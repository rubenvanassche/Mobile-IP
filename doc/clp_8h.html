<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Click: include/click/clp.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_38845554362b7075350137b91e3d2235.html">click</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">clp.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Functions for parsing command line options.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdarg.h&gt;</code><br />
</div>
<p><a href="clp_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_clp___option.html">Clp_Option</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option description.  <a href="struct_clp___option.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_clp___parser.html">Clp_Parser</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Command line parser.  <a href="struct_clp___parser.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a40b05a80c566714eee228a611fcaf2ef"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a40b05a80c566714eee228a611fcaf2ef">Clp_NotOption</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a40b05a80c566714eee228a611fcaf2ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clp_Next value: argument was not an option.  <a href="#a40b05a80c566714eee228a611fcaf2ef">More...</a><br /></td></tr>
<tr class="separator:a40b05a80c566714eee228a611fcaf2ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd465b8f9dbb7e2e4e5792faeb1455b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#acd465b8f9dbb7e2e4e5792faeb1455b9">Clp_Done</a>&#160;&#160;&#160;-1</td></tr>
<tr class="memdesc:acd465b8f9dbb7e2e4e5792faeb1455b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clp_Next value: there are no more arguments.  <a href="#acd465b8f9dbb7e2e4e5792faeb1455b9">More...</a><br /></td></tr>
<tr class="separator:acd465b8f9dbb7e2e4e5792faeb1455b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3805a3b884022d893c6dd5a55959a13b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a3805a3b884022d893c6dd5a55959a13b">Clp_BadOption</a>&#160;&#160;&#160;-2</td></tr>
<tr class="memdesc:a3805a3b884022d893c6dd5a55959a13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clp_Next value: argument was an erroneous option.  <a href="#a3805a3b884022d893c6dd5a55959a13b">More...</a><br /></td></tr>
<tr class="separator:a3805a3b884022d893c6dd5a55959a13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b60d105a4bca32d8266a53383babcd8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a2b60d105a4bca32d8266a53383babcd8">Clp_Error</a>&#160;&#160;&#160;-3</td></tr>
<tr class="memdesc:a2b60d105a4bca32d8266a53383babcd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clp_Next value: internal CLP error.  <a href="#a2b60d105a4bca32d8266a53383babcd8">More...</a><br /></td></tr>
<tr class="separator:a2b60d105a4bca32d8266a53383babcd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c2a847d29387e06c6707c2107af9e6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a59c2a847d29387e06c6707c2107af9e6">Clp_ValSize</a>&#160;&#160;&#160;40</td></tr>
<tr class="memdesc:a59c2a847d29387e06c6707c2107af9e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> val.cs field.  <a href="#a59c2a847d29387e06c6707c2107af9e6">More...</a><br /></td></tr>
<tr class="separator:a59c2a847d29387e06c6707c2107af9e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044c0c6889f95d0218bf784069d266b9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a044c0c6889f95d0218bf784069d266b9">Clp_ValIntSize</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:a044c0c6889f95d0218bf784069d266b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Minimum size of the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> val.is field.  <a href="#a044c0c6889f95d0218bf784069d266b9">More...</a><br /></td></tr>
<tr class="separator:a044c0c6889f95d0218bf784069d266b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadaae3812a754de330a2668e5381106d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aadaae3812a754de330a2668e5381106d">Clp_DisallowOptions</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="memdesc:aadaae3812a754de330a2668e5381106d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value type flag: value can't be an option string.  <a href="#aadaae3812a754de330a2668e5381106d">More...</a><br /></td></tr>
<tr class="separator:aadaae3812a754de330a2668e5381106d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fe7973f7c5dc730da07be3fddba5cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a48fe7973f7c5dc730da07be3fddba5cb">Clp_AllowNumbers</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="memdesc:a48fe7973f7c5dc730da07be3fddba5cb"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_string.html" title="A string of characters. ">String</a> list flag: allow explicit numbers.  <a href="#a48fe7973f7c5dc730da07be3fddba5cb">More...</a><br /></td></tr>
<tr class="separator:a48fe7973f7c5dc730da07be3fddba5cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affdf5b4e437c6f0e8f032a74aab8a175"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#affdf5b4e437c6f0e8f032a74aab8a175">Clp_StringListLong</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:affdf5b4e437c6f0e8f032a74aab8a175"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="class_string.html" title="A string of characters. ">String</a> list flag: values have long type.  <a href="#affdf5b4e437c6f0e8f032a74aab8a175">More...</a><br /></td></tr>
<tr class="separator:affdf5b4e437c6f0e8f032a74aab8a175"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Value types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These values describe the type of an option's argument and are used in the <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> val_type field. For example, if an option took integers, its <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> structure would have val_type set to Clp_ValInt. </p>
</div></td></tr>
<tr class="memitem:ad6193300b89a8f5f75884797b6df6187"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ad6193300b89a8f5f75884797b6df6187">Clp_NoVal</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:ad6193300b89a8f5f75884797b6df6187"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option takes no value.  <a href="#ad6193300b89a8f5f75884797b6df6187">More...</a><br /></td></tr>
<tr class="separator:ad6193300b89a8f5f75884797b6df6187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dba2867e5b401ef0522536de53ee5ba"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a8dba2867e5b401ef0522536de53ee5ba">Clp_ValString</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a8dba2867e5b401ef0522536de53ee5ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is an arbitrary string.  <a href="#a8dba2867e5b401ef0522536de53ee5ba">More...</a><br /></td></tr>
<tr class="separator:a8dba2867e5b401ef0522536de53ee5ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bd89a88c2d0633362fb81428cbdd62d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a9bd89a88c2d0633362fb81428cbdd62d">Clp_ValStringNotOption</a>&#160;&#160;&#160;2</td></tr>
<tr class="memdesc:a9bd89a88c2d0633362fb81428cbdd62d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is a non-option string.  <a href="#a9bd89a88c2d0633362fb81428cbdd62d">More...</a><br /></td></tr>
<tr class="separator:a9bd89a88c2d0633362fb81428cbdd62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01385c0aab20243071536dcebd431628"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a01385c0aab20243071536dcebd431628">Clp_ValBool</a>&#160;&#160;&#160;3</td></tr>
<tr class="memdesc:a01385c0aab20243071536dcebd431628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is a boolean.  <a href="#a01385c0aab20243071536dcebd431628">More...</a><br /></td></tr>
<tr class="separator:a01385c0aab20243071536dcebd431628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79deac4a5b9bab3b4d4f2f0bcbede13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ad79deac4a5b9bab3b4d4f2f0bcbede13">Clp_ValInt</a>&#160;&#160;&#160;4</td></tr>
<tr class="memdesc:ad79deac4a5b9bab3b4d4f2f0bcbede13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is a signed int.  <a href="#ad79deac4a5b9bab3b4d4f2f0bcbede13">More...</a><br /></td></tr>
<tr class="separator:ad79deac4a5b9bab3b4d4f2f0bcbede13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04037d6fee0f6e2f0af82fa447b35361"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a04037d6fee0f6e2f0af82fa447b35361">Clp_ValUnsigned</a>&#160;&#160;&#160;5</td></tr>
<tr class="memdesc:a04037d6fee0f6e2f0af82fa447b35361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is an unsigned int.  <a href="#a04037d6fee0f6e2f0af82fa447b35361">More...</a><br /></td></tr>
<tr class="separator:a04037d6fee0f6e2f0af82fa447b35361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b374c8ee3241193c5d9e789856f5d8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a92b374c8ee3241193c5d9e789856f5d8">Clp_ValLong</a>&#160;&#160;&#160;6</td></tr>
<tr class="memdesc:a92b374c8ee3241193c5d9e789856f5d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is a signed long.  <a href="#a92b374c8ee3241193c5d9e789856f5d8">More...</a><br /></td></tr>
<tr class="separator:a92b374c8ee3241193c5d9e789856f5d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb83952d0dc6d927d69acd657b316bda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#abb83952d0dc6d927d69acd657b316bda">Clp_ValUnsignedLong</a>&#160;&#160;&#160;7</td></tr>
<tr class="memdesc:abb83952d0dc6d927d69acd657b316bda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is an unsigned long.  <a href="#abb83952d0dc6d927d69acd657b316bda">More...</a><br /></td></tr>
<tr class="separator:abb83952d0dc6d927d69acd657b316bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8f1dda38e3df65e13c0b97f7c905df5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aa8f1dda38e3df65e13c0b97f7c905df5">Clp_ValDouble</a>&#160;&#160;&#160;8</td></tr>
<tr class="memdesc:aa8f1dda38e3df65e13c0b97f7c905df5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option value is a double. Accepts a real number as defined by strtod().  <a href="#aa8f1dda38e3df65e13c0b97f7c905df5">More...</a><br /></td></tr>
<tr class="separator:aa8f1dda38e3df65e13c0b97f7c905df5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d808d518d5e15b8286f6f774269fe"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ada2d808d518d5e15b8286f6f774269fe">Clp_ValFirstUser</a>&#160;&#160;&#160;10</td></tr>
<tr class="memdesc:ada2d808d518d5e15b8286f6f774269fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Value types &gt;= Clp_ValFirstUser are available for user types.  <a href="#ada2d808d518d5e15b8286f6f774269fe">More...</a><br /></td></tr>
<tr class="separator:ada2d808d518d5e15b8286f6f774269fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Option flags</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags are used in the <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> flags field. </p>
</div></td></tr>
<tr class="memitem:a32521fdfddfee4d1dec74aaf7f89866a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a32521fdfddfee4d1dec74aaf7f89866a">Clp_Mandatory</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="memdesc:a32521fdfddfee4d1dec74aaf7f89866a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option flag: value is mandatory.  <a href="#a32521fdfddfee4d1dec74aaf7f89866a">More...</a><br /></td></tr>
<tr class="separator:a32521fdfddfee4d1dec74aaf7f89866a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3004600a3b7bbcc0f4ebc0acf5203d9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ab3004600a3b7bbcc0f4ebc0acf5203d9">Clp_Optional</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:ab3004600a3b7bbcc0f4ebc0acf5203d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option flag: value is optional.  <a href="#ab3004600a3b7bbcc0f4ebc0acf5203d9">More...</a><br /></td></tr>
<tr class="separator:ab3004600a3b7bbcc0f4ebc0acf5203d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a9d9efc4e6b2bb80c4de8c9d75324f9"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a1a9d9efc4e6b2bb80c4de8c9d75324f9">Clp_Negate</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:a1a9d9efc4e6b2bb80c4de8c9d75324f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option flag: option may be negated.  <a href="#a1a9d9efc4e6b2bb80c4de8c9d75324f9">More...</a><br /></td></tr>
<tr class="separator:a1a9d9efc4e6b2bb80c4de8c9d75324f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2504d39dbdfc50d28be6489bf238a03"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ac2504d39dbdfc50d28be6489bf238a03">Clp_OnlyNegated</a>&#160;&#160;&#160;(1&lt;&lt;3)</td></tr>
<tr class="memdesc:ac2504d39dbdfc50d28be6489bf238a03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option flag: option <em>must</em> be negated.  <a href="#ac2504d39dbdfc50d28be6489bf238a03">More...</a><br /></td></tr>
<tr class="separator:ac2504d39dbdfc50d28be6489bf238a03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5039c3d55e8a6b77f25655b2faf8d47e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a5039c3d55e8a6b77f25655b2faf8d47e">Clp_PreferredMatch</a>&#160;&#160;&#160;(1&lt;&lt;4)</td></tr>
<tr class="memdesc:a5039c3d55e8a6b77f25655b2faf8d47e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option flag: prefer this option when matching.  <a href="#a5039c3d55e8a6b77f25655b2faf8d47e">More...</a><br /></td></tr>
<tr class="separator:a5039c3d55e8a6b77f25655b2faf8d47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Option character types</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These flags are used in to define character types in <a class="el" href="clp_8h.html#a794f6e4c42d4059ab58cb4b6fc1901a7" title="Set clp&#39;s treatment of character c. ">Clp_SetOptionChar()</a>. </p>
</div></td></tr>
<tr class="memitem:ad2ebb516efea4c2563bb96b15e2bdfc2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ad2ebb516efea4c2563bb96b15e2bdfc2">Clp_Short</a>&#160;&#160;&#160;(1&lt;&lt;0)</td></tr>
<tr class="memdesc:ad2ebb516efea4c2563bb96b15e2bdfc2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option character begins a set of short options.  <a href="#ad2ebb516efea4c2563bb96b15e2bdfc2">More...</a><br /></td></tr>
<tr class="separator:ad2ebb516efea4c2563bb96b15e2bdfc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ba38dc7249170c733318af309d71c0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ab5ba38dc7249170c733318af309d71c0">Clp_Long</a>&#160;&#160;&#160;(1&lt;&lt;1)</td></tr>
<tr class="memdesc:ab5ba38dc7249170c733318af309d71c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option character begins a long option.  <a href="#ab5ba38dc7249170c733318af309d71c0">More...</a><br /></td></tr>
<tr class="separator:ab5ba38dc7249170c733318af309d71c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162d08b4410037dfb4e50d0828822818"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a162d08b4410037dfb4e50d0828822818">Clp_ShortNegated</a>&#160;&#160;&#160;(1&lt;&lt;2)</td></tr>
<tr class="memdesc:a162d08b4410037dfb4e50d0828822818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option character begins a set of negated short options.  <a href="#a162d08b4410037dfb4e50d0828822818">More...</a><br /></td></tr>
<tr class="separator:a162d08b4410037dfb4e50d0828822818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abadde51c6f853d277b28dd14c4b2e15e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#abadde51c6f853d277b28dd14c4b2e15e">Clp_LongNegated</a>&#160;&#160;&#160;(1&lt;&lt;3)</td></tr>
<tr class="memdesc:abadde51c6f853d277b28dd14c4b2e15e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option character begins a negated long option.  <a href="#abadde51c6f853d277b28dd14c4b2e15e">More...</a><br /></td></tr>
<tr class="separator:abadde51c6f853d277b28dd14c4b2e15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8b8da67ac00baab0b21182cc181551"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#abd8b8da67ac00baab0b21182cc181551">Clp_LongImplicit</a>&#160;&#160;&#160;(1&lt;&lt;4)</td></tr>
<tr class="memdesc:abd8b8da67ac00baab0b21182cc181551"><td class="mdescLeft">&#160;</td><td class="mdescRight">Option character can begin a long option, and is part of that long option.  <a href="#abd8b8da67ac00baab0b21182cc181551">More...</a><br /></td></tr>
<tr class="separator:abd8b8da67ac00baab0b21182cc181551"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afaaf38f983051f134d0026476b0141db"><td class="memItemLeft" align="right" valign="top"><a id="afaaf38f983051f134d0026476b0141db"></a>
typedef struct <a class="el" href="struct_clp___option.html">Clp_Option</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Clp_Option</b></td></tr>
<tr class="separator:afaaf38f983051f134d0026476b0141db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b09f94ac08b67e66a8fac854e96d0a"><td class="memItemLeft" align="right" valign="top"><a id="a81b09f94ac08b67e66a8fac854e96d0a"></a>
typedef struct <a class="el" href="struct_clp___parser.html">Clp_Parser</a>&#160;</td><td class="memItemRight" valign="bottom"><b>Clp_Parser</b></td></tr>
<tr class="separator:a81b09f94ac08b67e66a8fac854e96d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b81a6a7469d6d746dacbdbbc88fa358"><td class="memItemLeft" align="right" valign="top"><a id="a3b81a6a7469d6d746dacbdbbc88fa358"></a>
typedef struct Clp_ParserState&#160;</td><td class="memItemRight" valign="bottom"><b>Clp_ParserState</b></td></tr>
<tr class="separator:a3b81a6a7469d6d746dacbdbbc88fa358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e6c19149ad51432fbc57024136ec72"><td class="memItemLeft" align="right" valign="top">typedef int(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ac4e6c19149ad51432fbc57024136ec72">Clp_ValParseFunc</a>) (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *vstr, int complain, void *user_data)</td></tr>
<tr class="memdesc:ac4e6c19149ad51432fbc57024136ec72"><td class="mdescLeft">&#160;</td><td class="mdescRight">A value parsing function.  <a href="#ac4e6c19149ad51432fbc57024136ec72">More...</a><br /></td></tr>
<tr class="separator:ac4e6c19149ad51432fbc57024136ec72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4546844b1b958b92be2b085e3e3dc7b7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a4546844b1b958b92be2b085e3e3dc7b7">Clp_ErrorHandler</a>) (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *message)</td></tr>
<tr class="memdesc:a4546844b1b958b92be2b085e3e3dc7b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function for reporting option errors.  <a href="#a4546844b1b958b92be2b085e3e3dc7b7">More...</a><br /></td></tr>
<tr class="separator:a4546844b1b958b92be2b085e3e3dc7b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a270e4dd45e742993d34faf16ea1f0339"><td class="memItemLeft" align="right" valign="top"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a270e4dd45e742993d34faf16ea1f0339">Clp_NewParser</a> (int argc, const char *const *argv, int nopt, const <a class="el" href="struct_clp___option.html">Clp_Option</a> *opt)</td></tr>
<tr class="memdesc:a270e4dd45e742993d34faf16ea1f0339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a>.  <a href="#a270e4dd45e742993d34faf16ea1f0339">More...</a><br /></td></tr>
<tr class="separator:a270e4dd45e742993d34faf16ea1f0339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6da540eb93d3411089e5ff92e3d3f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aea6da540eb93d3411089e5ff92e3d3f3">Clp_DeleteParser</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp)</td></tr>
<tr class="memdesc:aea6da540eb93d3411089e5ff92e3d3f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> object.  <a href="#aea6da540eb93d3411089e5ff92e3d3f3">More...</a><br /></td></tr>
<tr class="separator:aea6da540eb93d3411089e5ff92e3d3f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccf6dd0a5d839163029db3dddbdda00"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#afccf6dd0a5d839163029db3dddbdda00">Clp_ProgramName</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp)</td></tr>
<tr class="memdesc:afccf6dd0a5d839163029db3dddbdda00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>clp's</em> program name.  <a href="#afccf6dd0a5d839163029db3dddbdda00">More...</a><br /></td></tr>
<tr class="separator:afccf6dd0a5d839163029db3dddbdda00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af006f0973eadd6ec5194cc6659e1f097"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#af006f0973eadd6ec5194cc6659e1f097">Clp_SetProgramName</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *name)</td></tr>
<tr class="memdesc:af006f0973eadd6ec5194cc6659e1f097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> program name.  <a href="#af006f0973eadd6ec5194cc6659e1f097">More...</a><br /></td></tr>
<tr class="separator:af006f0973eadd6ec5194cc6659e1f097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56e71af19d651c7780c767b7219328f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="clp_8h.html#a4546844b1b958b92be2b085e3e3dc7b7">Clp_ErrorHandler</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ae56e71af19d651c7780c767b7219328f">Clp_SetErrorHandler</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, <a class="el" href="clp_8h.html#a4546844b1b958b92be2b085e3e3dc7b7">Clp_ErrorHandler</a> errh)</td></tr>
<tr class="memdesc:ae56e71af19d651c7780c767b7219328f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> error handler function.  <a href="#ae56e71af19d651c7780c767b7219328f">More...</a><br /></td></tr>
<tr class="separator:ae56e71af19d651c7780c767b7219328f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d94782d5752d5ae06f9528c0b3bb02"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#af6d94782d5752d5ae06f9528c0b3bb02">Clp_SetUTF8</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int utf8)</td></tr>
<tr class="memdesc:af6d94782d5752d5ae06f9528c0b3bb02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> UTF-8 mode.  <a href="#af6d94782d5752d5ae06f9528c0b3bb02">More...</a><br /></td></tr>
<tr class="separator:af6d94782d5752d5ae06f9528c0b3bb02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10a2fbec13da38a1b7d62fa7c0e0af75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a10a2fbec13da38a1b7d62fa7c0e0af75">Clp_OptionChar</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int c)</td></tr>
<tr class="memdesc:a10a2fbec13da38a1b7d62fa7c0e0af75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <em>clp's</em> treatment of character <em>c</em>.  <a href="#a10a2fbec13da38a1b7d62fa7c0e0af75">More...</a><br /></td></tr>
<tr class="separator:a10a2fbec13da38a1b7d62fa7c0e0af75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a794f6e4c42d4059ab58cb4b6fc1901a7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a794f6e4c42d4059ab58cb4b6fc1901a7">Clp_SetOptionChar</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int c, int type)</td></tr>
<tr class="memdesc:a794f6e4c42d4059ab58cb4b6fc1901a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> treatment of character <em>c</em>.  <a href="#a794f6e4c42d4059ab58cb4b6fc1901a7">More...</a><br /></td></tr>
<tr class="separator:a794f6e4c42d4059ab58cb4b6fc1901a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a047236bad3cb1558a0e2939344ff9f12"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a047236bad3cb1558a0e2939344ff9f12">Clp_SetOptions</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int nopt, const <a class="el" href="struct_clp___option.html">Clp_Option</a> *opt)</td></tr>
<tr class="memdesc:a047236bad3cb1558a0e2939344ff9f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> option definitions.  <a href="#a047236bad3cb1558a0e2939344ff9f12">More...</a><br /></td></tr>
<tr class="separator:a047236bad3cb1558a0e2939344ff9f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10809101ba870d1f719799f86ce8b86b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a10809101ba870d1f719799f86ce8b86b">Clp_SetArguments</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int argc, const char *const *argv)</td></tr>
<tr class="memdesc:a10809101ba870d1f719799f86ce8b86b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>clp's</em> arguments.  <a href="#a10809101ba870d1f719799f86ce8b86b">More...</a><br /></td></tr>
<tr class="separator:a10809101ba870d1f719799f86ce8b86b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499871c3e356d606c35a85349bc228c3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a499871c3e356d606c35a85349bc228c3">Clp_SetOptionProcessing</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int on)</td></tr>
<tr class="memdesc:a499871c3e356d606c35a85349bc228c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set whether <em>clp</em> is searching for options.  <a href="#a499871c3e356d606c35a85349bc228c3">More...</a><br /></td></tr>
<tr class="separator:a499871c3e356d606c35a85349bc228c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa96cff96af6c8463904a66c1027868d4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aa96cff96af6c8463904a66c1027868d4">Clp_AddType</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int val_type, int flags, <a class="el" href="clp_8h.html#ac4e6c19149ad51432fbc57024136ec72">Clp_ValParseFunc</a> parser, void *user_data)</td></tr>
<tr class="memdesc:aa96cff96af6c8463904a66c1027868d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new value type for <em>clp</em>.  <a href="#aa96cff96af6c8463904a66c1027868d4">More...</a><br /></td></tr>
<tr class="separator:aa96cff96af6c8463904a66c1027868d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83ecc57d06505e3f9154c8a85e5b2f6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a83ecc57d06505e3f9154c8a85e5b2f6d">Clp_AddStringListTypeVec</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int val_type, int flags, int nstrs, const char *const *strs, const int *vals)</td></tr>
<tr class="memdesc:a83ecc57d06505e3f9154c8a85e5b2f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new string list value type for <em>clp</em>.  <a href="#a83ecc57d06505e3f9154c8a85e5b2f6d">More...</a><br /></td></tr>
<tr class="separator:a83ecc57d06505e3f9154c8a85e5b2f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413eb61d972d0bde99c74ccd04943d46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a413eb61d972d0bde99c74ccd04943d46">Clp_AddStringListType</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int val_type, int flags,...) CLP_SENTINEL</td></tr>
<tr class="memdesc:a413eb61d972d0bde99c74ccd04943d46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a new string list value type for <em>clp</em>.  <a href="#a413eb61d972d0bde99c74ccd04943d46">More...</a><br /></td></tr>
<tr class="separator:a413eb61d972d0bde99c74ccd04943d46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5b3c63a6091476e79f30a6fd17bcf29"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29">Clp_Next</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp)</td></tr>
<tr class="memdesc:ac5b3c63a6091476e79f30a6fd17bcf29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and return the next argument from <em>clp</em>.  <a href="#ac5b3c63a6091476e79f30a6fd17bcf29">More...</a><br /></td></tr>
<tr class="separator:ac5b3c63a6091476e79f30a6fd17bcf29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5fc3ebb27b87f9ae6cdb42b099df041"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ad5fc3ebb27b87f9ae6cdb42b099df041">Clp_Shift</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int allow_options)</td></tr>
<tr class="memdesc:ad5fc3ebb27b87f9ae6cdb42b099df041"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the next argument from <em>clp</em> without option parsing.  <a href="#ad5fc3ebb27b87f9ae6cdb42b099df041">More...</a><br /></td></tr>
<tr class="separator:ad5fc3ebb27b87f9ae6cdb42b099df041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b2afa7cdc5f8ce171d8292c41f9844e"><td class="memItemLeft" align="right" valign="top">Clp_ParserState *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a2b2afa7cdc5f8ce171d8292c41f9844e">Clp_NewParserState</a> (void)</td></tr>
<tr class="memdesc:a2b2afa7cdc5f8ce171d8292c41f9844e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new Clp_ParserState.  <a href="#a2b2afa7cdc5f8ce171d8292c41f9844e">More...</a><br /></td></tr>
<tr class="separator:a2b2afa7cdc5f8ce171d8292c41f9844e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98193f79510e5f8badc592b469e59d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ad98193f79510e5f8badc592b469e59d2">Clp_DeleteParserState</a> (Clp_ParserState *state)</td></tr>
<tr class="memdesc:ad98193f79510e5f8badc592b469e59d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a Clp_ParserState object.  <a href="#ad98193f79510e5f8badc592b469e59d2">More...</a><br /></td></tr>
<tr class="separator:ad98193f79510e5f8badc592b469e59d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef9732aa7f7cdb2f70ee45190602c00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a9ef9732aa7f7cdb2f70ee45190602c00">Clp_SaveParser</a> (const <a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, Clp_ParserState *state)</td></tr>
<tr class="memdesc:a9ef9732aa7f7cdb2f70ee45190602c00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save <em>clp's</em> current state in <em>state</em>.  <a href="#a9ef9732aa7f7cdb2f70ee45190602c00">More...</a><br /></td></tr>
<tr class="separator:a9ef9732aa7f7cdb2f70ee45190602c00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388966eff308f6c76d87138d1762f02c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a388966eff308f6c76d87138d1762f02c">Clp_RestoreParser</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const Clp_ParserState *state)</td></tr>
<tr class="memdesc:a388966eff308f6c76d87138d1762f02c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Restore parser state from <em>state</em> into <em>clp</em>.  <a href="#a388966eff308f6c76d87138d1762f02c">More...</a><br /></td></tr>
<tr class="separator:a388966eff308f6c76d87138d1762f02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fdafd3a1bd98eb6dbd60d9a61baf480"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a7fdafd3a1bd98eb6dbd60d9a61baf480">Clp_OptionError</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *format,...)</td></tr>
<tr class="memdesc:a7fdafd3a1bd98eb6dbd60d9a61baf480"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a parser error.  <a href="#a7fdafd3a1bd98eb6dbd60d9a61baf480">More...</a><br /></td></tr>
<tr class="separator:a7fdafd3a1bd98eb6dbd60d9a61baf480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4beed00f3ce4112161bacd2968928f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ada4beed00f3ce4112161bacd2968928f">Clp_vsnprintf</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, char *str, size_t size, const char *format, va_list val)</td></tr>
<tr class="memdesc:ada4beed00f3ce4112161bacd2968928f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Format a message.  <a href="#ada4beed00f3ce4112161bacd2968928f">More...</a><br /></td></tr>
<tr class="separator:ada4beed00f3ce4112161bacd2968928f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7993eb9617bb3a8f1bad9ba1aa2cb8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aca7993eb9617bb3a8f1bad9ba1aa2cb8">Clp_fprintf</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, FILE *f, const char *format,...)</td></tr>
<tr class="memdesc:aca7993eb9617bb3a8f1bad9ba1aa2cb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message.  <a href="#aca7993eb9617bb3a8f1bad9ba1aa2cb8">More...</a><br /></td></tr>
<tr class="separator:aca7993eb9617bb3a8f1bad9ba1aa2cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18ade25435d31c9ffd713d695fb50f80"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a18ade25435d31c9ffd713d695fb50f80">Clp_vfprintf</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, FILE *f, const char *format, va_list val)</td></tr>
<tr class="memdesc:a18ade25435d31c9ffd713d695fb50f80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a message.  <a href="#a18ade25435d31c9ffd713d695fb50f80">More...</a><br /></td></tr>
<tr class="separator:a18ade25435d31c9ffd713d695fb50f80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c487d36991a3ade60b4650fb117c394"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#a9c487d36991a3ade60b4650fb117c394">Clp_CurOptionNameBuf</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, char *buf, int len)</td></tr>
<tr class="memdesc:a9c487d36991a3ade60b4650fb117c394"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the current option as a string.  <a href="#a9c487d36991a3ade60b4650fb117c394">More...</a><br /></td></tr>
<tr class="separator:a9c487d36991a3ade60b4650fb117c394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8eea106a829b4f7a07e3592d459875c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aa8eea106a829b4f7a07e3592d459875c">Clp_CurOptionName</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp)</td></tr>
<tr class="memdesc:aa8eea106a829b4f7a07e3592d459875c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the current option as a string.  <a href="#aa8eea106a829b4f7a07e3592d459875c">More...</a><br /></td></tr>
<tr class="separator:aa8eea106a829b4f7a07e3592d459875c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5bf5a1363019da8d5cd6be6cdcd4416"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#ae5bf5a1363019da8d5cd6be6cdcd4416">Clp_IsLong</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *long_name)</td></tr>
<tr class="memdesc:ae5bf5a1363019da8d5cd6be6cdcd4416"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the current option had long name <em>name</em>.  <a href="#ae5bf5a1363019da8d5cd6be6cdcd4416">More...</a><br /></td></tr>
<tr class="separator:ae5bf5a1363019da8d5cd6be6cdcd4416"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa23693e1785a3917817778540ab94566"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="clp_8h.html#aa23693e1785a3917817778540ab94566">Clp_IsShort</a> (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, int short_name)</td></tr>
<tr class="memdesc:aa23693e1785a3917817778540ab94566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if the current option had short name <em>name</em>.  <a href="#aa23693e1785a3917817778540ab94566">More...</a><br /></td></tr>
<tr class="separator:aa23693e1785a3917817778540ab94566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Functions for parsing command line options. </p>
<p>The CLP functions are used to parse command line arugments into options. It automatically handles value parsing, error messages, long options with minimum prefix matching, short options, and negated options.</p>
<p>The CLP model works like this.</p>
<ol>
<li>
The user declares an array of <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> structures that define the options their program accepts. </li>
<li>
The user creates a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> object using <a class="el" href="clp_8h.html#a270e4dd45e742993d34faf16ea1f0339" title="Create a new Clp_Parser. ">Clp_NewParser()</a>, passing in the command line arguments to parse and the <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> structures. </li>
<li>
A loop repeatedly calls <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> to parse the arguments. </li>
</ol>
<p>Unlike many command line parsing libraries, CLP steps through all arguments one at a time, rather than slurping up all options at once. This makes it meaningful to give an option more than once.</p>
<p>Here's an example.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define ANIMAL_OPT 1</span></div><div class="line"><span class="preprocessor">#define VEGETABLE_OPT 2</span></div><div class="line"><span class="preprocessor">#define MINERALS_OPT 3</span></div><div class="line"><span class="preprocessor">#define USAGE_OPT 4</span></div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="struct_clp___option.html">Clp_Option</a> options[] = {</div><div class="line">    { <span class="stringliteral">&quot;animal&quot;</span>, <span class="charliteral">&#39;a&#39;</span>, ANIMAL_OPT, <a class="code" href="clp_8h.html#a8dba2867e5b401ef0522536de53ee5ba">Clp_ValString</a>, 0 },</div><div class="line">    { <span class="stringliteral">&quot;vegetable&quot;</span>, <span class="charliteral">&#39;v&#39;</span>, VEGETABLE_OPT, <a class="code" href="clp_8h.html#a8dba2867e5b401ef0522536de53ee5ba">Clp_ValString</a>, <a class="code" href="clp_8h.html#a1a9d9efc4e6b2bb80c4de8c9d75324f9">Clp_Negate</a> | <a class="code" href="clp_8h.html#ab3004600a3b7bbcc0f4ebc0acf5203d9">Clp_Optional</a> },</div><div class="line">    { <span class="stringliteral">&quot;minerals&quot;</span>, <span class="charliteral">&#39;m&#39;</span>, MINERALS_OPT, <a class="code" href="clp_8h.html#ad79deac4a5b9bab3b4d4f2f0bcbede13">Clp_ValInt</a>, 0 },</div><div class="line">    { <span class="stringliteral">&quot;usage&quot;</span>, 0, USAGE_OPT, 0, 0 }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) {</div><div class="line">    <a class="code" href="struct_clp___parser.html">Clp_Parser</a> *clp = <a class="code" href="clp_8h.html#a270e4dd45e742993d34faf16ea1f0339">Clp_NewParser</a>(argc, argv,</div><div class="line">              <span class="keyword">sizeof</span>(options) / <span class="keyword">sizeof</span>(options[0]), options);</div><div class="line">    <span class="keywordtype">int</span> opt;</div><div class="line">    <span class="keywordflow">while</span> ((opt = <a class="code" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29">Clp_Next</a>(clp)) != <a class="code" href="clp_8h.html#acd465b8f9dbb7e2e4e5792faeb1455b9">Clp_Done</a>)</div><div class="line">        <span class="keywordflow">switch</span> (opt) {</div><div class="line">        <span class="keywordflow">case</span> ANIMAL_OPT:</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;animal is %s\n&quot;</span>, clp-&gt;<a class="code" href="struct_clp___parser.html#ab8172793e51e632725e85e1091aada07">val</a>.s);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> VEGETABLE_OPT:</div><div class="line">            <span class="keywordflow">if</span> (clp-&gt;<a class="code" href="struct_clp___parser.html#aabb319a8975ee8c6706fa4098f84b67e">negated</a>)</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;no vegetables!\n&quot;</span>);</div><div class="line">            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (clp-&gt;<a class="code" href="struct_clp___parser.html#a438e2061f363d48ebb5225653c9521de">have_val</a>)</div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;vegetable is %s\n&quot;</span>, clp-&gt;<a class="code" href="struct_clp___parser.html#ab8172793e51e632725e85e1091aada07">val</a>.s);</div><div class="line">            <span class="keywordflow">else</span></div><div class="line">                fprintf(stderr, <span class="stringliteral">&quot;vegetables OK\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> MINERALS_OPT:</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;%d minerals\n&quot;</span>, clp-&gt;<a class="code" href="struct_clp___parser.html#ab8172793e51e632725e85e1091aada07">val</a>.i);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> USAGE_OPT:</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;Usage: 20q [--animal=ANIMAL] [--vegetable[=VEGETABLE]] [--minerals=N]\n&quot;</span>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        <span class="keywordflow">case</span> <a class="code" href="clp_8h.html#a40b05a80c566714eee228a611fcaf2ef">Clp_NotOption</a>:</div><div class="line">            fprintf(stderr, <span class="stringliteral">&quot;non-option %s\n&quot;</span>, clp-&gt;<a class="code" href="struct_clp___parser.html#a4e2cd802900da5a9873ed4ad49fdbcb4">vstr</a>);</div><div class="line">            <span class="keywordflow">break</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Here are a couple of executions.</p>
<pre>
% ./20q &ndash;animal=cat
animal is cat
% ./20q &ndash;animal=cat -a dog -afish &ndash;animal bird &ndash;an=snake
animal is cat
animal is dog
animal is fish
animal is bird
animal is snake
% ./20q &ndash;no-vegetables
no vegetables!
% ./20q -v
vegetables OK
% ./20q -vkale
vegetable is kale
% ./20q -m10
10 minerals
% ./20q -m foo
'-m' expects an integer, not 'foo'
</pre> </div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ad6193300b89a8f5f75884797b6df6187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6193300b89a8f5f75884797b6df6187">&#9670;&nbsp;</a></span>Clp_NoVal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_NoVal&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option takes no value. </p>

</div>
</div>
<a id="a8dba2867e5b401ef0522536de53ee5ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dba2867e5b401ef0522536de53ee5ba">&#9670;&nbsp;</a></span>Clp_ValString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValString&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is an arbitrary string. </p>

</div>
</div>
<a id="a9bd89a88c2d0633362fb81428cbdd62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bd89a88c2d0633362fb81428cbdd62d">&#9670;&nbsp;</a></span>Clp_ValStringNotOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValStringNotOption&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is a non-option string. </p>
<p>See Clp_DisallowOptions. </p>

</div>
</div>
<a id="a01385c0aab20243071536dcebd431628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01385c0aab20243071536dcebd431628">&#9670;&nbsp;</a></span>Clp_ValBool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValBool&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is a boolean. </p>
<p>Accepts "true", "false", "yes", "no", "1", and "0", or any prefixes thereof. The match is case-insensitive. </p>

</div>
</div>
<a id="ad79deac4a5b9bab3b4d4f2f0bcbede13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79deac4a5b9bab3b4d4f2f0bcbede13">&#9670;&nbsp;</a></span>Clp_ValInt</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValInt&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is a signed int. </p>
<p>Accepts an optional "+" or "-" sign, followed by one or more digits. The digits may be include a "0x" or "0X" prefix, for a hexadecimal number, or a "0" prefix, for an octal number; otherwise it is decimal. </p>

</div>
</div>
<a id="a04037d6fee0f6e2f0af82fa447b35361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04037d6fee0f6e2f0af82fa447b35361">&#9670;&nbsp;</a></span>Clp_ValUnsigned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValUnsigned&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is an unsigned int. </p>
<p>Accepts an optional "+" sign, followed by one or more digits. The digits may be include a "0x" or "0X" prefix, for a hexadecimal number, or a "0" prefix, for an octal number; otherwise it is decimal. </p>

</div>
</div>
<a id="a92b374c8ee3241193c5d9e789856f5d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b374c8ee3241193c5d9e789856f5d8">&#9670;&nbsp;</a></span>Clp_ValLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValLong&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is a signed long. </p>

</div>
</div>
<a id="abb83952d0dc6d927d69acd657b316bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb83952d0dc6d927d69acd657b316bda">&#9670;&nbsp;</a></span>Clp_ValUnsignedLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValUnsignedLong&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is an unsigned long. </p>

</div>
</div>
<a id="aa8f1dda38e3df65e13c0b97f7c905df5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8f1dda38e3df65e13c0b97f7c905df5">&#9670;&nbsp;</a></span>Clp_ValDouble</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValDouble&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option value is a double. Accepts a real number as defined by strtod(). </p>

</div>
</div>
<a id="ada2d808d518d5e15b8286f6f774269fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2d808d518d5e15b8286f6f774269fe">&#9670;&nbsp;</a></span>Clp_ValFirstUser</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValFirstUser&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value types &gt;= Clp_ValFirstUser are available for user types. </p>

</div>
</div>
<a id="a32521fdfddfee4d1dec74aaf7f89866a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32521fdfddfee4d1dec74aaf7f89866a">&#9670;&nbsp;</a></span>Clp_Mandatory</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Mandatory&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option flag: value is mandatory. </p>
<p>It is an error if the option has no value. This is the default if an option has arg_type != 0 and the Clp_Optional flag is not provided. </p>

</div>
</div>
<a id="ab3004600a3b7bbcc0f4ebc0acf5203d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3004600a3b7bbcc0f4ebc0acf5203d9">&#9670;&nbsp;</a></span>Clp_Optional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Optional&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option flag: value is optional. </p>

</div>
</div>
<a id="a1a9d9efc4e6b2bb80c4de8c9d75324f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a9d9efc4e6b2bb80c4de8c9d75324f9">&#9670;&nbsp;</a></span>Clp_Negate</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Negate&#160;&#160;&#160;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option flag: option may be negated. </p>
<p>&ndash;no-[long_name] will be accepted in argument lists. </p>

</div>
</div>
<a id="ac2504d39dbdfc50d28be6489bf238a03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2504d39dbdfc50d28be6489bf238a03">&#9670;&nbsp;</a></span>Clp_OnlyNegated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_OnlyNegated&#160;&#160;&#160;(1&lt;&lt;3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option flag: option <em>must</em> be negated. </p>
<p>&ndash;no-[long_name] will be accepted in argument lists, but &ndash;[long_name] will not. This is the default if long_name begins with "no-". </p>

</div>
</div>
<a id="a5039c3d55e8a6b77f25655b2faf8d47e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5039c3d55e8a6b77f25655b2faf8d47e">&#9670;&nbsp;</a></span>Clp_PreferredMatch</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_PreferredMatch&#160;&#160;&#160;(1&lt;&lt;4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option flag: prefer this option when matching. </p>
<p>Prefixes of &ndash;[long_name] should map to this option, even if other options begin with &ndash;[long_name]. </p>

</div>
</div>
<a id="ad2ebb516efea4c2563bb96b15e2bdfc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ebb516efea4c2563bb96b15e2bdfc2">&#9670;&nbsp;</a></span>Clp_Short</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Short&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option character begins a set of short options. </p>

</div>
</div>
<a id="ab5ba38dc7249170c733318af309d71c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ba38dc7249170c733318af309d71c0">&#9670;&nbsp;</a></span>Clp_Long</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Long&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option character begins a long option. </p>

</div>
</div>
<a id="a162d08b4410037dfb4e50d0828822818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162d08b4410037dfb4e50d0828822818">&#9670;&nbsp;</a></span>Clp_ShortNegated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ShortNegated&#160;&#160;&#160;(1&lt;&lt;2)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option character begins a set of negated short options. </p>

</div>
</div>
<a id="abadde51c6f853d277b28dd14c4b2e15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abadde51c6f853d277b28dd14c4b2e15e">&#9670;&nbsp;</a></span>Clp_LongNegated</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_LongNegated&#160;&#160;&#160;(1&lt;&lt;3)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option character begins a negated long option. </p>

</div>
</div>
<a id="abd8b8da67ac00baab0b21182cc181551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8b8da67ac00baab0b21182cc181551">&#9670;&nbsp;</a></span>Clp_LongImplicit</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_LongImplicit&#160;&#160;&#160;(1&lt;&lt;4)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Option character can begin a long option, and is part of that long option. </p>

</div>
</div>
<a id="a40b05a80c566714eee228a611fcaf2ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b05a80c566714eee228a611fcaf2ef">&#9670;&nbsp;</a></span>Clp_NotOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_NotOption&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clp_Next value: argument was not an option. </p>

</div>
</div>
<a id="acd465b8f9dbb7e2e4e5792faeb1455b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd465b8f9dbb7e2e4e5792faeb1455b9">&#9670;&nbsp;</a></span>Clp_Done</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Done&#160;&#160;&#160;-1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clp_Next value: there are no more arguments. </p>

</div>
</div>
<a id="a3805a3b884022d893c6dd5a55959a13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3805a3b884022d893c6dd5a55959a13b">&#9670;&nbsp;</a></span>Clp_BadOption</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_BadOption&#160;&#160;&#160;-2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clp_Next value: argument was an erroneous option. </p>

</div>
</div>
<a id="a2b60d105a4bca32d8266a53383babcd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b60d105a4bca32d8266a53383babcd8">&#9670;&nbsp;</a></span>Clp_Error</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_Error&#160;&#160;&#160;-3</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clp_Next value: internal CLP error. </p>

</div>
</div>
<a id="a59c2a847d29387e06c6707c2107af9e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c2a847d29387e06c6707c2107af9e6">&#9670;&nbsp;</a></span>Clp_ValSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValSize&#160;&#160;&#160;40</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum size of the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> val.cs field. </p>

</div>
</div>
<a id="a044c0c6889f95d0218bf784069d266b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044c0c6889f95d0218bf784069d266b9">&#9670;&nbsp;</a></span>Clp_ValIntSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_ValIntSize&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Minimum size of the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> val.is field. </p>

</div>
</div>
<a id="aadaae3812a754de330a2668e5381106d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadaae3812a754de330a2668e5381106d">&#9670;&nbsp;</a></span>Clp_DisallowOptions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_DisallowOptions&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Value type flag: value can't be an option string. </p>
<p>See <a class="el" href="clp_8h.html#aa96cff96af6c8463904a66c1027868d4" title="Define a new value type for clp. ">Clp_AddType()</a>. </p>

</div>
</div>
<a id="a48fe7973f7c5dc730da07be3fddba5cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fe7973f7c5dc730da07be3fddba5cb">&#9670;&nbsp;</a></span>Clp_AllowNumbers</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_AllowNumbers&#160;&#160;&#160;(1&lt;&lt;0)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_string.html" title="A string of characters. ">String</a> list flag: allow explicit numbers. </p>
<p>See <a class="el" href="clp_8h.html#a413eb61d972d0bde99c74ccd04943d46" title="Define a new string list value type for clp. ">Clp_AddStringListType()</a> and <a class="el" href="clp_8h.html#a83ecc57d06505e3f9154c8a85e5b2f6d" title="Define a new string list value type for clp. ">Clp_AddStringListTypeVec()</a>. </p>

</div>
</div>
<a id="affdf5b4e437c6f0e8f032a74aab8a175"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affdf5b4e437c6f0e8f032a74aab8a175">&#9670;&nbsp;</a></span>Clp_StringListLong</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define Clp_StringListLong&#160;&#160;&#160;(1&lt;&lt;1)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="class_string.html" title="A string of characters. ">String</a> list flag: values have long type. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac4e6c19149ad51432fbc57024136ec72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e6c19149ad51432fbc57024136ec72">&#9670;&nbsp;</a></span>Clp_ValParseFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int(* Clp_ValParseFunc) (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *vstr, int complain, void *user_data)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A value parsing function. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">vstr</td><td>the value to be parsed </td></tr>
    <tr><td class="paramname">complain</td><td>if nonzero, report error messages via Clp_OptionError </td></tr>
    <tr><td class="paramname">user_data</td><td>user data passed to <a class="el" href="clp_8h.html#aa96cff96af6c8463904a66c1027868d4" title="Define a new value type for clp. ">Clp_AddType()</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if parsing succeeded, 0 otherwise </dd></dl>

</div>
</div>
<a id="a4546844b1b958b92be2b085e3e3dc7b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4546844b1b958b92be2b085e3e3dc7b7">&#9670;&nbsp;</a></span>Clp_ErrorHandler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* Clp_ErrorHandler) (<a class="el" href="struct_clp___parser.html">Clp_Parser</a> *clp, const char *message)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A function for reporting option errors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">message</td><td>error message </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a270e4dd45e742993d34faf16ea1f0339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a270e4dd45e742993d34faf16ea1f0339">&#9670;&nbsp;</a></span>Clp_NewParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="struct_clp___parser.html">Clp_Parser</a>* Clp_NewParser </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_clp___option.html">Clp_Option</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a>. </p>
<p>never</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argc</td><td>number of arguments </td></tr>
    <tr><td class="paramname">argv</td><td>argument array </td></tr>
    <tr><td class="paramname">nopt</td><td>number of option definitions </td></tr>
    <tr><td class="paramname">opt</td><td>option definition array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the parser</dd></dl>
<p>The new <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> that will parse the arguments in <em>argv</em> according to the option definitions in <em>opt</em>.</p>
<p>The <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> is created with the following characteristics:</p>
<ul>
<li>
The "-" character introduces short options (<code>Clp_SetOptionChar(clp, '-', Clp_Short)</code>). </li>
<li>
Clp_ProgramName is set from the first argument in <em>argv</em>, if any. The first argument returned by <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> will be the second argument in <em>argv</em>. Note that this behavior differs from Clp_SetArguments. </li>
<li>
UTF-8 support is on iff the <code>LANG</code> environment variable contains one of the substrings "UTF-8", "UTF8", or "utf8". Override this with <a class="el" href="clp_8h.html#af6d94782d5752d5ae06f9528c0b3bb02" title="Set clp&#39;s UTF-8 mode. ">Clp_SetUTF8()</a>. </li>
<li>
The Clp_ValString, Clp_ValStringNotOption, Clp_ValInt, Clp_ValUnsigned, Clp_ValLong, Clp_ValUnsignedLong, Clp_ValBool, and Clp_ValDouble types are installed. </li>
<li>
Errors are reported to standard error. </li>
</ul>
<p>You may also create a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> with no arguments or options (<code>Clp_NewParser(0, 0, 0, 0)</code>) and set the arguments and options later.</p>
<p>Returns NULL if there isn't enough memory to construct the parser.</p>
<dl class="section note"><dt>Note</dt><dd>The CLP library will not modify the contents of <em>argv</em> or <em>opt</em>. The calling program must not modify <em>opt</em>. It may modify <em>argv</em> in limited cases. </dd></dl>

</div>
</div>
<a id="aea6da540eb93d3411089e5ff92e3d3f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6da540eb93d3411089e5ff92e3d3f3">&#9670;&nbsp;</a></span>Clp_DeleteParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clp_DeleteParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser</td></tr>
  </table>
  </dd>
</dl>
<p>All memory associated with <em>clp</em> is freed. </p>

</div>
</div>
<a id="afccf6dd0a5d839163029db3dddbdda00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccf6dd0a5d839163029db3dddbdda00">&#9670;&nbsp;</a></span>Clp_ProgramName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Clp_ProgramName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <em>clp's</em> program name. </p>

</div>
</div>
<a id="af006f0973eadd6ec5194cc6659e1f097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af006f0973eadd6ec5194cc6659e1f097">&#9670;&nbsp;</a></span>Clp_SetProgramName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Clp_SetProgramName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> program name. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">name</td><td>new program name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous program name</dd></dl>
<p>The calling program should not modify or free <em>name</em> until <em>clp</em> itself is destroyed. </p>

</div>
</div>
<a id="ae56e71af19d651c7780c767b7219328f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56e71af19d651c7780c767b7219328f">&#9670;&nbsp;</a></span>Clp_SetErrorHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="clp_8h.html#a4546844b1b958b92be2b085e3e3dc7b7">Clp_ErrorHandler</a> Clp_SetErrorHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clp_8h.html#a4546844b1b958b92be2b085e3e3dc7b7">Clp_ErrorHandler</a>&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> error handler function. </p>

</div>
</div>
<a id="af6d94782d5752d5ae06f9528c0b3bb02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d94782d5752d5ae06f9528c0b3bb02">&#9670;&nbsp;</a></span>Clp_SetUTF8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_SetUTF8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>utf8</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> UTF-8 mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">utf8</td><td>does the parser support UTF-8? </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous UTF-8 mode</dd></dl>
<p>In UTF-8 mode, all input strings (arguments and long names for options) are assumed to be encoded via UTF-8, and all character names (<a class="el" href="clp_8h.html#a794f6e4c42d4059ab58cb4b6fc1901a7" title="Set clp&#39;s treatment of character c. ">Clp_SetOptionChar()</a> and short names for options) may cover the whole Unicode range. Out of UTF-8 mode, all input strings are treated as binary, and all character names must be unsigned char values.</p>
<p>Furthermore, error messages in UTF-8 mode may contain Unicode quote characters. </p>

</div>
</div>
<a id="a10a2fbec13da38a1b7d62fa7c0e0af75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10a2fbec13da38a1b7d62fa7c0e0af75">&#9670;&nbsp;</a></span>Clp_OptionChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_OptionChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return <em>clp's</em> treatment of character <em>c</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">c</td><td>character </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>option character treatment</dd></dl>
<p>Returns an integer specifying how CLP treats arguments that begin with character <em>c</em>. See Clp_SetOptionChar for possibilities. </p>

</div>
</div>
<a id="a794f6e4c42d4059ab58cb4b6fc1901a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a794f6e4c42d4059ab58cb4b6fc1901a7">&#9670;&nbsp;</a></span>Clp_SetOptionChar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_SetOptionChar </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> treatment of character <em>c</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">c</td><td>character </td></tr>
    <tr><td class="paramname">type</td><td>option character treatment </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous option character treatment, or -1 on error</dd></dl>
<p><em>type</em> specifies how CLP treats arguments that begin with character <em>c</em>. Possibilities are:</p>
<dl>
<dt>Clp_NotOption (or 0) </dt>
<dd>The argument cannot be an option. </dd>
<dt>Clp_Long </dt>
<dd>The argument is a long option. </dd>
<dt>Clp_Short </dt>
<dd>The argument is a set of short options. </dd>
<dt>Clp_Short|Clp_Long </dt>
<dd>The argument is either a long option or, if no matching long option is found, a set of short options. </dd>
<dt>Clp_LongNegated </dt>
<dd>The argument is a negated long option. For example, after Clp_SetOptionChar(<em>clp</em>, '^', Clp_LongNegated), the argument "^foo" is equivalent to "--no-foo". </dd>
<dt>Clp_ShortNegated </dt>
<dd>The argument is a set of negated short options. </dd>
<dt>Clp_ShortNegated|Clp_LongNegated </dt>
<dd>The argument is either a negated long option or, if no matching long option is found, a set of negated short options. </dd>
<dt>Clp_LongImplicit </dt>
<dd>The argument may be a long option, where the character <em>c</em> is actually part of the long option name. For example, after Clp_SetOptionChar(<em>clp</em>, 'f', Clp_LongImplicit), the argument "foo" may be equivalent to "--foo". </dd>
</dl>
<p>In UTF-8 mode, <em>c</em> may be any Unicode character. Otherwise, <em>c</em> must be an unsigned char value. The special character 0 assigns <em>type</em> to <em>every</em> character.</p>
<p>It is an error if <em>c</em> is out of range, <em>type</em> is illegal, or there are too many character definitions stored in <em>clp</em> already. The function returns -1 on error.</p>
<p>A double hyphen "--" always introduces a long option. This behavior cannot currently be changed with <a class="el" href="clp_8h.html#a794f6e4c42d4059ab58cb4b6fc1901a7" title="Set clp&#39;s treatment of character c. ">Clp_SetOptionChar()</a>. </p>

</div>
</div>
<a id="a047236bad3cb1558a0e2939344ff9f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047236bad3cb1558a0e2939344ff9f12">&#9670;&nbsp;</a></span>Clp_SetOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_SetOptions </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nopt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_clp___option.html">Clp_Option</a> *&#160;</td>
          <td class="paramname"><em>opt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> option definitions. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">nopt</td><td>number of option definitions </td></tr>
    <tr><td class="paramname">opt</td><td>option definition array </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>Installs the option definitions in <em>opt</em>. Future option parsing will use <em>opt</em> to search for options.</p>
<p>Also checks <em>opt's</em> option definitions for validity. "CLP internal
errors" are reported via <a class="el" href="clp_8h.html#a7fdafd3a1bd98eb6dbd60d9a61baf480" title="Report a parser error. ">Clp_OptionError()</a> if:</p>
<ul>
<li>
An option has a negative ID. </li>
<li>
Two different short options have the same name. </li>
<li>
Two different long options have the same name. </li>
<li>
A short and a long option are ambiguous, in that some option character might introduce either a short or a long option (e.g., Clp_SetOptionChar(<em>clp</em>, '-', Clp_Long|Clp_Short)), and a short name equals a long name. </li>
</ul>
<p>If necessary memory cannot be allocated, this function returns -1 without modifying the parser.</p>
<dl class="section note"><dt>Note</dt><dd>The CLP library will not modify the contents of <em>argv</em> or <em>opt</em>. The calling program must not modify <em>opt</em> either until another call to <a class="el" href="clp_8h.html#a047236bad3cb1558a0e2939344ff9f12" title="Set clp&#39;s option definitions. ">Clp_SetOptions()</a> or the parser is destroyed. </dd></dl>

</div>
</div>
<a id="a10809101ba870d1f719799f86ce8b86b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10809101ba870d1f719799f86ce8b86b">&#9670;&nbsp;</a></span>Clp_SetArguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clp_SetArguments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set <em>clp's</em> arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">argc</td><td>number of arguments </td></tr>
    <tr><td class="paramname">argv</td><td>argument array</td></tr>
  </table>
  </dd>
</dl>
<p>Installs the arguments in <em>argv</em> for parsing. Future option parsing will analyze <em>argv</em>.</p>
<p>Unlike <a class="el" href="clp_8h.html#a270e4dd45e742993d34faf16ea1f0339" title="Create a new Clp_Parser. ">Clp_NewParser()</a>, this function does not treat <em>argv</em>[0] specially. The first subsequent call to <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> will analyze <em>argv</em>[0].</p>
<p>This function also sets option processing to on, as by Clp_SetOptionProcessing(<em>clp</em>, 1).</p>
<dl class="section note"><dt>Note</dt><dd>The CLP library will not modify the contents of <em>argv</em>. The calling program should not generally modify the element of <em>argv</em> that CLP is currently analyzing. </dd></dl>

</div>
</div>
<a id="a499871c3e356d606c35a85349bc228c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499871c3e356d606c35a85349bc228c3">&#9670;&nbsp;</a></span>Clp_SetOptionProcessing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_SetOptionProcessing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>on</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set whether <em>clp</em> is searching for options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">on</td><td>whether to search for options </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>previous option processing setting</dd></dl>
<p>When option processing is off, every call to <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> returns Clp_NotOption. By default the option <code>"--"</code> turns off option processing and is otherwise ignored. </p>

</div>
</div>
<a id="aa96cff96af6c8463904a66c1027868d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa96cff96af6c8463904a66c1027868d4">&#9670;&nbsp;</a></span>Clp_AddType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_AddType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="clp_8h.html#ac4e6c19149ad51432fbc57024136ec72">Clp_ValParseFunc</a>&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a new value type for <em>clp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">val_type</td><td>value type ID </td></tr>
    <tr><td class="paramname">flags</td><td>value type flags </td></tr>
    <tr><td class="paramname">parser</td><td>parser function </td></tr>
    <tr><td class="paramname">user_data</td><td>user data for <em>parser</em> function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>Defines argument type <em>val_type</em> in parser <em>clp</em>. The parsing function <em>parser</em> will be passed argument values for type <em>val_type</em>. It should parse the argument into values (usually in <em>clp-&gt;val</em>, but sometimes elsewhere), report errors if necessary, and return whether the parse was successful.</p>
<p>Any prior argument parser match <em>val_type</em> is removed. <em>val_type</em> must be greater than zero.</p>
<p><em>flags</em> specifies additional parsing flags. At the moment the only relevant flag is Clp_DisallowOptions, which means that separated values must not look like options. For example, assume argument <code>&ndash;a</code>/<code>-a</code> has mandatory value type Clp_ValStringNotOption (which has Clp_DisallowOptions). Then:</p>
<ul>
<li>
<code>&ndash;a=&ndash;b</code> will parse with value <code>&ndash;b</code>. </li>
<li>
<code>-a&ndash;b</code> will parse with value <code>&ndash;b</code>. </li>
<li>
<code>&ndash;a &ndash;b</code> will not parse, since the mandatory value looks like an option. </li>
<li>
<code>-a &ndash;b</code> will not parse, since the mandatory value looks like an option. </li>
</ul>

</div>
</div>
<a id="a83ecc57d06505e3f9154c8a85e5b2f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83ecc57d06505e3f9154c8a85e5b2f6d">&#9670;&nbsp;</a></span>Clp_AddStringListTypeVec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_AddStringListTypeVec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nstrs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *const *&#160;</td>
          <td class="paramname"><em>strs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>vals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a new string list value type for <em>clp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">val_type</td><td>value type ID </td></tr>
    <tr><td class="paramname">flags</td><td>string list flags </td></tr>
    <tr><td class="paramname">nstrs</td><td>number of strings in list </td></tr>
    <tr><td class="paramname">strs</td><td>array of strings </td></tr>
    <tr><td class="paramname">vals</td><td>array of values </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>Defines argument type <em>val_type</em> in parser <em>clp</em>. The parsing function sets <em>clp-&gt;val.i</em> to an integer. The value string is matched against the <em>strs</em>. If there's a unique match, the corresponding entry from <em>vals</em> is returned. Unique prefix matches also work. Finally, if <em>flags</em> contains the Clp_AllowNumbers flag, then integers are also accepted.</p>
<p>For example: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> strs[] = { <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;cattle&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span> };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> vals[]          = { 1,     2,        3     };</div><div class="line"><a class="code" href="clp_8h.html#a83ecc57d06505e3f9154c8a85e5b2f6d">Clp_AddStringListTypeVec</a>(clp, 100, <a class="code" href="clp_8h.html#a48fe7973f7c5dc730da07be3fddba5cb">Clp_AllowNumbers</a>, 3, strs, vals);</div></div><!-- fragment --><p>Say that option <code>&ndash;animal</code> takes value type 100. Then:</p>
<ul>
<li>
<code>&ndash;animal=cat</code> will succeed and set <em>clp-&gt;val.i</em> = 1. </li>
<li>
<code>&ndash;animal=cattle</code> will succeed and set <em>clp-&gt;val.i</em> = 2. </li>
<li>
<code>&ndash;animal=dog</code> will succeed and set <em>clp-&gt;val.i</em> = 3. </li>
<li>
<code>&ndash;animal=d</code> will succeed and set <em>clp-&gt;val.i</em> = 3. </li>
<li>
<code>&ndash;animal=c</code> will fail, since <code>c</code> is ambiguous. </li>
<li>
<code>&ndash;animal=4</code> will succeed and set <em>clp-&gt;val.i</em> = 4. </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>The CLP library will not modify the contents of <em>strs</em> or <em>vals</em>. The calling program can modify the <em>strs</em> array, but the actual strings (for instance, <em>strs</em>[0] and <em>strs</em>[1]) must not be modified or freed until the parser is destroyed. </dd></dl>

</div>
</div>
<a id="a413eb61d972d0bde99c74ccd04943d46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413eb61d972d0bde99c74ccd04943d46">&#9670;&nbsp;</a></span>Clp_AddStringListType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_AddStringListType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>val_type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a new string list value type for <em>clp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">val_type</td><td>value type ID </td></tr>
    <tr><td class="paramname">flags</td><td>string list flags </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure</dd></dl>
<p>Defines argument type <em>val_type</em> in parser <em>clp</em>. The parsing function sets <em>clp-&gt;val.i</em> to an integer. The value string is matched against strings provided in the ellipsis arguments. For example, the <a class="el" href="clp_8h.html#a413eb61d972d0bde99c74ccd04943d46" title="Define a new string list value type for clp. ">Clp_AddStringListType()</a> call below has the same effect as the <a class="el" href="clp_8h.html#a83ecc57d06505e3f9154c8a85e5b2f6d" title="Define a new string list value type for clp. ">Clp_AddStringListTypeVec()</a> call:</p>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="clp_8h.html#a413eb61d972d0bde99c74ccd04943d46">Clp_AddStringListType</a>(clp, 100, <a class="code" href="clp_8h.html#a48fe7973f7c5dc730da07be3fddba5cb">Clp_AllowNumbers</a>, <span class="stringliteral">&quot;cat&quot;</span>, 1,</div><div class="line">                      <span class="stringliteral">&quot;cattle&quot;</span>, 2, <span class="stringliteral">&quot;dog&quot;</span>, 3, (<span class="keyword">const</span> <span class="keywordtype">char</span> *) NULL);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> * <span class="keyword">const</span> strs[] = { <span class="stringliteral">&quot;cat&quot;</span>, <span class="stringliteral">&quot;cattle&quot;</span>, <span class="stringliteral">&quot;dog&quot;</span> };</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> vals[]          = { 1,     2,        3     };</div><div class="line"><a class="code" href="clp_8h.html#a83ecc57d06505e3f9154c8a85e5b2f6d">Clp_AddStringListTypeVec</a>(clp, 100, <a class="code" href="clp_8h.html#a48fe7973f7c5dc730da07be3fddba5cb">Clp_AllowNumbers</a>, 3, strs, vals);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The CLP library will not modify any of the passed-in strings. The calling program must not modify or free them either until the parser is destroyed. </dd></dl>

</div>
</div>
<a id="ac5b3c63a6091476e79f30a6fd17bcf29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5b3c63a6091476e79f30a6fd17bcf29">&#9670;&nbsp;</a></span>Clp_Next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_Next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and return the next argument from <em>clp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>option ID of next option</dd></dl>
<p>Parse the next argument from the argument list, store information about that argument in the fields of <em>clp</em>, and return the option's ID.</p>
<p>If an argument was successfully parsed, that option's ID is returned. Other possible return values are:</p>
<dl>
<dt>Clp_Done </dt>
<dd>There are no more arguments. </dd>
<dt>Clp_NotOption </dt>
<dd>The next argument was not an option. The argument's text is <em>clp-&gt;vstr</em> (and <em>clp-&gt;val.s</em>). </dd>
<dt>Clp_BadOption </dt>
<dd>The next argument was a bad option: either an option that wasn't understood, or an option lacking a required value, or an option whose value couldn't be parsed. The option has been skipped. </dd>
<dt>Clp_Error </dt>
<dd>There was an internal error. This should never occur unless a user messes with, for example, a <a class="el" href="struct_clp___option.html" title="Option description. ">Clp_Option</a> array. </dd>
</dl>
<p>The fields of <em>clp</em> are set as follows.</p>
<dl>
<dt><code>negated</code> </dt>
<dd>1 if the option was negated, 0 if it wasn't. </dd>
<dt><code>have_val</code> </dt>
<dd>1 if the option had a value, 0 if it didn't. Note that negated options are not allowed to have values. </dd>
<dt><code>vstr</code> </dt>
<dd>The value string, if any. NULL if there was no value. </dd>
<dt><code>val</code> </dt>
<dd>An option's value type will parse the value string into this union. </dd>
</dl>
<p>The parsed argument is shifted off the argument list, so that sequential calls to <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> step through the arugment list. </p>

</div>
</div>
<a id="ad5fc3ebb27b87f9ae6cdb42b099df041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5fc3ebb27b87f9ae6cdb42b099df041">&#9670;&nbsp;</a></span>Clp_Shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Clp_Shift </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>allow_options</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the next argument from <em>clp</em> without option parsing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">allow_options</td><td>whether options will be allowed</td></tr>
  </table>
  </dd>
</dl>
<p>Remove and return the next argument from <em>clp's</em> argument array. If there are no arguments left, or if the next argument is an option and <em>allow_options</em> != 0, then returns null. </p>

</div>
</div>
<a id="a2b2afa7cdc5f8ce171d8292c41f9844e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b2afa7cdc5f8ce171d8292c41f9844e">&#9670;&nbsp;</a></span>Clp_NewParserState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Clp_ParserState* Clp_NewParserState </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a new Clp_ParserState. </p>
<dl class="section return"><dt>Returns</dt><dd>the parser state</dd></dl>
<p>A Clp_ParserState object can store a parsing state of a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> object. This state specifies exactly how far the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> has gotten in parsing an argument list. The <a class="el" href="clp_8h.html#a9ef9732aa7f7cdb2f70ee45190602c00" title="Save clp&#39;s current state in state. ">Clp_SaveParser()</a> and <a class="el" href="clp_8h.html#a388966eff308f6c76d87138d1762f02c" title="Restore parser state from state into clp. ">Clp_RestoreParser()</a> functions can be used to save this state and then restore it later, allowing a <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> to switch among argument lists.</p>
<p>The initial state is empty, in that after Clp_RestoreParser(clp, state), Clp_Next(clp) would return Clp_Done.</p>
<p>Parser states can be saved and restored among different parser objects.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#ad98193f79510e5f8badc592b469e59d2" title="Destroy a Clp_ParserState object. ">Clp_DeleteParserState</a>, <a class="el" href="clp_8h.html#a9ef9732aa7f7cdb2f70ee45190602c00" title="Save clp&#39;s current state in state. ">Clp_SaveParser</a>, <a class="el" href="clp_8h.html#a388966eff308f6c76d87138d1762f02c" title="Restore parser state from state into clp. ">Clp_RestoreParser</a> </dd></dl>

</div>
</div>
<a id="ad98193f79510e5f8badc592b469e59d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98193f79510e5f8badc592b469e59d2">&#9670;&nbsp;</a></span>Clp_DeleteParserState()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clp_DeleteParserState </td>
          <td>(</td>
          <td class="paramtype">Clp_ParserState *&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a Clp_ParserState object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>parser state</td></tr>
  </table>
  </dd>
</dl>
<p>The memory associated with <em>state</em> is freed. </p>

</div>
</div>
<a id="a9ef9732aa7f7cdb2f70ee45190602c00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef9732aa7f7cdb2f70ee45190602c00">&#9670;&nbsp;</a></span>Clp_SaveParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clp_SaveParser </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Clp_ParserState *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save <em>clp's</em> current state in <em>state</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">state</td><td>parser state </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#a2b2afa7cdc5f8ce171d8292c41f9844e" title="Create a new Clp_ParserState. ">Clp_NewParserState</a>, <a class="el" href="clp_8h.html#a388966eff308f6c76d87138d1762f02c" title="Restore parser state from state into clp. ">Clp_RestoreParser</a> </dd></dl>

</div>
</div>
<a id="a388966eff308f6c76d87138d1762f02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388966eff308f6c76d87138d1762f02c">&#9670;&nbsp;</a></span>Clp_RestoreParser()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Clp_RestoreParser </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Clp_ParserState *&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Restore parser state from <em>state</em> into <em>clp</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">state</td><td>parser state</td></tr>
  </table>
  </dd>
</dl>
<p>The parser state in <em>state</em> is restored into <em>clp</em>. The next call to <a class="el" href="clp_8h.html#ac5b3c63a6091476e79f30a6fd17bcf29" title="Parse and return the next argument from clp. ">Clp_Next()</a> will return the same result as it would have at the time <em>state</em> was saved (probably by Clp_SaveParser(<em>clp</em>, <em>state</em>)).</p>
<p>A parser state contains information about arguments (argc and argv; see <a class="el" href="clp_8h.html#a10809101ba870d1f719799f86ce8b86b" title="Set clp&#39;s arguments. ">Clp_SetArguments()</a>) and option processing (<a class="el" href="clp_8h.html#a499871c3e356d606c35a85349bc228c3" title="Set whether clp is searching for options. ">Clp_SetOptionProcessing()</a>), but not about options (<a class="el" href="clp_8h.html#a047236bad3cb1558a0e2939344ff9f12" title="Set clp&#39;s option definitions. ">Clp_SetOptions()</a>). Changes to options and value types are preserved across <a class="el" href="clp_8h.html#a388966eff308f6c76d87138d1762f02c" title="Restore parser state from state into clp. ">Clp_RestoreParser()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#a2b2afa7cdc5f8ce171d8292c41f9844e" title="Create a new Clp_ParserState. ">Clp_NewParserState</a>, <a class="el" href="clp_8h.html#a9ef9732aa7f7cdb2f70ee45190602c00" title="Save clp&#39;s current state in state. ">Clp_SaveParser</a> </dd></dl>

</div>
</div>
<a id="a7fdafd3a1bd98eb6dbd60d9a61baf480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fdafd3a1bd98eb6dbd60d9a61baf480">&#9670;&nbsp;</a></span>Clp_OptionError()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_OptionError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Report a parser error. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">format</td><td>error format</td></tr>
  </table>
  </dd>
</dl>
<p>Format an error message from <em>format</em> and any additional arguments in the ellipsis. The resulting error string is then printed to standard error (or passed to the error handler specified by Clp_SetErrorHandler). Returns the number of characters printed.</p>
<p>The following format characters are accepted:</p>
<dl>
<dt><code>%</code><code>c</code> </dt>
<dd>A character (type <code>int</code>). Control characters are printed in caret notation. If the parser is in UTF-8 mode, the character is formatted in UTF-8. Otherwise, special characters are printed with backslashes and octal notation. </dd>
<dt><code>%</code><code>s</code> </dt>
<dd>A string (type <code>const char *</code>). </dd>
<dt><code>%</code><code>C</code> </dt>
<dd>The argument is a string (type <code>const char *</code>). The first character in this string is printed. If the parser is in UTF-8 mode, this may involve multiple bytes. </dd>
<dt><code>%</code><code>d</code> </dt>
<dd>An integer (type <code>int</code>). Printed in decimal. </dd>
<dt><code>%</code><code>O</code> </dt>
<dd>The current option. No values are read from the argument list; the current option is defined in the <a class="el" href="struct_clp___parser.html" title="Command line parser. ">Clp_Parser</a> object itself. </dd>
<dt><code>%</code><code>V</code> </dt>
<dd>Like <code>%</code><code>O</code>, but also includes the current value, if any. </dd>
<dt><code>%%</code> </dt>
<dd>Prints a percent character. </dd>
<dt><code>%</code><code>&lt;</code> </dt>
<dd>Prints an open quote string. In UTF-8 mode, prints a left single quote. Otherwise prints a single quote. </dd>
<dt><code>%</code><code>&gt;</code> </dt>
<dd>Prints a closing quote string. In UTF-8 mode, prints a right single quote. Otherwise prints a single quote. </dd>
<dt><code>%</code><code>,</code> </dt>
<dd>Prints an apostrophe. In UTF-8 mode, prints a right single quote. Otherwise prints a single quote. </dd>
</dl>
<p>Note that no flag characters, precision, or field width characters are currently supported.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#ae56e71af19d651c7780c767b7219328f" title="Set clp&#39;s error handler function. ">Clp_SetErrorHandler</a> </dd></dl>

</div>
</div>
<a id="ada4beed00f3ce4112161bacd2968928f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4beed00f3ce4112161bacd2968928f">&#9670;&nbsp;</a></span>Clp_vsnprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_vsnprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Format a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">str</td><td>output string </td></tr>
    <tr><td class="paramname">size</td><td>size of output string </td></tr>
    <tr><td class="paramname">format</td><td>error format</td></tr>
  </table>
  </dd>
</dl>
<p>Format an error message from <em>format</em> and any additional arguments in the ellipsis, according to the Clp_OptionError formatting conventions. The resulting string is written to <em>str</em>. At most <em>size</em> characters are written to <em>str</em>, including a terminating null byte. The return value is the number of characters that would have been written (excluding the terminating null byte) if <em>size</em> were large enough to contain the entire string.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#a7fdafd3a1bd98eb6dbd60d9a61baf480" title="Report a parser error. ">Clp_OptionError</a> </dd></dl>

</div>
</div>
<a id="aca7993eb9617bb3a8f1bad9ba1aa2cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7993eb9617bb3a8f1bad9ba1aa2cb8">&#9670;&nbsp;</a></span>Clp_fprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_fprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">f</td><td>output file </td></tr>
    <tr><td class="paramname">format</td><td>error format</td></tr>
  </table>
  </dd>
</dl>
<p>Format an error message using <em>format</em> and additional arguments in the ellipsis, according to the Clp_OptionError formatting conventions. The resulting message is written to <em>f</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#a7fdafd3a1bd98eb6dbd60d9a61baf480" title="Report a parser error. ">Clp_OptionError</a> </dd></dl>

</div>
</div>
<a id="a18ade25435d31c9ffd713d695fb50f80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18ade25435d31c9ffd713d695fb50f80">&#9670;&nbsp;</a></span>Clp_vfprintf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_vfprintf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">va_list&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a message. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">f</td><td>output file </td></tr>
    <tr><td class="paramname">format</td><td>error format </td></tr>
    <tr><td class="paramname">val</td><td>arguments</td></tr>
  </table>
  </dd>
</dl>
<p>Format an error message using <em>format</em> and <em>val</em>, according to the Clp_OptionError formatting conventions. The resulting message is written to <em>f</em>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#a7fdafd3a1bd98eb6dbd60d9a61baf480" title="Report a parser error. ">Clp_OptionError</a> </dd></dl>

</div>
</div>
<a id="a9c487d36991a3ade60b4650fb117c394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c487d36991a3ade60b4650fb117c394">&#9670;&nbsp;</a></span>Clp_CurOptionNameBuf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_CurOptionNameBuf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the current option as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
    <tr><td class="paramname">buf</td><td>output buffer </td></tr>
    <tr><td class="paramname">len</td><td>length of output buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of characters written to the buffer, not including the terminating NUL</dd></dl>
<p>A string that looks like the last option parsed by <em>clp</em> is extracted into <em>buf</em>. The correct option characters are put into the string first, followed by the option text. The output buffer is null-terminated unless <em>len</em> == 0.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#aa8eea106a829b4f7a07e3592d459875c" title="Extract the current option as a string. ">Clp_CurOptionName</a> </dd></dl>

</div>
</div>
<a id="aa8eea106a829b4f7a07e3592d459875c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8eea106a829b4f7a07e3592d459875c">&#9670;&nbsp;</a></span>Clp_CurOptionName()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* Clp_CurOptionName </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the current option as a string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">clp</td><td>the parser </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>string describing the current option</dd></dl>
<p>This function acts like <a class="el" href="clp_8h.html#a9c487d36991a3ade60b4650fb117c394" title="Extract the current option as a string. ">Clp_CurOptionNameBuf()</a>, but returns a pointer into a static buffer that will be rewritten on the next call to <a class="el" href="clp_8h.html#aa8eea106a829b4f7a07e3592d459875c" title="Extract the current option as a string. ">Clp_CurOptionName()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>This function is not thread safe.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="clp_8h.html#aa8eea106a829b4f7a07e3592d459875c" title="Extract the current option as a string. ">Clp_CurOptionName</a> </dd></dl>

</div>
</div>
<a id="ae5bf5a1363019da8d5cd6be6cdcd4416"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5bf5a1363019da8d5cd6be6cdcd4416">&#9670;&nbsp;</a></span>Clp_IsLong()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_IsLong </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>long_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the current option had long name <em>name</em>. </p>

</div>
</div>
<a id="aa23693e1785a3917817778540ab94566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa23693e1785a3917817778540ab94566">&#9670;&nbsp;</a></span>Clp_IsShort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Clp_IsShort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_clp___parser.html">Clp_Parser</a> *&#160;</td>
          <td class="paramname"><em>clp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>short_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if the current option had short name <em>name</em>. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 13 2017 20:11:39 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
