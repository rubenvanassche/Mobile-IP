<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Click: include/click/confparse.hh File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_38845554362b7075350137b91e3d2235.html">click</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">confparse.hh File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Support for parsing configuration strings.  
<a href="#details">More...</a></p>

<p><a href="confparse_8hh_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Argument Manipulation</div></td></tr>
<tr class="memitem:aee90c69236e8a1e19d14aec3d4bfa652"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aee90c69236e8a1e19d14aec3d4bfa652">cp_skip_space</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:aee90c69236e8a1e19d14aec3d4bfa652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first nonspace character in the string [<em>begin</em>, <em>end</em>).  <a href="#aee90c69236e8a1e19d14aec3d4bfa652">More...</a><br /></td></tr>
<tr class="separator:aee90c69236e8a1e19d14aec3d4bfa652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb4518b86b1aa517d9d753b185aae6c7"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afb4518b86b1aa517d9d753b185aae6c7">cp_skip_comment_space</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:afb4518b86b1aa517d9d753b185aae6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the first nonspace, noncomment character in the string [<em>begin</em>, <em>end</em>).  <a href="#afb4518b86b1aa517d9d753b185aae6c7">More...</a><br /></td></tr>
<tr class="separator:afb4518b86b1aa517d9d753b185aae6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ab3eec45f2d5a76091ffc17101f488"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a07ab3eec45f2d5a76091ffc17101f488">cp_skip_double_quote</a> (const char *begin, const char *end)</td></tr>
<tr class="memdesc:a07ab3eec45f2d5a76091ffc17101f488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the first character after a double-quoted string starting at <em>begin</em>.  <a href="#a07ab3eec45f2d5a76091ffc17101f488">More...</a><br /></td></tr>
<tr class="separator:a07ab3eec45f2d5a76091ffc17101f488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7ce0e06da5e9e65ac43a4010b82b108"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ab7ce0e06da5e9e65ac43a4010b82b108">cp_eat_space</a> (<a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:ab7ce0e06da5e9e65ac43a4010b82b108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove spaces from the beginning of <em>str</em>.  <a href="#ab7ce0e06da5e9e65ac43a4010b82b108">More...</a><br /></td></tr>
<tr class="separator:ab7ce0e06da5e9e65ac43a4010b82b108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0e5ca68e156d338965fba214d414b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a13c0e5ca68e156d338965fba214d414b">cp_is_space</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a13c0e5ca68e156d338965fba214d414b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <em>str</em> is all spaces.  <a href="#a13c0e5ca68e156d338965fba214d414b">More...</a><br /></td></tr>
<tr class="separator:a13c0e5ca68e156d338965fba214d414b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca030c34ab8521cd4aaf8d80b200f1ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aca030c34ab8521cd4aaf8d80b200f1ad">cp_is_word</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:aca030c34ab8521cd4aaf8d80b200f1ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test whether <em>str</em> is a valid "word".  <a href="#aca030c34ab8521cd4aaf8d80b200f1ad">More...</a><br /></td></tr>
<tr class="separator:aca030c34ab8521cd4aaf8d80b200f1ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa09070636c380d2bb398941963f2ca67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa09070636c380d2bb398941963f2ca67">cp_is_click_id</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:aa09070636c380d2bb398941963f2ca67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test if <em>str</em> is a valid Click identifier.  <a href="#aa09070636c380d2bb398941963f2ca67">More...</a><br /></td></tr>
<tr class="separator:aa09070636c380d2bb398941963f2ca67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa01b2aaaf628883af929264473ee8864"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864">cp_uncomment</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:aa01b2aaaf628883af929264473ee8864"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplify <em>str's</em> whitespace and replace comments by spaces, returning the result.  <a href="#aa01b2aaaf628883af929264473ee8864">More...</a><br /></td></tr>
<tr class="separator:aa01b2aaaf628883af929264473ee8864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a096d2b80a263f7e6b15e0b8c45361"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361">cp_unquote</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a69a096d2b80a263f7e6b15e0b8c45361"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove one level of quoting from <em>str</em>, returning the result.  <a href="#a69a096d2b80a263f7e6b15e0b8c45361">More...</a><br /></td></tr>
<tr class="separator:a69a096d2b80a263f7e6b15e0b8c45361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa496b97b69db307c6d5560d86373f03d"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa496b97b69db307c6d5560d86373f03d">cp_process_backslash</a> (const char *begin, const char *end, <a class="el" href="class_string_accum.html">StringAccum</a> &amp;sa)</td></tr>
<tr class="memdesc:aa496b97b69db307c6d5560d86373f03d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process a backslash escape, appending results to <em>sa</em>.  <a href="#aa496b97b69db307c6d5560d86373f03d">More...</a><br /></td></tr>
<tr class="separator:aa496b97b69db307c6d5560d86373f03d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe4c743d2be681a21e0426edf81661a9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#abe4c743d2be681a21e0426edf81661a9">cp_quote</a> (const <a class="el" href="class_string.html">String</a> &amp;str, bool allow_newlines=false)</td></tr>
<tr class="memdesc:abe4c743d2be681a21e0426edf81661a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a quoted version of <em>str</em>.  <a href="#abe4c743d2be681a21e0426edf81661a9">More...</a><br /></td></tr>
<tr class="separator:abe4c743d2be681a21e0426edf81661a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a644f412600eb0781773488c6a0046"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046">cp_argvec</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf)</td></tr>
<tr class="memdesc:ad6a644f412600eb0781773488c6a0046"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a configuration string into arguments at commas.  <a href="#ad6a644f412600eb0781773488c6a0046">More...</a><br /></td></tr>
<tr class="separator:ad6a644f412600eb0781773488c6a0046"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a135a1aa1eae03fe38907ec1077394820"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a135a1aa1eae03fe38907ec1077394820">cp_unargvec</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf)</td></tr>
<tr class="memdesc:a135a1aa1eae03fe38907ec1077394820"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the strings of <em>conf</em> with commas and return the result.  <a href="#a135a1aa1eae03fe38907ec1077394820">More...</a><br /></td></tr>
<tr class="separator:a135a1aa1eae03fe38907ec1077394820"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08caa501d360ef6151c272253f34fe00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a08caa501d360ef6151c272253f34fe00">cp_spacevec</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf)</td></tr>
<tr class="memdesc:a08caa501d360ef6151c272253f34fe00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Separate a configuration string into arguments at unquoted spaces.  <a href="#a08caa501d360ef6151c272253f34fe00">More...</a><br /></td></tr>
<tr class="separator:a08caa501d360ef6151c272253f34fe00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8a047fba4bad1a0529fc51fd783133f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa8a047fba4bad1a0529fc51fd783133f">cp_shift_spacevec</a> (<a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:aa8a047fba4bad1a0529fc51fd783133f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove and return the first space-separated argument from <em>str</em>.  <a href="#aa8a047fba4bad1a0529fc51fd783133f">More...</a><br /></td></tr>
<tr class="separator:aa8a047fba4bad1a0529fc51fd783133f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1748d17a6d30e071abca4e569078f17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa1748d17a6d30e071abca4e569078f17">cp_unspacevec</a> (const <a class="el" href="class_string.html">String</a> *begin, const <a class="el" href="class_string.html">String</a> *end)</td></tr>
<tr class="memdesc:aa1748d17a6d30e071abca4e569078f17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the strings in [<em>begin</em>, <em>end</em>) with spaces and return the result.  <a href="#aa1748d17a6d30e071abca4e569078f17">More...</a><br /></td></tr>
<tr class="separator:aa1748d17a6d30e071abca4e569078f17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af130191df66c930be6d39c261183e031"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#af130191df66c930be6d39c261183e031">cp_unspacevec</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf)</td></tr>
<tr class="memdesc:af130191df66c930be6d39c261183e031"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join the strings in <em>conf</em> with spaces and return the result.  <a href="#af130191df66c930be6d39c261183e031">More...</a><br /></td></tr>
<tr class="separator:af130191df66c930be6d39c261183e031"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Unparsing</div></td></tr>
<tr class="memitem:af735aed54261a99477987946bd54b55f"><td class="memItemLeft" align="right" valign="top"><a id="af735aed54261a99477987946bd54b55f"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_bool</b> (bool value)</td></tr>
<tr class="separator:af735aed54261a99477987946bd54b55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dec02cfc79c1f9679ca0d9fda1f97cb"><td class="memItemLeft" align="right" valign="top"><a id="a1dec02cfc79c1f9679ca0d9fda1f97cb"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real2</b> (int32_t value, int frac_bits)</td></tr>
<tr class="separator:a1dec02cfc79c1f9679ca0d9fda1f97cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b9a8f08b25257bed6ad291ff0bd3874"><td class="memItemLeft" align="right" valign="top"><a id="a5b9a8f08b25257bed6ad291ff0bd3874"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real2</b> (uint32_t value, int frac_bits)</td></tr>
<tr class="separator:a5b9a8f08b25257bed6ad291ff0bd3874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca6d4e973397571ed8fe7263d9ed8c5"><td class="memItemLeft" align="right" valign="top"><a id="afca6d4e973397571ed8fe7263d9ed8c5"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real2</b> (int64_t value, int frac_bits)</td></tr>
<tr class="separator:afca6d4e973397571ed8fe7263d9ed8c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d7f7983af4fe40695e7f1961fbfe17"><td class="memItemLeft" align="right" valign="top"><a id="a19d7f7983af4fe40695e7f1961fbfe17"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real2</b> (uint64_t value, int frac_bits)</td></tr>
<tr class="separator:a19d7f7983af4fe40695e7f1961fbfe17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6f5644cde18dd25fcc7eeb68353d68"><td class="memItemLeft" align="right" valign="top"><a id="add6f5644cde18dd25fcc7eeb68353d68"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real10</b> (int32_t value, int frac_digits)</td></tr>
<tr class="separator:add6f5644cde18dd25fcc7eeb68353d68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca62eabefc877343fff8bb4aa0d32da0"><td class="memItemLeft" align="right" valign="top"><a id="aca62eabefc877343fff8bb4aa0d32da0"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_real10</b> (uint32_t value, int frac_digits)</td></tr>
<tr class="separator:aca62eabefc877343fff8bb4aa0d32da0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022374f518ca356ac6df2f0edaebe524"><td class="memItemLeft" align="right" valign="top"><a id="a022374f518ca356ac6df2f0edaebe524"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_milliseconds</b> (uint32_t value)</td></tr>
<tr class="separator:a022374f518ca356ac6df2f0edaebe524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7104ae58388a77279ac866099da5ebaf"><td class="memItemLeft" align="right" valign="top"><a id="a7104ae58388a77279ac866099da5ebaf"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_microseconds</b> (uint32_t value)</td></tr>
<tr class="separator:a7104ae58388a77279ac866099da5ebaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d1888f14b7067674bc0776683fe2f5"><td class="memItemLeft" align="right" valign="top"><a id="aa3d1888f14b7067674bc0776683fe2f5"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_interval</b> (const <a class="el" href="class_timestamp.html">Timestamp</a> &amp;value)</td></tr>
<tr class="separator:aa3d1888f14b7067674bc0776683fe2f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3dc6fb32569500b5eeb98560e619006"><td class="memItemLeft" align="right" valign="top"><a id="ab3dc6fb32569500b5eeb98560e619006"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_interval</b> (const struct timeval &amp;value)</td></tr>
<tr class="separator:ab3dc6fb32569500b5eeb98560e619006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a296071740e0dee53b46ca26aa55541df"><td class="memItemLeft" align="right" valign="top"><a id="a296071740e0dee53b46ca26aa55541df"></a>
<a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unparse_bandwidth</b> (uint32_t value)</td></tr>
<tr class="separator:a296071740e0dee53b46ca26aa55541df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Legacy Functions</div></td></tr>
<tr class="memitem:aea6b37319089e863e60a30543e320644"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...)</td></tr>
<tr class="memdesc:aea6b37319089e863e60a30543e320644"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy function for parsing a list of arguments.  <a href="#aea6b37319089e863e60a30543e320644">More...</a><br /></td></tr>
<tr class="separator:aea6b37319089e863e60a30543e320644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe286c128e1450846423736a7e045818"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#abe286c128e1450846423736a7e045818">cp_va_parse</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...)</td></tr>
<tr class="memdesc:abe286c128e1450846423736a7e045818"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy function for parsing a comma-separated argument string.  <a href="#abe286c128e1450846423736a7e045818">More...</a><br /></td></tr>
<tr class="separator:abe286c128e1450846423736a7e045818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e118defdfe7dea181dec407857f6373"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a5e118defdfe7dea181dec407857f6373">cp_va_space_parse</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...)</td></tr>
<tr class="memdesc:a5e118defdfe7dea181dec407857f6373"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy function for parsing a space-separated argument string.  <a href="#a5e118defdfe7dea181dec407857f6373">More...</a><br /></td></tr>
<tr class="separator:a5e118defdfe7dea181dec407857f6373"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec000231945185c38d89b74b86525e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aec000231945185c38d89b74b86525e6d">cp_va_parse_keyword</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...)</td></tr>
<tr class="memdesc:aec000231945185c38d89b74b86525e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy function for parsing a single argument.  <a href="#aec000231945185c38d89b74b86525e6d">More...</a><br /></td></tr>
<tr class="separator:aec000231945185c38d89b74b86525e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53fca3a1428cc2a346305829764b1a75"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a53fca3a1428cc2a346305829764b1a75">cp_va_parse_remove_keywords</a> (<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, int first, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...)</td></tr>
<tr class="memdesc:a53fca3a1428cc2a346305829764b1a75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Legacy function for parsing and removing matching arguments from <em>conf</em>.  <a href="#a53fca3a1428cc2a346305829764b1a75">More...</a><br /></td></tr>
<tr class="separator:a53fca3a1428cc2a346305829764b1a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Direct Parsing Functions</h2></td></tr>
<tr class="memitem:a821636b19e69b03945cf0472bc587b26"><td class="memItemLeft" align="right" valign="top"><a id="a821636b19e69b03945cf0472bc587b26"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>CP_REAL2_MAX_FRAC_BITS</b>&#160;&#160;&#160;28</td></tr>
<tr class="separator:a821636b19e69b03945cf0472bc587b26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a39ac156bdf36a7cc4ccc3b1e9fd435"><td class="memItemLeft" align="right" valign="top"><a id="a0a39ac156bdf36a7cc4ccc3b1e9fd435"></a>enum &#160;</td><td class="memItemRight" valign="bottom"><b>CpErrors</b> { <br />
&#160;&#160;<b>CPE_OK</b> = 0, 
<b>CPE_FORMAT</b>, 
<b>CPE_NEGATIVE</b>, 
<b>CPE_OVERFLOW</b>, 
<br />
&#160;&#160;<b>CPE_INVALID</b>, 
<b>CPE_MEMORY</b>, 
<b>CPE_NOUNITS</b>
<br />
 }</td></tr>
<tr class="separator:a0a39ac156bdf36a7cc4ccc3b1e9fd435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed82baf7f470b522273a3e37c24c600"><td class="memItemLeft" align="right" valign="top"><a id="abed82baf7f470b522273a3e37c24c600"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>cp_basic_integer_whole</b> = 64
 }</td></tr>
<tr class="separator:abed82baf7f470b522273a3e37c24c600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6170ef955898e3141104fd96bd185b91"><td class="memItemLeft" align="right" valign="top"><a id="a6170ef955898e3141104fd96bd185b91"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cp_errno</b></td></tr>
<tr class="separator:a6170ef955898e3141104fd96bd185b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3853041c3eff44f9432a41163a73c2bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd">cp_string</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_string.html">String</a> *result, <a class="el" href="class_string.html">String</a> *rest=0)</td></tr>
<tr class="memdesc:a3853041c3eff44f9432a41163a73c2bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a string from <em>str</em>.  <a href="#a3853041c3eff44f9432a41163a73c2bd">More...</a><br /></td></tr>
<tr class="separator:a3853041c3eff44f9432a41163a73c2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae21647d30503b2b4e2bb04fd8842922"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aae21647d30503b2b4e2bb04fd8842922">cp_word</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_string.html">String</a> *result, <a class="el" href="class_string.html">String</a> *rest=0)</td></tr>
<tr class="memdesc:aae21647d30503b2b4e2bb04fd8842922"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a word from <em>str</em>.  <a href="#aae21647d30503b2b4e2bb04fd8842922">More...</a><br /></td></tr>
<tr class="separator:aae21647d30503b2b4e2bb04fd8842922"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17450dcd527f644e36009aefb1e1bd36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a17450dcd527f644e36009aefb1e1bd36">cp_keyword</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_string.html">String</a> *result, <a class="el" href="class_string.html">String</a> *rest=0)</td></tr>
<tr class="memdesc:a17450dcd527f644e36009aefb1e1bd36"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a keyword from <em>str</em>.  <a href="#a17450dcd527f644e36009aefb1e1bd36">More...</a><br /></td></tr>
<tr class="separator:a17450dcd527f644e36009aefb1e1bd36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e741359e6048d9847df83ba3b790c71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a7e741359e6048d9847df83ba3b790c71">cp_bool</a> (const <a class="el" href="class_string.html">String</a> &amp;str, bool *result)</td></tr>
<tr class="memdesc:a7e741359e6048d9847df83ba3b790c71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a boolean from <em>str</em>.  <a href="#a7e741359e6048d9847df83ba3b790c71">More...</a><br /></td></tr>
<tr class="separator:a7e741359e6048d9847df83ba3b790c71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05f5b35ebc21facb87b054c28f905a38"><td class="memItemLeft" align="right" valign="top"><a id="a05f5b35ebc21facb87b054c28f905a38"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_basic_integer</b> (const char *begin, const char *end, int flags, int size, void *result)</td></tr>
<tr class="separator:a05f5b35ebc21facb87b054c28f905a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73da3daad75dc0be8f51f2b8c9bd1e7c"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c">cp_integer</a> (const char *begin, const char *end, int base, int *result)</td></tr>
<tr class="memdesc:a73da3daad75dc0be8f51f2b8c9bd1e7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an integer from [<em>begin</em>, <em>end</em>) in base <em>base</em>.  <a href="#a73da3daad75dc0be8f51f2b8c9bd1e7c">More...</a><br /></td></tr>
<tr class="separator:a73da3daad75dc0be8f51f2b8c9bd1e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d8fcdd933212d208db97d620b59115"><td class="memItemLeft" align="right" valign="top"><a id="a21d8fcdd933212d208db97d620b59115"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const char *begin, const char *end, int base, unsigned *result)</td></tr>
<tr class="separator:a21d8fcdd933212d208db97d620b59115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3ae5d3db9eaf0f2b682e91caad162f"><td class="memItemLeft" align="right" valign="top"><a id="a9d3ae5d3db9eaf0f2b682e91caad162f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const char *begin, const char *end, int base, long *result)</td></tr>
<tr class="separator:a9d3ae5d3db9eaf0f2b682e91caad162f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ad42d0bf3b492c0e23ad7fa47c814f"><td class="memItemLeft" align="right" valign="top"><a id="aa2ad42d0bf3b492c0e23ad7fa47c814f"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const char *begin, const char *end, int base, unsigned long *result)</td></tr>
<tr class="separator:aa2ad42d0bf3b492c0e23ad7fa47c814f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2ec7da5d8660ed2394de1285f04417"><td class="memItemLeft" align="right" valign="top"><a id="a2a2ec7da5d8660ed2394de1285f04417"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const char *begin, const char *end, int base, int64_t *result)</td></tr>
<tr class="separator:a2a2ec7da5d8660ed2394de1285f04417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7d630fb5db60ea8a5c0f13d87c10e1"><td class="memItemLeft" align="right" valign="top"><a id="afb7d630fb5db60ea8a5c0f13d87c10e1"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const char *begin, const char *end, int base, uint64_t *result)</td></tr>
<tr class="separator:afb7d630fb5db60ea8a5c0f13d87c10e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a360e1ee2c3eec2362116c3f03d3009"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a0a360e1ee2c3eec2362116c3f03d3009">cp_integer</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, int *result)</td></tr>
<tr class="memdesc:a0a360e1ee2c3eec2362116c3f03d3009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an integer from <em>str</em> in base <em>base</em>.  <a href="#a0a360e1ee2c3eec2362116c3f03d3009">More...</a><br /></td></tr>
<tr class="separator:a0a360e1ee2c3eec2362116c3f03d3009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2bb0616e4b861a73b978c1ec293869"><td class="memItemLeft" align="right" valign="top"><a id="aaa2bb0616e4b861a73b978c1ec293869"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, unsigned int *result)</td></tr>
<tr class="separator:aaa2bb0616e4b861a73b978c1ec293869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa884a4dc26309e4354e9969a3ac19008"><td class="memItemLeft" align="right" valign="top"><a id="aa884a4dc26309e4354e9969a3ac19008"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, long *result)</td></tr>
<tr class="separator:aa884a4dc26309e4354e9969a3ac19008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afefe773ca9c6b2a36fe0bd546050658e"><td class="memItemLeft" align="right" valign="top"><a id="afefe773ca9c6b2a36fe0bd546050658e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, unsigned long *result)</td></tr>
<tr class="separator:afefe773ca9c6b2a36fe0bd546050658e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a225419cc23ee3becab12526dba3d084e"><td class="memItemLeft" align="right" valign="top"><a id="a225419cc23ee3becab12526dba3d084e"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, int64_t *result)</td></tr>
<tr class="separator:a225419cc23ee3becab12526dba3d084e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db25cfd18d0af0bbe6f13a975c65ffd"><td class="memItemLeft" align="right" valign="top"><a id="a8db25cfd18d0af0bbe6f13a975c65ffd"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int base, uint64_t *result)</td></tr>
<tr class="separator:a8db25cfd18d0af0bbe6f13a975c65ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3843f1f73bb1a50bb1cddc9ce9e0aca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ac3843f1f73bb1a50bb1cddc9ce9e0aca">cp_integer</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int *result)</td></tr>
<tr class="memdesc:ac3843f1f73bb1a50bb1cddc9ce9e0aca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an integer from <em>str</em> in base 0.  <a href="#ac3843f1f73bb1a50bb1cddc9ce9e0aca">More...</a><br /></td></tr>
<tr class="separator:ac3843f1f73bb1a50bb1cddc9ce9e0aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5311d48975adfeb540561a979a92225"><td class="memItemLeft" align="right" valign="top"><a id="ac5311d48975adfeb540561a979a92225"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned int *result)</td></tr>
<tr class="separator:ac5311d48975adfeb540561a979a92225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0d434eb806363b791dd13fdfc5fc16"><td class="memItemLeft" align="right" valign="top"><a id="a5f0d434eb806363b791dd13fdfc5fc16"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, long *result)</td></tr>
<tr class="separator:a5f0d434eb806363b791dd13fdfc5fc16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b3b8a4ccab1561896ab34042af16142"><td class="memItemLeft" align="right" valign="top"><a id="a7b3b8a4ccab1561896ab34042af16142"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned long *result)</td></tr>
<tr class="separator:a7b3b8a4ccab1561896ab34042af16142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16d99ef6756fc6e1ddaf0870592ef911"><td class="memItemLeft" align="right" valign="top"><a id="a16d99ef6756fc6e1ddaf0870592ef911"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int64_t *result)</td></tr>
<tr class="separator:a16d99ef6756fc6e1ddaf0870592ef911"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad986f0607c3209e17aac5db20c9eeb5a"><td class="memItemLeft" align="right" valign="top"><a id="ad986f0607c3209e17aac5db20c9eeb5a"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_integer</b> (const <a class="el" href="class_string.html">String</a> &amp;str, uint64_t *result)</td></tr>
<tr class="separator:ad986f0607c3209e17aac5db20c9eeb5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62fe9aa2b03be0c2c99070cb64240d84"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84">cp_real2</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_bits, int32_t *result)</td></tr>
<tr class="memdesc:a62fe9aa2b03be0c2c99070cb64240d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a fixed-point number from <em>str</em>.  <a href="#a62fe9aa2b03be0c2c99070cb64240d84">More...</a><br /></td></tr>
<tr class="separator:a62fe9aa2b03be0c2c99070cb64240d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e20c4c88f768f778486649153ef3ed"><td class="memItemLeft" align="right" valign="top"><a id="ad9e20c4c88f768f778486649153ef3ed"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_real2</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_bits, uint32_t *result)</td></tr>
<tr class="separator:ad9e20c4c88f768f778486649153ef3ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387daecd4382457c3d2b8be88e60d02e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e">cp_real10</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_digits, int32_t *result)</td></tr>
<tr class="memdesc:a387daecd4382457c3d2b8be88e60d02e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a real number from <em>str</em>, representing the result as an integer with <em>frac_digits</em> decimal digits of fraction.  <a href="#a387daecd4382457c3d2b8be88e60d02e">More...</a><br /></td></tr>
<tr class="separator:a387daecd4382457c3d2b8be88e60d02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11d24e2ed515dd2d81e4ab438324f6f"><td class="memItemLeft" align="right" valign="top"><a id="ae11d24e2ed515dd2d81e4ab438324f6f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_real10</b> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_digits, uint32_t *result)</td></tr>
<tr class="separator:ae11d24e2ed515dd2d81e4ab438324f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47d562ad0cb6795313235ff84bad440d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a47d562ad0cb6795313235ff84bad440d">cp_real10</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_digits, uint32_t *result_int, uint32_t *result_frac)</td></tr>
<tr class="memdesc:a47d562ad0cb6795313235ff84bad440d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a real number from <em>str</em>, representing the result as an integer with <em>frac_digits</em> decimal digits of fraction.  <a href="#a47d562ad0cb6795313235ff84bad440d">More...</a><br /></td></tr>
<tr class="separator:a47d562ad0cb6795313235ff84bad440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e3d6bb41be9959f40a37f217d9bc2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a03e3d6bb41be9959f40a37f217d9bc2a">cp_double</a> (const <a class="el" href="class_string.html">String</a> &amp;str, double *result)</td></tr>
<tr class="memdesc:a03e3d6bb41be9959f40a37f217d9bc2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a real number from <em>str</em>.  <a href="#a03e3d6bb41be9959f40a37f217d9bc2a">More...</a><br /></td></tr>
<tr class="separator:a03e3d6bb41be9959f40a37f217d9bc2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f4dd1ae1146aad253b6ecf69000f6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a45f4dd1ae1146aad253b6ecf69000f6c">cp_seconds_as</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int frac_digits, uint32_t *result)</td></tr>
<tr class="memdesc:a45f4dd1ae1146aad253b6ecf69000f6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an amount of time from <em>str</em>.  <a href="#a45f4dd1ae1146aad253b6ecf69000f6c">More...</a><br /></td></tr>
<tr class="separator:a45f4dd1ae1146aad253b6ecf69000f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa241b9899bd1118769cbff9ce75c18f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afa241b9899bd1118769cbff9ce75c18f">cp_seconds_as_milli</a> (const <a class="el" href="class_string.html">String</a> &amp;str, uint32_t *result)</td></tr>
<tr class="memdesc:afa241b9899bd1118769cbff9ce75c18f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an amount of time in milliseconds from <em>str</em>.  <a href="#afa241b9899bd1118769cbff9ce75c18f">More...</a><br /></td></tr>
<tr class="separator:afa241b9899bd1118769cbff9ce75c18f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1502cc5e990c25518f8c16536493136f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a1502cc5e990c25518f8c16536493136f">cp_seconds_as_micro</a> (const <a class="el" href="class_string.html">String</a> &amp;str, uint32_t *result)</td></tr>
<tr class="memdesc:a1502cc5e990c25518f8c16536493136f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an amount of time in microseconds from <em>str</em>.  <a href="#a1502cc5e990c25518f8c16536493136f">More...</a><br /></td></tr>
<tr class="separator:a1502cc5e990c25518f8c16536493136f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfcd439b6d13c97798bbc0c95668a37e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#acfcd439b6d13c97798bbc0c95668a37e">cp_seconds</a> (const <a class="el" href="class_string.html">String</a> &amp;str, double *result)</td></tr>
<tr class="memdesc:acfcd439b6d13c97798bbc0c95668a37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an amount of time from <em>str</em>.  <a href="#acfcd439b6d13c97798bbc0c95668a37e">More...</a><br /></td></tr>
<tr class="separator:acfcd439b6d13c97798bbc0c95668a37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a048b32c8601bb347886d5f3ea749221f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f">cp_time</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_timestamp.html">Timestamp</a> *result, bool allow_negative=false)</td></tr>
<tr class="memdesc:a048b32c8601bb347886d5f3ea749221f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a timestamp from <em>str</em>.  <a href="#a048b32c8601bb347886d5f3ea749221f">More...</a><br /></td></tr>
<tr class="separator:a048b32c8601bb347886d5f3ea749221f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935addf9585369269758b8970edae8b1"><td class="memItemLeft" align="right" valign="top"><a id="a935addf9585369269758b8970edae8b1"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_time</b> (const <a class="el" href="class_string.html">String</a> &amp;str, struct timeval *result)</td></tr>
<tr class="separator:a935addf9585369269758b8970edae8b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0abab0a34c041846472bf3e6ffae4be"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae0abab0a34c041846472bf3e6ffae4be">cp_bandwidth</a> (const <a class="el" href="class_string.html">String</a> &amp;str, uint32_t *result)</td></tr>
<tr class="memdesc:ae0abab0a34c041846472bf3e6ffae4be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a bandwidth value from <em>str</em>.  <a href="#ae0abab0a34c041846472bf3e6ffae4be">More...</a><br /></td></tr>
<tr class="separator:ae0abab0a34c041846472bf3e6ffae4be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8914824f1b08c1b6ff63f10b3583ada"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada">cp_ip_address</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_i_p_address.html">IPAddress</a> *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:aa8914824f1b08c1b6ff63f10b3583ada"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IP address from <em>str</em>.  <a href="#aa8914824f1b08c1b6ff63f10b3583ada">More...</a><br /></td></tr>
<tr class="separator:aa8914824f1b08c1b6ff63f10b3583ada"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531e5731ff39038d653be80bd7228e72"><td class="memItemLeft" align="right" valign="top"><a id="a531e5731ff39038d653be80bd7228e72"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip_address</b> (const <a class="el" href="class_string.html">String</a> &amp;str, struct in_addr *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:a531e5731ff39038d653be80bd7228e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859216a52ef2a4b1f57c4431c3137cb5"><td class="memItemLeft" align="right" valign="top"><a id="a859216a52ef2a4b1f57c4431c3137cb5"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip_address</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:a859216a52ef2a4b1f57c4431c3137cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b2a34a902c5b2855e016120c284b93"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93">cp_ip_prefix</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_i_p_address.html">IPAddress</a> *result_addr, <a class="el" href="class_i_p_address.html">IPAddress</a> *result_mask, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:ac6b2a34a902c5b2855e016120c284b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IP address or prefix from <em>str</em>.  <a href="#ac6b2a34a902c5b2855e016120c284b93">More...</a><br /></td></tr>
<tr class="separator:ac6b2a34a902c5b2855e016120c284b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae13dee9744cbc1c8f42c2e2d8a3d8b59"><td class="memItemLeft" align="right" valign="top"><a id="ae13dee9744cbc1c8f42c2e2d8a3d8b59"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result_addr, unsigned char *result_mask, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:ae13dee9744cbc1c8f42c2e2d8a3d8b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0a00dca9b4dce70389c5e195b1d54fa"><td class="memItemLeft" align="right" valign="top"><a id="ae0a00dca9b4dce70389c5e195b1d54fa"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_i_p_address.html">IPAddress</a> *result_addr, <a class="el" href="class_i_p_address.html">IPAddress</a> *result_mask, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:ae0a00dca9b4dce70389c5e195b1d54fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ab84b01fa49b48cb1a8a8a4ed294bf2"><td class="memItemLeft" align="right" valign="top"><a id="a0ab84b01fa49b48cb1a8a8a4ed294bf2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result_addr, unsigned char *result_mask, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:a0ab84b01fa49b48cb1a8a8a4ed294bf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851d8db616ba1745bcdbac8bdd5574cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a851d8db616ba1745bcdbac8bdd5574cf">cp_ip_address_list</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_i_p_address.html">IPAddress</a> &gt; *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:a851d8db616ba1745bcdbac8bdd5574cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a space-separated list of IP addresses from <em>str</em>.  <a href="#a851d8db616ba1745bcdbac8bdd5574cf">More...</a><br /></td></tr>
<tr class="separator:a851d8db616ba1745bcdbac8bdd5574cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a497851064c585d0fa473a30bf73998af"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a497851064c585d0fa473a30bf73998af">cp_ip6_address</a> (const <a class="el" href="class_string.html">String</a> &amp;str, IP6Address *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:a497851064c585d0fa473a30bf73998af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IPv6 address from <em>str</em>.  <a href="#a497851064c585d0fa473a30bf73998af">More...</a><br /></td></tr>
<tr class="separator:a497851064c585d0fa473a30bf73998af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b1ea1929313d4a3396f96ceb48a51e2"><td class="memItemLeft" align="right" valign="top"><a id="a6b1ea1929313d4a3396f96ceb48a51e2"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip6_address</b> (const <a class="el" href="class_string.html">String</a> &amp;str, struct in6_addr *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:a6b1ea1929313d4a3396f96ceb48a51e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada9b395b190617ca4ca8c659bc67d069"><td class="memItemLeft" align="right" valign="top"><a id="ada9b395b190617ca4ca8c659bc67d069"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip6_address</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:ada9b395b190617ca4ca8c659bc67d069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc5fd422bb8653469dcc1f655ba3e426"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426">cp_ip6_prefix</a> (const <a class="el" href="class_string.html">String</a> &amp;str, IP6Address *result_addr, int *result_prefix, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:afc5fd422bb8653469dcc1f655ba3e426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an IPv6 address or prefix from <em>str</em>.  <a href="#afc5fd422bb8653469dcc1f655ba3e426">More...</a><br /></td></tr>
<tr class="separator:afc5fd422bb8653469dcc1f655ba3e426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a1df81eafa59e9c8abfe921515ef3"><td class="memItemLeft" align="right" valign="top"><a id="aa18a1df81eafa59e9c8abfe921515ef3"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip6_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result_addr, int *result_prefix, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:aa18a1df81eafa59e9c8abfe921515ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe5331a76c3538000768f592d91d1711"><td class="memItemLeft" align="right" valign="top"><a id="afe5331a76c3538000768f592d91d1711"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip6_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result_addr, unsigned char *result_mask, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:afe5331a76c3538000768f592d91d1711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae884aeee68be3c0cdbc39dce39467977"><td class="memItemLeft" align="right" valign="top"><a id="ae884aeee68be3c0cdbc39dce39467977"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ip6_prefix</b> (const <a class="el" href="class_string.html">String</a> &amp;str, IP6Address *result_addr, IP6Address *result_mask, bool allow_bare_address, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:ae884aeee68be3c0cdbc39dce39467977"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71a07a747ecfafca77978fbace74d01d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a71a07a747ecfafca77978fbace74d01d">cp_ethernet_address</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_ether_address.html">EtherAddress</a> *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:a71a07a747ecfafca77978fbace74d01d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an Ethernet address from <em>str</em>.  <a href="#a71a07a747ecfafca77978fbace74d01d">More...</a><br /></td></tr>
<tr class="separator:a71a07a747ecfafca77978fbace74d01d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fbc7f34a5547a11c26ecd89841a071c"><td class="memItemLeft" align="right" valign="top"><a id="a2fbc7f34a5547a11c26ecd89841a071c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>cp_ethernet_address</b> (const <a class="el" href="class_string.html">String</a> &amp;str, unsigned char *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="separator:a2fbc7f34a5547a11c26ecd89841a071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b51d4b32b3318b2c02a376e5312d32d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d">cp_tcpudp_port</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int proto, uint16_t *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:a0b51d4b32b3318b2c02a376e5312d32d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a TCP, UDP, etc. port number from <em>str</em>.  <a href="#a0b51d4b32b3318b2c02a376e5312d32d">More...</a><br /></td></tr>
<tr class="separator:a0b51d4b32b3318b2c02a376e5312d32d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a04a5a56f54f32679a5d873ac1cd2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d">cp_element</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0, const char *argname=0)</td></tr>
<tr class="memdesc:a63a04a5a56f54f32679a5d873ac1cd2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an element reference from <em>str</em>.  <a href="#a63a04a5a56f54f32679a5d873ac1cd2d">More...</a><br /></td></tr>
<tr class="separator:a63a04a5a56f54f32679a5d873ac1cd2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63762d61a43ad8eede021212411cac1d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a63762d61a43ad8eede021212411cac1d">cp_element</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_router.html">Router</a> *router, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0, const char *argname=0)</td></tr>
<tr class="memdesc:a63762d61a43ad8eede021212411cac1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse an element reference from <em>str</em>.  <a href="#a63762d61a43ad8eede021212411cac1d">More...</a><br /></td></tr>
<tr class="separator:a63762d61a43ad8eede021212411cac1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad412ee0e6169740f40c956a0d533848b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ad412ee0e6169740f40c956a0d533848b">cp_handler_name</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_element.html">Element</a> **result_element, <a class="el" href="class_string.html">String</a> *result_hname, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0)</td></tr>
<tr class="memdesc:ad412ee0e6169740f40c956a0d533848b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a handler name from <em>str</em>.  <a href="#ad412ee0e6169740f40c956a0d533848b">More...</a><br /></td></tr>
<tr class="separator:ad412ee0e6169740f40c956a0d533848b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a332fd6a991c93467e3352f4b2c118a1f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a332fd6a991c93467e3352f4b2c118a1f">cp_handler</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int flags, <a class="el" href="class_element.html">Element</a> **result_element, const <a class="el" href="class_handler.html">Handler</a> **result_handler, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh=0)</td></tr>
<tr class="memdesc:a332fd6a991c93467e3352f4b2c118a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a handler reference from <em>str</em>.  <a href="#a332fd6a991c93467e3352f4b2c118a1f">More...</a><br /></td></tr>
<tr class="separator:a332fd6a991c93467e3352f4b2c118a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf06e7b3314f7e1806b0977ceac65e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a90bf06e7b3314f7e1806b0977ceac65e">cp_filename</a> (const <a class="el" href="class_string.html">String</a> &amp;str, <a class="el" href="class_string.html">String</a> *result)</td></tr>
<tr class="memdesc:a90bf06e7b3314f7e1806b0977ceac65e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a filename string from <em>str</em>.  <a href="#a90bf06e7b3314f7e1806b0977ceac65e">More...</a><br /></td></tr>
<tr class="separator:a90bf06e7b3314f7e1806b0977ceac65e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac46670c43208f88fbf5839a8347f92df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ac46670c43208f88fbf5839a8347f92df">cp_file_offset</a> (const <a class="el" href="class_string.html">String</a> &amp;str, off_t *result)</td></tr>
<tr class="memdesc:ac46670c43208f88fbf5839a8347f92df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a file offset from <em>str</em>.  <a href="#ac46670c43208f88fbf5839a8347f92df">More...</a><br /></td></tr>
<tr class="separator:ac46670c43208f88fbf5839a8347f92df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c9c7cd4046a5896351bace015bbcab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a74c9c7cd4046a5896351bace015bbcab">cp_anno</a> (const <a class="el" href="class_string.html">String</a> &amp;str, int size, int *result, const <a class="el" href="class_element.html">Element</a> *context=0)</td></tr>
<tr class="memdesc:a74c9c7cd4046a5896351bace015bbcab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a packet annotation value from <em>str</em>.  <a href="#a74c9c7cd4046a5896351bace015bbcab">More...</a><br /></td></tr>
<tr class="separator:a74c9c7cd4046a5896351bace015bbcab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
cp_va_kparse</h2></td></tr>
<tr class="memitem:a63ecb5b3b015b237f2f78b05595f07f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2">CpKparseFlags</a> { <br />
&#160;&#160;<a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f">cpkN</a> = 0, 
<a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9">cpkM</a> = 1, 
<a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a> = 2, 
<a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67">cpkC</a> = 4, 
<br />
&#160;&#160;<a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a7986189d1880a2ea7e04c5b80cf29400">cpkD</a> = 8, 
<b>cpkNormal</b> = cpkN, 
<b>cpkMandatory</b> = cpkM, 
<b>cpkPositional</b> = cpkP, 
<br />
&#160;&#160;<b>cpkConfirm</b> = cpkC, 
<b>cpkDeprecated</b> = cpkD
<br />
 }<tr class="memdesc:a63ecb5b3b015b237f2f78b05595f07f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of flags for <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> items.  <a href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2">More...</a><br /></td></tr>
</td></tr>
<tr class="separator:a63ecb5b3b015b237f2f78b05595f07f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2cc0db6bee483e94e998211609d876"><td class="memItemLeft" align="right" valign="top">typedef const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a></td></tr>
<tr class="memdesc:aac2cc0db6bee483e94e998211609d876"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of argument type names for <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> items.  <a href="#aac2cc0db6bee483e94e998211609d876">More...</a><br /></td></tr>
<tr class="separator:aac2cc0db6bee483e94e998211609d876"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3107cb41175a9f2d8910ec6004458e91"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a></td></tr>
<tr class="memdesc:a3107cb41175a9f2d8910ec6004458e91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use as argument name. Ends cp_va argument list.  <a href="#a3107cb41175a9f2d8910ec6004458e91">More...</a><br /></td></tr>
<tr class="separator:a3107cb41175a9f2d8910ec6004458e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8aad812afb85b0fef0f20e004bfa0b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a5d8aad812afb85b0fef0f20e004bfa0b">cpIgnoreRest</a></td></tr>
<tr class="memdesc:a5d8aad812afb85b0fef0f20e004bfa0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use as argument name. No result storage; causes <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> to ignore unparsed arguments and any remaining items.  <a href="#a5d8aad812afb85b0fef0f20e004bfa0b">More...</a><br /></td></tr>
<tr class="separator:a5d8aad812afb85b0fef0f20e004bfa0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa57761bf1391314f00669b8e6fd3e8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a9fa57761bf1391314f00669b8e6fd3e8">cpIgnore</a></td></tr>
<tr class="memdesc:a9fa57761bf1391314f00669b8e6fd3e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">No result storage, ignores this argument.  <a href="#a9fa57761bf1391314f00669b8e6fd3e8">More...</a><br /></td></tr>
<tr class="separator:a9fa57761bf1391314f00669b8e6fd3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ac02b6dea6f2826d3547b3939f9a15"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a54ac02b6dea6f2826d3547b3939f9a15">cpArgument</a></td></tr>
<tr class="memdesc:a54ac02b6dea6f2826d3547b3939f9a15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage String*, accepts any argument.  <a href="#a54ac02b6dea6f2826d3547b3939f9a15">More...</a><br /></td></tr>
<tr class="separator:a54ac02b6dea6f2826d3547b3939f9a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8b20288115ebdc905a473a9ccea9360"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae8b20288115ebdc905a473a9ccea9360">cpArguments</a></td></tr>
<tr class="memdesc:ae8b20288115ebdc905a473a9ccea9360"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage <a class="el" href="class_vector.html">Vector&lt;String&gt;</a>*, accepts any number of arguments with the same keyword.  <a href="#ae8b20288115ebdc905a473a9ccea9360">More...</a><br /></td></tr>
<tr class="separator:ae8b20288115ebdc905a473a9ccea9360"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b070881b58db387ca6b8de0ee019be4"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a7b070881b58db387ca6b8de0ee019be4">cpString</a></td></tr>
<tr class="memdesc:a7b070881b58db387ca6b8de0ee019be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>.  <a href="#a7b070881b58db387ca6b8de0ee019be4">More...</a><br /></td></tr>
<tr class="separator:a7b070881b58db387ca6b8de0ee019be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239e7339df236b3643d249865391ea6a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a239e7339df236b3643d249865391ea6a">cpWord</a></td></tr>
<tr class="memdesc:a239e7339df236b3643d249865391ea6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage String*, parsed by <a class="el" href="confparse_8hh.html#aae21647d30503b2b4e2bb04fd8842922" title="Parse a word from str. ">cp_word()</a>.  <a href="#a239e7339df236b3643d249865391ea6a">More...</a><br /></td></tr>
<tr class="separator:a239e7339df236b3643d249865391ea6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c005f21cdbacc729d17cd76a2e8fa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a7e0c005f21cdbacc729d17cd76a2e8fa">cpKeyword</a></td></tr>
<tr class="memdesc:a7e0c005f21cdbacc729d17cd76a2e8fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a17450dcd527f644e36009aefb1e1bd36" title="Parse a keyword from str. ">cp_keyword()</a>.  <a href="#a7e0c005f21cdbacc729d17cd76a2e8fa">More...</a><br /></td></tr>
<tr class="separator:a7e0c005f21cdbacc729d17cd76a2e8fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70743b45b8c583047e6405006d3e997d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a></td></tr>
<tr class="memdesc:a70743b45b8c583047e6405006d3e997d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage bool*, parsed by <a class="el" href="confparse_8hh.html#a7e741359e6048d9847df83ba3b790c71" title="Parse a boolean from str. ">cp_bool()</a>.  <a href="#a70743b45b8c583047e6405006d3e997d">More...</a><br /></td></tr>
<tr class="separator:a70743b45b8c583047e6405006d3e997d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802b1f261939ad1e1f602338ca6bc58c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a802b1f261939ad1e1f602338ca6bc58c">cpByte</a></td></tr>
<tr class="memdesc:a802b1f261939ad1e1f602338ca6bc58c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage unsigned char*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a802b1f261939ad1e1f602338ca6bc58c">More...</a><br /></td></tr>
<tr class="separator:a802b1f261939ad1e1f602338ca6bc58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd1be6b084c9bb8de30b85feb1c1257"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a8cd1be6b084c9bb8de30b85feb1c1257">cpShort</a></td></tr>
<tr class="memdesc:a8cd1be6b084c9bb8de30b85feb1c1257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage short*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a8cd1be6b084c9bb8de30b85feb1c1257">More...</a><br /></td></tr>
<tr class="separator:a8cd1be6b084c9bb8de30b85feb1c1257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a1557bacb0e0be5143db5e59aaa8b5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a16a1557bacb0e0be5143db5e59aaa8b5">cpUnsignedShort</a></td></tr>
<tr class="memdesc:a16a1557bacb0e0be5143db5e59aaa8b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage unsigned short*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a16a1557bacb0e0be5143db5e59aaa8b5">More...</a><br /></td></tr>
<tr class="separator:a16a1557bacb0e0be5143db5e59aaa8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af668236f4b4a15caf6f2508cd25bfc87"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#af668236f4b4a15caf6f2508cd25bfc87">cpInteger</a></td></tr>
<tr class="memdesc:af668236f4b4a15caf6f2508cd25bfc87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage int32_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#af668236f4b4a15caf6f2508cd25bfc87">More...</a><br /></td></tr>
<tr class="separator:af668236f4b4a15caf6f2508cd25bfc87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c3a4f21b5a8c8015edce2e7bc359ab"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a02c3a4f21b5a8c8015edce2e7bc359ab">cpUnsigned</a></td></tr>
<tr class="memdesc:a02c3a4f21b5a8c8015edce2e7bc359ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a02c3a4f21b5a8c8015edce2e7bc359ab">More...</a><br /></td></tr>
<tr class="separator:a02c3a4f21b5a8c8015edce2e7bc359ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38afa0eb33df387c613d1f8e0a00e779"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a38afa0eb33df387c613d1f8e0a00e779">cpSize</a></td></tr>
<tr class="memdesc:a38afa0eb33df387c613d1f8e0a00e779"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage size_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a38afa0eb33df387c613d1f8e0a00e779">More...</a><br /></td></tr>
<tr class="separator:a38afa0eb33df387c613d1f8e0a00e779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c416e44a66c4cafd9ae5a9246ef5483"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a4c416e44a66c4cafd9ae5a9246ef5483">cpNamedInteger</a></td></tr>
<tr class="memdesc:a4c416e44a66c4cafd9ae5a9246ef5483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter uint32_t nameinfo_type, result storage int32_t*, parsed by <a class="el" href="class_name_info.html#a0c5ec52346d286545d099ff4139ef80e" title="Query installed databases for name, returning a 32-bit integer value. ">NameInfo::query_int</a>.  <a href="#a4c416e44a66c4cafd9ae5a9246ef5483">More...</a><br /></td></tr>
<tr class="separator:a4c416e44a66c4cafd9ae5a9246ef5483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddf47f0316112e6b1f3df89908a34cf"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a9ddf47f0316112e6b1f3df89908a34cf">cpInteger64</a></td></tr>
<tr class="memdesc:a9ddf47f0316112e6b1f3df89908a34cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage int64_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#a9ddf47f0316112e6b1f3df89908a34cf">More...</a><br /></td></tr>
<tr class="separator:a9ddf47f0316112e6b1f3df89908a34cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc20aa1cbb0a3562476200c25423f45e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afc20aa1cbb0a3562476200c25423f45e">cpUnsigned64</a></td></tr>
<tr class="memdesc:afc20aa1cbb0a3562476200c25423f45e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint64_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#afc20aa1cbb0a3562476200c25423f45e">More...</a><br /></td></tr>
<tr class="separator:afc20aa1cbb0a3562476200c25423f45e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6359a0cdf3daf568fa6e1399ac88afa9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a6359a0cdf3daf568fa6e1399ac88afa9">cpUnsignedReal2</a></td></tr>
<tr class="memdesc:a6359a0cdf3daf568fa6e1399ac88afa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter int frac_bits, result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84" title="Parse a fixed-point number from str. ">cp_real2()</a>.  <a href="#a6359a0cdf3daf568fa6e1399ac88afa9">More...</a><br /></td></tr>
<tr class="separator:a6359a0cdf3daf568fa6e1399ac88afa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026f56003e8aa5eb72aec8b7b16e859d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a026f56003e8aa5eb72aec8b7b16e859d">cpReal10</a></td></tr>
<tr class="memdesc:a026f56003e8aa5eb72aec8b7b16e859d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter int frac_digits, result storage int32_t*, parsed by <a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e" title="Parse a real number from str, representing the result as an integer with frac_digits decimal digits o...">cp_real10()</a>.  <a href="#a026f56003e8aa5eb72aec8b7b16e859d">More...</a><br /></td></tr>
<tr class="separator:a026f56003e8aa5eb72aec8b7b16e859d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74d4a665ecfbbdf6947a1a7be5114dd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aa74d4a665ecfbbdf6947a1a7be5114dd">cpUnsignedReal10</a></td></tr>
<tr class="memdesc:aa74d4a665ecfbbdf6947a1a7be5114dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter int frac_digits, result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e" title="Parse a real number from str, representing the result as an integer with frac_digits decimal digits o...">cp_real10()</a>.  <a href="#aa74d4a665ecfbbdf6947a1a7be5114dd">More...</a><br /></td></tr>
<tr class="separator:aa74d4a665ecfbbdf6947a1a7be5114dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5f31418cced25a485e8e97e68a44b1b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae5f31418cced25a485e8e97e68a44b1b">cpDouble</a></td></tr>
<tr class="memdesc:ae5f31418cced25a485e8e97e68a44b1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage double*, parsed by <a class="el" href="confparse_8hh.html#a03e3d6bb41be9959f40a37f217d9bc2a" title="Parse a real number from str. ">cp_double()</a>.  <a href="#ae5f31418cced25a485e8e97e68a44b1b">More...</a><br /></td></tr>
<tr class="separator:ae5f31418cced25a485e8e97e68a44b1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad644d2dd40557bae281415614eb7df20"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ad644d2dd40557bae281415614eb7df20">cpSeconds</a></td></tr>
<tr class="memdesc:ad644d2dd40557bae281415614eb7df20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a45f4dd1ae1146aad253b6ecf69000f6c" title="Parse an amount of time from str. ">cp_seconds_as()</a> with frac_digits 0.  <a href="#ad644d2dd40557bae281415614eb7df20">More...</a><br /></td></tr>
<tr class="separator:ad644d2dd40557bae281415614eb7df20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a014e4a35daa90e43bc68e06bdf17ab6b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a014e4a35daa90e43bc68e06bdf17ab6b">cpSecondsAsMilli</a></td></tr>
<tr class="memdesc:a014e4a35daa90e43bc68e06bdf17ab6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#afa241b9899bd1118769cbff9ce75c18f" title="Parse an amount of time in milliseconds from str. ">cp_seconds_as_milli()</a>.  <a href="#a014e4a35daa90e43bc68e06bdf17ab6b">More...</a><br /></td></tr>
<tr class="separator:a014e4a35daa90e43bc68e06bdf17ab6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a699ac8df64f0031e842c1ccc8b639ad0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a699ac8df64f0031e842c1ccc8b639ad0">cpSecondsAsMicro</a></td></tr>
<tr class="memdesc:a699ac8df64f0031e842c1ccc8b639ad0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a1502cc5e990c25518f8c16536493136f" title="Parse an amount of time in microseconds from str. ">cp_seconds_as_micro()</a>.  <a href="#a699ac8df64f0031e842c1ccc8b639ad0">More...</a><br /></td></tr>
<tr class="separator:a699ac8df64f0031e842c1ccc8b639ad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c309617bf09f1a1befa6c737b23c88"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae9c309617bf09f1a1befa6c737b23c88">cpTimestamp</a></td></tr>
<tr class="memdesc:ae9c309617bf09f1a1befa6c737b23c88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage Timestamp*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>.  <a href="#ae9c309617bf09f1a1befa6c737b23c88">More...</a><br /></td></tr>
<tr class="separator:ae9c309617bf09f1a1befa6c737b23c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afccf0abca85e42010de19371c41234c7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afccf0abca85e42010de19371c41234c7">cpTimestampSigned</a></td></tr>
<tr class="memdesc:afccf0abca85e42010de19371c41234c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage Timestamp*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>.  <a href="#afccf0abca85e42010de19371c41234c7">More...</a><br /></td></tr>
<tr class="separator:afccf0abca85e42010de19371c41234c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23f87af591ff92757961888efe6b2ac"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ac23f87af591ff92757961888efe6b2ac">cpTimeval</a></td></tr>
<tr class="memdesc:ac23f87af591ff92757961888efe6b2ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage struct timeval*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>.  <a href="#ac23f87af591ff92757961888efe6b2ac">More...</a><br /></td></tr>
<tr class="separator:ac23f87af591ff92757961888efe6b2ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad6c97ac8eca209f5663d250647ec08c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aad6c97ac8eca209f5663d250647ec08c">cpBandwidth</a></td></tr>
<tr class="memdesc:aad6c97ac8eca209f5663d250647ec08c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#ae0abab0a34c041846472bf3e6ffae4be" title="Parse a bandwidth value from str. ">cp_bandwidth()</a>.  <a href="#aad6c97ac8eca209f5663d250647ec08c">More...</a><br /></td></tr>
<tr class="separator:aad6c97ac8eca209f5663d250647ec08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7bdbf222a354f7864e8ce284fd1fe42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ad7bdbf222a354f7864e8ce284fd1fe42">cpIPAddress</a></td></tr>
<tr class="memdesc:ad7bdbf222a354f7864e8ce284fd1fe42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IPAddress* or equivalent, parsed by <a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada" title="Parse an IP address from str. ">cp_ip_address()</a>.  <a href="#ad7bdbf222a354f7864e8ce284fd1fe42">More...</a><br /></td></tr>
<tr class="separator:ad7bdbf222a354f7864e8ce284fd1fe42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234dd84d3576cb40a2cee3a4e1ddd00d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a234dd84d3576cb40a2cee3a4e1ddd00d">cpIPPrefix</a></td></tr>
<tr class="memdesc:a234dd84d3576cb40a2cee3a4e1ddd00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IPAddress* addr and <a class="el" href="class_i_p_address.html" title="An IPv4 address. ">IPAddress</a> *mask, parsed by <a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93" title="Parse an IP address or prefix from str. ">cp_ip_prefix()</a>.  <a href="#a234dd84d3576cb40a2cee3a4e1ddd00d">More...</a><br /></td></tr>
<tr class="separator:a234dd84d3576cb40a2cee3a4e1ddd00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc77d6340ef7fb659fa154220ff2460a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#afc77d6340ef7fb659fa154220ff2460a">cpIPAddressOrPrefix</a></td></tr>
<tr class="memdesc:afc77d6340ef7fb659fa154220ff2460a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IPAddress* addr and <a class="el" href="class_i_p_address.html" title="An IPv4 address. ">IPAddress</a> *mask, parsed by <a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93" title="Parse an IP address or prefix from str. ">cp_ip_prefix()</a>.  <a href="#afc77d6340ef7fb659fa154220ff2460a">More...</a><br /></td></tr>
<tr class="separator:afc77d6340ef7fb659fa154220ff2460a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9193eabb4fe3e037861d5a139b44908"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ab9193eabb4fe3e037861d5a139b44908">cpIPAddressList</a></td></tr>
<tr class="memdesc:ab9193eabb4fe3e037861d5a139b44908"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage Vector&lt;IPAddress&gt;*, parsed by <a class="el" href="confparse_8hh.html#a851d8db616ba1745bcdbac8bdd5574cf" title="Parse a space-separated list of IP addresses from str. ">cp_ip_address_list()</a>.  <a href="#ab9193eabb4fe3e037861d5a139b44908">More...</a><br /></td></tr>
<tr class="separator:ab9193eabb4fe3e037861d5a139b44908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac726d572fd623b660689f967491072fe"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ac726d572fd623b660689f967491072fe">cpEtherAddress</a></td></tr>
<tr class="memdesc:ac726d572fd623b660689f967491072fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage EtherAddress*, parsed by <a class="el" href="confparse_8hh.html#a71a07a747ecfafca77978fbace74d01d" title="Parse an Ethernet address from str. ">cp_ethernet_address()</a>.  <a href="#ac726d572fd623b660689f967491072fe">More...</a><br /></td></tr>
<tr class="separator:ac726d572fd623b660689f967491072fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b872143fdfb48efbc3f80e696b67a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a88b872143fdfb48efbc3f80e696b67a1">cpEthernetAddress</a></td></tr>
<tr class="memdesc:a88b872143fdfb48efbc3f80e696b67a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage EtherAddress*, parsed by <a class="el" href="confparse_8hh.html#a71a07a747ecfafca77978fbace74d01d" title="Parse an Ethernet address from str. ">cp_ethernet_address()</a>. Synonym for cpEtherAddress.  <a href="#a88b872143fdfb48efbc3f80e696b67a1">More...</a><br /></td></tr>
<tr class="separator:a88b872143fdfb48efbc3f80e696b67a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a586c2aabfd7ddab05a07b3e9f72f0809"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a586c2aabfd7ddab05a07b3e9f72f0809">cpTCPPort</a></td></tr>
<tr class="memdesc:a586c2aabfd7ddab05a07b3e9f72f0809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint16_t*, parsed by <a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d" title="Parse a TCP, UDP, etc. port number from str. ">cp_tcpudp_port()</a>.  <a href="#a586c2aabfd7ddab05a07b3e9f72f0809">More...</a><br /></td></tr>
<tr class="separator:a586c2aabfd7ddab05a07b3e9f72f0809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a8767dbcabfcb15a8a25e9314d48927"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a9a8767dbcabfcb15a8a25e9314d48927">cpUDPPort</a></td></tr>
<tr class="memdesc:a9a8767dbcabfcb15a8a25e9314d48927"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage uint16_t*, parsed by <a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d" title="Parse a TCP, UDP, etc. port number from str. ">cp_tcpudp_port()</a>.  <a href="#a9a8767dbcabfcb15a8a25e9314d48927">More...</a><br /></td></tr>
<tr class="separator:a9a8767dbcabfcb15a8a25e9314d48927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b54fa1eff1f6cc1db41f1be29407a1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#af0b54fa1eff1f6cc1db41f1be29407a1">cpElement</a></td></tr>
<tr class="memdesc:af0b54fa1eff1f6cc1db41f1be29407a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage Element**, parsed by <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a>.  <a href="#af0b54fa1eff1f6cc1db41f1be29407a1">More...</a><br /></td></tr>
<tr class="separator:af0b54fa1eff1f6cc1db41f1be29407a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8f7c4e4b874ffe5bb9ee3b5c740fa17"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae8f7c4e4b874ffe5bb9ee3b5c740fa17">cpElementCast</a></td></tr>
<tr class="memdesc:ae8f7c4e4b874ffe5bb9ee3b5c740fa17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter const char*, result storage void**, parsed by <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a> and <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">Element::cast()</a>.  <a href="#ae8f7c4e4b874ffe5bb9ee3b5c740fa17">More...</a><br /></td></tr>
<tr class="separator:ae8f7c4e4b874ffe5bb9ee3b5c740fa17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48dc97b1196c9cfcdd053a9aea4a37d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ab48dc97b1196c9cfcdd053a9aea4a37d">cpHandlerName</a></td></tr>
<tr class="memdesc:ab48dc97b1196c9cfcdd053a9aea4a37d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage Element** and String*, parsed by <a class="el" href="confparse_8hh.html#ad412ee0e6169740f40c956a0d533848b" title="Parse a handler name from str. ">cp_handler_name()</a>.  <a href="#ab48dc97b1196c9cfcdd053a9aea4a37d">More...</a><br /></td></tr>
<tr class="separator:ab48dc97b1196c9cfcdd053a9aea4a37d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e466630ef61518c01bfafaa4a69226"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#af3e466630ef61518c01bfafaa4a69226">cpHandlerCallRead</a></td></tr>
<tr class="memdesc:af3e466630ef61518c01bfafaa4a69226"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage HandlerCall*, parsed by <a class="el" href="class_handler_call.html" title="Convenience class for calling handlers. ">HandlerCall</a>.  <a href="#af3e466630ef61518c01bfafaa4a69226">More...</a><br /></td></tr>
<tr class="separator:af3e466630ef61518c01bfafaa4a69226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd8fa488e307cc0be357d87ff0c6fd0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a2fd8fa488e307cc0be357d87ff0c6fd0">cpHandlerCallWrite</a></td></tr>
<tr class="memdesc:a2fd8fa488e307cc0be357d87ff0c6fd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage HandlerCall*, parsed by <a class="el" href="class_handler_call.html" title="Convenience class for calling handlers. ">HandlerCall</a>.  <a href="#a2fd8fa488e307cc0be357d87ff0c6fd0">More...</a><br /></td></tr>
<tr class="separator:a2fd8fa488e307cc0be357d87ff0c6fd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2d978036217313a428f043b450dfb0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ad2d978036217313a428f043b450dfb0a">cpHandlerCallPtrRead</a></td></tr>
<tr class="memdesc:ad2d978036217313a428f043b450dfb0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage HandlerCall**, parsed by <a class="el" href="class_handler_call.html#a4ff40e1bb09141973016bb3259df531c" title="Create and initialize a read HandlerCall from hdesc. ">HandlerCall::reset_read</a>.  <a href="#ad2d978036217313a428f043b450dfb0a">More...</a><br /></td></tr>
<tr class="separator:ad2d978036217313a428f043b450dfb0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6670db8f13b686aa92603150e2cf2b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aed6670db8f13b686aa92603150e2cf2b">cpHandlerCallPtrWrite</a></td></tr>
<tr class="memdesc:aed6670db8f13b686aa92603150e2cf2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage HandlerCall**, parsed by <a class="el" href="class_handler_call.html#a79ef3c74336920b4e856d4b7d4f0941e" title="Create and initialize a write HandlerCall from hdesc. ">HandlerCall::reset_write</a>.  <a href="#aed6670db8f13b686aa92603150e2cf2b">More...</a><br /></td></tr>
<tr class="separator:aed6670db8f13b686aa92603150e2cf2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f1175365a79b40e1a9baff9376c99c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a30f1175365a79b40e1a9baff9376c99c">cpIP6Address</a></td></tr>
<tr class="memdesc:a30f1175365a79b40e1a9baff9376c99c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IP6Address* or equivalent, parsed by <a class="el" href="confparse_8hh.html#a497851064c585d0fa473a30bf73998af" title="Parse an IPv6 address from str. ">cp_ip6_address()</a>.  <a href="#a30f1175365a79b40e1a9baff9376c99c">More...</a><br /></td></tr>
<tr class="separator:a30f1175365a79b40e1a9baff9376c99c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b15ecc0f6e9f52060d7e031087e4aa"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a16b15ecc0f6e9f52060d7e031087e4aa">cpIP6Prefix</a></td></tr>
<tr class="memdesc:a16b15ecc0f6e9f52060d7e031087e4aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IP6Address* addr and IP6Address* mask, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>.  <a href="#a16b15ecc0f6e9f52060d7e031087e4aa">More...</a><br /></td></tr>
<tr class="separator:a16b15ecc0f6e9f52060d7e031087e4aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fee93fa661924ae0a0e2409ce07ed3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a52fee93fa661924ae0a0e2409ce07ed3">cpIP6PrefixLen</a></td></tr>
<tr class="memdesc:a52fee93fa661924ae0a0e2409ce07ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IP6Address* addr and int* prefix_len, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>.  <a href="#a52fee93fa661924ae0a0e2409ce07ed3">More...</a><br /></td></tr>
<tr class="separator:a52fee93fa661924ae0a0e2409ce07ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17decc8597d6ee5135216d2fa5a5247"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#af17decc8597d6ee5135216d2fa5a5247">cpIP6AddressOrPrefix</a></td></tr>
<tr class="memdesc:af17decc8597d6ee5135216d2fa5a5247"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage IP6Address* addr and IP6Address* mask, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>.  <a href="#af17decc8597d6ee5135216d2fa5a5247">More...</a><br /></td></tr>
<tr class="separator:af17decc8597d6ee5135216d2fa5a5247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620dc576beec00aefd8872fc2703092f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a620dc576beec00aefd8872fc2703092f">cpFilename</a></td></tr>
<tr class="memdesc:a620dc576beec00aefd8872fc2703092f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a90bf06e7b3314f7e1806b0977ceac65e" title="Parse a filename string from str. ">cp_filename()</a>.  <a href="#a620dc576beec00aefd8872fc2703092f">More...</a><br /></td></tr>
<tr class="separator:a620dc576beec00aefd8872fc2703092f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae21e655b2d4e0d5e91ca3ddc242eb61c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#ae21e655b2d4e0d5e91ca3ddc242eb61c">cpFileOffset</a></td></tr>
<tr class="memdesc:ae21e655b2d4e0d5e91ca3ddc242eb61c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Result storage off_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>.  <a href="#ae21e655b2d4e0d5e91ca3ddc242eb61c">More...</a><br /></td></tr>
<tr class="separator:ae21e655b2d4e0d5e91ca3ddc242eb61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf82791e7d98a4e9cb78c10ab244d9f7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#abf82791e7d98a4e9cb78c10ab244d9f7">cpAnno</a></td></tr>
<tr class="memdesc:abf82791e7d98a4e9cb78c10ab244d9f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse parameter int annotation_size, result storage int*, parsed by <a class="el" href="confparse_8hh.html#a74c9c7cd4046a5896351bace015bbcab" title="Parse a packet annotation value from str. ">cp_anno()</a>.  <a href="#abf82791e7d98a4e9cb78c10ab244d9f7">More...</a><br /></td></tr>
<tr class="separator:abf82791e7d98a4e9cb78c10ab244d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb026faaf3c7dbd25a48f3e1124abf0d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#abb026faaf3c7dbd25a48f3e1124abf0d">cpOptional</a></td></tr>
<tr class="memdesc:abb026faaf3c7dbd25a48f3e1124abf0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">cp_va_parse only: Following arguments are optional.  <a href="#abb026faaf3c7dbd25a48f3e1124abf0d">More...</a><br /></td></tr>
<tr class="separator:abb026faaf3c7dbd25a48f3e1124abf0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca9a72e47b3d5f977b367f7222d0a9bc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aca9a72e47b3d5f977b367f7222d0a9bc">cpKeywords</a></td></tr>
<tr class="memdesc:aca9a72e47b3d5f977b367f7222d0a9bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">cp_va_parse only: Following arguments are keywords.  <a href="#aca9a72e47b3d5f977b367f7222d0a9bc">More...</a><br /></td></tr>
<tr class="separator:aca9a72e47b3d5f977b367f7222d0a9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3617951ee3e5b9eb80018ec269c612"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a3d3617951ee3e5b9eb80018ec269c612">cpConfirmKeywords</a></td></tr>
<tr class="memdesc:a3d3617951ee3e5b9eb80018ec269c612"><td class="mdescLeft">&#160;</td><td class="mdescRight">cp_va_parse only: Following arguments are confirmed keywords.  <a href="#a3d3617951ee3e5b9eb80018ec269c612">More...</a><br /></td></tr>
<tr class="separator:a3d3617951ee3e5b9eb80018ec269c612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab09850bee7830d5557596adddcc6200"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#aab09850bee7830d5557596adddcc6200">cpMandatoryKeywords</a></td></tr>
<tr class="memdesc:aab09850bee7830d5557596adddcc6200"><td class="mdescLeft">&#160;</td><td class="mdescRight">cp_va_parse only: Following arguments are mandatory keywords.  <a href="#aab09850bee7830d5557596adddcc6200">More...</a><br /></td></tr>
<tr class="separator:aab09850bee7830d5557596adddcc6200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30e22aba18c4758d29378a9503936b56"><td class="memItemLeft" align="right" valign="top"><a id="a30e22aba18c4758d29378a9503936b56"></a>
const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpInterval&#160;</td><td class="memItemRight" valign="bottom"><b>CLICK_CONFPARSE_DEPRECATED</b></td></tr>
<tr class="separator:a30e22aba18c4758d29378a9503936b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cf73ba574654eee9d96123c45fe3484"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...) CP_SENTINEL</td></tr>
<tr class="memdesc:a9cf73ba574654eee9d96123c45fe3484"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a list of arguments.  <a href="#a9cf73ba574654eee9d96123c45fe3484">More...</a><br /></td></tr>
<tr class="separator:a9cf73ba574654eee9d96123c45fe3484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84da63c103be27b0e23720caebb8049a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a84da63c103be27b0e23720caebb8049a">cp_va_kparse</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...) CP_SENTINEL</td></tr>
<tr class="memdesc:a84da63c103be27b0e23720caebb8049a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a comma-separated argument string.  <a href="#a84da63c103be27b0e23720caebb8049a">More...</a><br /></td></tr>
<tr class="separator:a84da63c103be27b0e23720caebb8049a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837ac4bbf266763b5eebb3e02a10b4da"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a837ac4bbf266763b5eebb3e02a10b4da">cp_va_space_kparse</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...) CP_SENTINEL</td></tr>
<tr class="memdesc:a837ac4bbf266763b5eebb3e02a10b4da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a space-separated argument string.  <a href="#a837ac4bbf266763b5eebb3e02a10b4da">More...</a><br /></td></tr>
<tr class="separator:a837ac4bbf266763b5eebb3e02a10b4da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9217b8857a6309841ba3d075ef85437a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a9217b8857a6309841ba3d075ef85437a">cp_va_kparse_keyword</a> (const <a class="el" href="class_string.html">String</a> &amp;str, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...) CP_SENTINEL</td></tr>
<tr class="memdesc:a9217b8857a6309841ba3d075ef85437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a single argument.  <a href="#a9217b8857a6309841ba3d075ef85437a">More...</a><br /></td></tr>
<tr class="separator:a9217b8857a6309841ba3d075ef85437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b6a55a3d1d22bbadfaf378a301edf0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a01b6a55a3d1d22bbadfaf378a301edf0">cp_va_kparse_remove_keywords</a> (<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, const <a class="el" href="class_element.html">Element</a> *context, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh,...) CP_SENTINEL</td></tr>
<tr class="memdesc:a01b6a55a3d1d22bbadfaf378a301edf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse and remove matching arguments from <em>conf</em>.  <a href="#a01b6a55a3d1d22bbadfaf378a301edf0">More...</a><br /></td></tr>
<tr class="separator:a01b6a55a3d1d22bbadfaf378a301edf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda9203fe690e72bbc1688a3c740c37e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#acda9203fe690e72bbc1688a3c740c37e">cp_assign_arguments</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;argv, const <a class="el" href="class_string.html">String</a> *param_begin, const <a class="el" href="class_string.html">String</a> *param_end, <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; *values=0)</td></tr>
<tr class="memdesc:acda9203fe690e72bbc1688a3c740c37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign arguments from <em>argv</em> to <em>values</em>.  <a href="#acda9203fe690e72bbc1688a3c740c37e">More...</a><br /></td></tr>
<tr class="separator:acda9203fe690e72bbc1688a3c740c37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05dd05870811fb091be88db69a5ff502"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a05dd05870811fb091be88db69a5ff502">cp_va_static_initialize</a> ()</td></tr>
<tr class="memdesc:a05dd05870811fb091be88db69a5ff502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> implementation.  <a href="#a05dd05870811fb091be88db69a5ff502">More...</a><br /></td></tr>
<tr class="separator:a05dd05870811fb091be88db69a5ff502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb0691a7e955c32f99724829b232252"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="confparse_8hh.html#a2bb0691a7e955c32f99724829b232252">cp_va_static_cleanup</a> ()</td></tr>
<tr class="memdesc:a2bb0691a7e955c32f99724829b232252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clean up the <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> implementation.  <a href="#a2bb0691a7e955c32f99724829b232252">More...</a><br /></td></tr>
<tr class="separator:a2bb0691a7e955c32f99724829b232252"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Argument Types for cp_va_kparse()</h2></td></tr>
<tr class="memitem:ab04a0655cd1e3bcac5e8f48c18df1a57"><td class="memItemLeft" align="right" valign="top"><a id="ab04a0655cd1e3bcac5e8f48c18df1a57"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <br />
&#160;&#160;<b>cpArgNormal</b> = 0, 
<b>cpArgStore2</b> = 1, 
<b>cpArgExtraInt</b> = 2, 
<b>cpArgExtraCStr</b> = 4, 
<br />
&#160;&#160;<b>cpArgAllowNumbers</b> = 8
<br />
 }</td></tr>
<tr class="separator:ab04a0655cd1e3bcac5e8f48c18df1a57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69a1bb18497660b4cc18e23bff38091"><td class="memItemLeft" align="right" valign="top"><a id="ac69a1bb18497660b4cc18e23bff38091"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>cp_parsefunc</b>) (cp_value *value, const <a class="el" href="class_string.html">String</a> &amp;arg, <a class="el" href="class_error_handler.html">ErrorHandler</a> *errh, const char *argdesc, const <a class="el" href="class_element.html">Element</a> *context)</td></tr>
<tr class="separator:ac69a1bb18497660b4cc18e23bff38091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13cd006e38826c954f35f4290b4dcd1e"><td class="memItemLeft" align="right" valign="top"><a id="a13cd006e38826c954f35f4290b4dcd1e"></a>
typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><b>cp_storefunc</b>) (cp_value *value, const <a class="el" href="class_element.html">Element</a> *context)</td></tr>
<tr class="separator:a13cd006e38826c954f35f4290b4dcd1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cac7f89635e6670974e03de16234540"><td class="memItemLeft" align="right" valign="top"><a id="a3cac7f89635e6670974e03de16234540"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cp_register_argtype</b> (const char *name, const char *description, int flags, cp_parsefunc parsefunc, cp_storefunc storefunc, void *user_data=0)</td></tr>
<tr class="separator:a3cac7f89635e6670974e03de16234540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df66b5d6e8627d86295f6c05e51760b"><td class="memItemLeft" align="right" valign="top"><a id="a4df66b5d6e8627d86295f6c05e51760b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>cp_unregister_argtype</b> (const char *name)</td></tr>
<tr class="separator:a4df66b5d6e8627d86295f6c05e51760b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafc8dd18c87995d3d8ae9d7b997b081"><td class="memItemLeft" align="right" valign="top"><a id="afafc8dd18c87995d3d8ae9d7b997b081"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cp_register_stringlist_argtype</b> (const char *name, const char *description, int flags)</td></tr>
<tr class="separator:afafc8dd18c87995d3d8ae9d7b997b081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0ca2725b7d3f865c59c85b0641c62e1"><td class="memItemLeft" align="right" valign="top"><a id="ae0ca2725b7d3f865c59c85b0641c62e1"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>cp_extend_stringlist_argtype</b> (const char *name,...)</td></tr>
<tr class="separator:ae0ca2725b7d3f865c59c85b0641c62e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Support for parsing configuration strings. </p>
<p>Defines functions and helpers for parsing configuration strings into numbers, IP addresses, and other useful types.</p>
<h3>cp_va_kparse Introduction</h3>
<p>Most elements that take configuration strings parse them using the <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> function and friends. These functions take a variable argument list describing the desired arguments and result slots. They parse the configuration, store the results in the slots, report any errors, and return the number of arguments successfully assigned on success or a negative value on failure.</p>
<dl class="section note"><dt>Note</dt><dd>Previous versions of Click used <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> and friends instead of <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a>. A guide for transitioning from <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> to <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> is given in the documentation for <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a>.</dd></dl>
<p>Here are some <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> examples.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> MyElement::configure(<a class="code" href="class_vector.html">Vector&lt;String&gt;</a> &amp;conf, <a class="code" href="class_error_handler.html">ErrorHandler</a> *errh) {</div><div class="line">    <a class="code" href="class_string.html">String</a> data; uint32_t limit = 0; <span class="keywordtype">bool</span> stop = <span class="keyword">false</span>;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                     <span class="stringliteral">&quot;DATA&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>+<a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9">cpkM</a>, <a class="code" href="confparse_8hh.html#a7b070881b58db387ca6b8de0ee019be4">cpString</a>, &amp;data,</div><div class="line">                     <span class="stringliteral">&quot;LIMIT&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>, <a class="code" href="confparse_8hh.html#a02c3a4f21b5a8c8015edce2e7bc359ab">cpUnsigned</a>, &amp;limit,</div><div class="line">                     <span class="stringliteral">&quot;STOP&quot;</span>, 0, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, &amp;stop,</div><div class="line">                     <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) &lt; 0)   <span class="comment">// argument list always terminated by cpEnd</span></div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    ... }</div></div><!-- fragment --><p>This element supports three arguments, <code>DATA</code> (a string), <code>LIMIT</code> (an unsigned integer), and <code>STOP</code> (a boolean). Here are some example element definitions:</p>
<div class="fragment"><div class="line">MyElement(DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>, LIMIT 10);</div><div class="line">            <span class="comment">/* OK, sets data = &quot;blah blah blah&quot;, limit = 10; leaves stop unchanged */</span></div><div class="line">MyElement(LIMIT 10, DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>);</div><div class="line">            <span class="comment">/* OK, has the same effect */</span></div><div class="line">MyElement(LIMIT 10);</div><div class="line">            <span class="comment">/* error &quot;missing mandatory DATA argument&quot; */</span></div><div class="line">            <span class="comment">/* (the cpkM flag marks an argument as mandatory) */</span></div><div class="line">MyElement(DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>);</div><div class="line">            <span class="comment">/* OK, sets data = &quot;blah blah blah&quot; and leaves limit unchanged */</span></div><div class="line">            <span class="comment">/* (LIMIT lacks the cpkM flag, so it can be left off) */</span></div><div class="line">MyElement(DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>, STOP <span class="keyword">true</span>);</div><div class="line">            <span class="comment">/* OK, sets data = &quot;blah blah blah&quot; and stop = true */</span></div><div class="line">            <span class="comment">/* (LIMIT lacks the cpkM flag, so it can be left off) */</span></div><div class="line">MyElement(DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>, LIMIT 10, DATA <span class="stringliteral">&quot;blah&quot;</span>);</div><div class="line">            <span class="comment">/* OK, sets data = &quot;blah&quot; (later arguments take precedence) */</span></div><div class="line">MyElement(DATA <span class="stringliteral">&quot;blah blah blah&quot;</span>, LIMIT 10, BOGUS <span class="stringliteral">&quot;bogus&quot;</span>);</div><div class="line">            <span class="comment">/* error &quot;too many arguments&quot; */</span></div><div class="line">MyElement(<span class="stringliteral">&quot;blah blah blah&quot;</span>, 10);</div><div class="line">            <span class="comment">/* OK, same as MyElement(DATA &quot;blah blah blah&quot;, LIMIT 10) */</span></div><div class="line">            <span class="comment">/* (the cpkP flag allows positional arguments) */</span></div><div class="line">MyElement(<span class="stringliteral">&quot;blah blah blah&quot;</span>, 10, <span class="keyword">true</span>);</div><div class="line">            <span class="comment">/* error &quot;too many arguments&quot; */</span></div><div class="line">            <span class="comment">/* (STOP lacks the cpkP flag and must be given by name) */</span></div></div><!-- fragment --><h3>cp_va_kparse Items</h3>
<p>An item in a <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> argument list consists of:</p>
<ol>
<li>
<b>Argument name</b> (type: const char *). Example: <code>"DATA"</code>. </li>
<li>
<b>Parse flags</b> (type: int). Zero or more of <a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d" title="Argument may be specified positionally. ">cpkP</a>, <a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9" title="Argument is mandatory. ">cpkM</a>, and <a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67" title="Argument presence should be confirmed. ">cpkC</a>. </li>
<li>
If the parse flags contain <a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67" title="Argument presence should be confirmed. ">cpkC</a>, then a <b>confirmation flag</b> comes next (type: bool *). This flag is set to true if an argument successfully matched the item and false if not. </li>
<li>
<b>Argument type</b> (type: <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a>). Defines the type of argument read from the configuration string. Example: <a class="el" href="confparse_8hh.html#a7b070881b58db387ca6b8de0ee019be4" title="Result storage String*, parsed by cp_string(). ">cpString</a>. </li>
<li>
Optional <b>parse parameters</b> (determined by the argument type). For example, <a class="el" href="confparse_8hh.html#a6359a0cdf3daf568fa6e1399ac88afa9" title="Parse parameter int frac_bits, result storage uint32_t*, parsed by cp_real2(). ">cpUnsignedReal2</a> takes a parse parameter that defines how many bits of fraction are needed. </li>
<li>
<b>Result storage</b> (determined by the argument type). </li>
</ol>
<p>This example uses more of these features.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> MyElement2::configure(<a class="code" href="class_vector.html">Vector&lt;String&gt;</a> &amp;conf, <a class="code" href="class_error_handler.html">ErrorHandler</a> *errh) {</div><div class="line">    <span class="keywordtype">bool</span> p_given; uint32_t p = 0x10000; <a class="code" href="class_i_p_address.html">IPAddress</a> addr, mask;</div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                     <span class="stringliteral">&quot;P&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67">cpkC</a>, &amp;p_given, <a class="code" href="confparse_8hh.html#a6359a0cdf3daf568fa6e1399ac88afa9">cpUnsignedReal2</a>, 16, &amp;p,</div><div class="line">                     <span class="stringliteral">&quot;NETWORK&quot;</span>, 0, <a class="code" href="confparse_8hh.html#a234dd84d3576cb40a2cee3a4e1ddd00d">cpIPPrefix</a>, &amp;addr, &amp;mask,</div><div class="line">                     <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) &lt; 0)</div><div class="line">        <span class="keywordflow">return</span> -1;</div><div class="line">    ... }</div></div><!-- fragment --><p>This element supports two arguments, <code>P</code> (a fixed-point number with 16 bits of fraction) and <code>NETWORK</code> (an IP prefix, defined by address and mask). Here are some example element definitions:</p>
<div class="fragment"><div class="line">MyElement2();</div><div class="line">            <span class="comment">/* OK, since neither argument is mandatory; sets p_given = false */</span></div><div class="line">MyElement2(P 0.5, PREFIX 10/8);</div><div class="line">            <span class="comment">/* OK, sets p_given = true, p = 0x8000, addr = 10.0.0.0, and mask = 255.0.0.0 */</span></div></div><!-- fragment --><h3>cp_va_kparse Argument Types</h3>
<p><a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> argument types are defined by <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> constants. For example, the <a class="el" href="confparse_8hh.html#af668236f4b4a15caf6f2508cd25bfc87" title="Result storage int32_t*, parsed by cp_integer(). ">cpInteger</a> argument type parses a 32-bit signed integer. See <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> for more. Elements may also define their own argument types with cp_register_argtype().</p>
<h3>Direct Parsing Functions</h3>
<p>You may also call parsing functions directly if <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> doesn't match your needs. These functions have names like <a class="el" href="confparse_8hh.html#a7e741359e6048d9847df83ba3b790c71" title="Parse a boolean from str. ">cp_bool()</a>, <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>, <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>, <a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada" title="Parse an IP address from str. ">cp_ip_address()</a>, and so forth, and share a basic interface:</p>
<ul>
<li>The first argument, const <a class="el" href="class_string.html" title="A string of characters. ">String</a> &amp;<em>str</em>, contains the string to be parsed. </li>
<li>The last argument(s) specify locations where the parsed results should be stored. These <em>result</em> arguments have pointer type. </li>
<li>The return type is bool. True is returned if and only if parsing succeeds, and the <em>result</em> slots are modified if and only if parsing succeeds. </li>
<li>Most parsing functions expect to parse the entire supplied string. Any extraneous characters, such as trailing whitespace, cause parsing to fail. </li>
<li>Most parsing functions never report errors to any source; they simply return false when parsing fails.</li>
</ul>
<h3>Argument Manipulation</h3>
<p>Finally, functions like <a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864" title="Simplify str&#39;s whitespace and replace comments by spaces, returning the result. ">cp_uncomment()</a>, <a class="el" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361" title="Remove one level of quoting from str, returning the result. ">cp_unquote()</a>, <a class="el" href="confparse_8hh.html#abe4c743d2be681a21e0426edf81661a9" title="Return a quoted version of str. ">cp_quote()</a>, <a class="el" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046" title="Separate a configuration string into arguments at commas. ">cp_argvec()</a>, and <a class="el" href="confparse_8hh.html#a13c0e5ca68e156d338965fba214d414b" title="Test if str is all spaces. ">cp_is_space()</a> manipulate arguments as strings. <a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864" title="Simplify str&#39;s whitespace and replace comments by spaces, returning the result. ">cp_uncomment()</a> removes comments and simplifies white space; <a class="el" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361" title="Remove one level of quoting from str, returning the result. ">cp_unquote()</a> removes quotation marks and expands backslash escapes; <a class="el" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046" title="Separate a configuration string into arguments at commas. ">cp_argvec()</a> splits a configuration string at commas; and so forth. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="aac2cc0db6bee483e94e998211609d876"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac2cc0db6bee483e94e998211609d876">&#9670;&nbsp;</a></span>CpVaParseCmd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef const char* <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of argument type names for <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> items. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a63ecb5b3b015b237f2f78b05595f07f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ecb5b3b015b237f2f78b05595f07f2">&#9670;&nbsp;</a></span>CpKparseFlags</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2">CpKparseFlags</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of flags for <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> items. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f"></a>cpkN&#160;</td><td class="fielddoc"><p>Default flags. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9"></a>cpkM&#160;</td><td class="fielddoc"><p>Argument is mandatory. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d"></a>cpkP&#160;</td><td class="fielddoc"><p>Argument may be specified positionally. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67"></a>cpkC&#160;</td><td class="fielddoc"><p>Argument presence should be confirmed. </p>
</td></tr>
<tr><td class="fieldname"><a id="a63ecb5b3b015b237f2f78b05595f07f2a7986189d1880a2ea7e04c5b80cf29400"></a>cpkD&#160;</td><td class="fielddoc"><p>Argument is deprecated. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aee90c69236e8a1e19d14aec3d4bfa652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee90c69236e8a1e19d14aec3d4bfa652">&#9670;&nbsp;</a></span>cp_skip_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cp_skip_space </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first nonspace character in the string [<em>begin</em>, <em>end</em>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first non-space character in [<em>begin</em>, <em>end</em>), or <em>end</em> if the string is all spaces.</dd></dl>
<p>Space characters are defined as by isspace() in the "C" locale, and consist of the characters in <code>[ \f\n\r\t\v]</code>. </p>

</div>
</div>
<a id="afb4518b86b1aa517d9d753b185aae6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb4518b86b1aa517d9d753b185aae6c7">&#9670;&nbsp;</a></span>cp_skip_comment_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cp_skip_comment_space </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the first nonspace, noncomment character in the string [<em>begin</em>, <em>end</em>). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first nonspace and noncomment character in [<em>begin</em>, <em>end</em>), or <em>end</em> if the string is all spaces and comments.</dd></dl>
<p>This function recognizes C-style and C++-style comments: </p><div class="fragment"><div class="line"><span class="comment">/* C style */</span>  <span class="comment">// C++ style (runs until newline)</span></div></div><!-- fragment --><p> In C++-style comments, the character sequences <code>"\n"</code>, <code>"\r"</code>, and <code>"\r\n"</code> are recognized as newlines. The newline is considered part of the comment. </p>

</div>
</div>
<a id="a07ab3eec45f2d5a76091ffc17101f488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ab3eec45f2d5a76091ffc17101f488">&#9670;&nbsp;</a></span>cp_skip_double_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cp_skip_double_quote </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the first character after a double-quoted string starting at <em>begin</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of double-quoted string </td></tr>
    <tr><td class="paramname">end</td><td>one past end of string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to first character in [<em>begin</em>, <em>end</em>) after the double-quoted string, or <em>end</em> if the double-quoted portion is not correctly terminated. </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>begin</em> &lt; <em>end</em> and *<em>begin</em> == '"'</dd></dl>
<p><a class="el" href="confparse_8hh.html#a07ab3eec45f2d5a76091ffc17101f488" title="Return the first character after a double-quoted string starting at begin. ">cp_skip_double_quote()</a> understands all the backslash escapes processed by <a class="el" href="confparse_8hh.html#aa496b97b69db307c6d5560d86373f03d" title="Process a backslash escape, appending results to sa. ">cp_process_backslash()</a>. </p>

</div>
</div>
<a id="ab7ce0e06da5e9e65ac43a4010b82b108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7ce0e06da5e9e65ac43a4010b82b108">&#9670;&nbsp;</a></span>cp_eat_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_eat_space </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove spaces from the beginning of <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the resulting string is nonempty, false otherwise. </dd></dl>

</div>
</div>
<a id="a13c0e5ca68e156d338965fba214d414b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0e5ca68e156d338965fba214d414b">&#9670;&nbsp;</a></span>cp_is_space()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_is_space </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Test if <em>str</em> is all spaces. </p>
<dl class="section return"><dt>Returns</dt><dd>True when every character in <em>str</em> is a space. </dd></dl>

</div>
</div>
<a id="aca030c34ab8521cd4aaf8d80b200f1ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca030c34ab8521cd4aaf8d80b200f1ad">&#9670;&nbsp;</a></span>cp_is_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_is_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test whether <em>str</em> is a valid "word". </p>
<p>A "word" in Click consists of one or more characters in the ASCII range '!' through '~', inclusive, except for the quote characters '"' and ''', the backslash '\', and the comma ','. </p>

</div>
</div>
<a id="aa09070636c380d2bb398941963f2ca67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09070636c380d2bb398941963f2ca67">&#9670;&nbsp;</a></span>cp_is_click_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_is_click_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Test if <em>str</em> is a valid Click identifier. </p>
<p>A Click identifier consists of one or more characters in the set <code>[A-Za-z0-9/_@]</code>, with restrictions on where <code>/</code> may appear (it cannot be the first character or the last character, and two adjacent slashes aren't allowed either). </p>

</div>
</div>
<a id="aa01b2aaaf628883af929264473ee8864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa01b2aaaf628883af929264473ee8864">&#9670;&nbsp;</a></span>cp_uncomment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_uncomment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simplify <em>str's</em> whitespace and replace comments by spaces, returning the result. </p>
<dl class="section return"><dt>Returns</dt><dd>A version of <em>str</em> with all initial space removed, all final space removed, and all comments and space-comment sequences replaced by a single space character.</dd></dl>
<p>Adjacent space characters are preserved in the output <em>unless</em> they appear next to a comment. For example: </p><div class="fragment"><div class="line"><a class="code" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864">cp_uncomment</a>(<span class="stringliteral">&quot;  a   b  &quot;</span>) == <span class="stringliteral">&quot;a   b&quot;</span>, but:</div><div class="line"><a class="code" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864">cp_uncomment</a>(<span class="stringliteral">&quot;  a /* Comment */       b  &quot;</span>) == <span class="stringliteral">&quot;a b&quot;</span></div></div><!-- fragment --><p> Comment characters inside double or single quotes are ignored: </p><div class="fragment"><div class="line"><a class="code" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864">cp_uncomment</a>(<span class="stringliteral">&quot;  \&quot; /*???  */ \&quot;  &quot;</span>) == <span class="stringliteral">&quot;\&quot; /*???  */ \&quot;&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a69a096d2b80a263f7e6b15e0b8c45361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a096d2b80a263f7e6b15e0b8c45361">&#9670;&nbsp;</a></span>cp_unquote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_unquote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove one level of quoting from <em>str</em>, returning the result. </p>
<p>This function acts as cp_uncomment, plus removing one level of quoting. <code>"..."</code> and <code>'...'</code> sequences are replaced by their contents. Backslash escapes are expanded inside double quotes (see cp_process_backslash). Additionally, <code>"\&lt;...&gt;"</code> sequences are expanded outside of any quotes. For example: </p><div class="fragment"><div class="line"><a class="code" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361">cp_unquote</a>(<span class="stringliteral">&quot;\&quot;\\n\&quot; abc /* 123 */ &#39;/* def */&#39;&quot;</span>) == <span class="stringliteral">&quot;\n abc /* def */&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aa496b97b69db307c6d5560d86373f03d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa496b97b69db307c6d5560d86373f03d">&#9670;&nbsp;</a></span>cp_process_backslash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* cp_process_backslash </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string_accum.html">StringAccum</a> &amp;&#160;</td>
          <td class="paramname"><em>sa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process a backslash escape, appending results to <em>sa</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>beginning of string </td></tr>
    <tr><td class="paramname">end</td><td>end of string </td></tr>
    <tr><td class="paramname">sa</td><td>string accumulator </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><em>begin</em> &lt; <em>end</em>, and <em>begin</em> points to a backslash character. </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the first character in [<em>begin</em>, <em>end</em>) following the backslash escape.</dd></dl>
<p>This function understands the following backslash escapes. </p><ul>
<li>
<code>"\[newline]"</code> is ignored (it adds no characters to <em>sa</em>), where <code>[newline]</code> is one of the sequences <code>"\n"</code>, <code>"\r"</code>, or <code>"\r\n"</code>. </li>
<li>
<code>"\[C escape]"</code> is processed as in C, where <code>[C escape]</code> is one of the characters in <code>[abfnrtv]</code>. </li>
<li>
<code>"\\"</code> expands to a single backslash. Similarly, <code>"\$"</code>, <code>"\'"</code>, <code>"\\""&lt;/tt&gt;, and &lt;tt&gt;"\,"</code> expand to the escaped character. </li>
<li>
<code>"\[1-3 octal digits]"</code> expands to the given character. </li>
<li>
<code>"\x[hex digits]"</code> expands to the given character. </li>
<li>
<code>"\&lt;[hex digits, spaces, and comments]&gt;"</code> expands to the binary string indicated by the <code>hex digits</code>. Spaces and comments are removed. For example, <div class="fragment"><div class="line"><span class="stringliteral">&quot;&lt;48656c6C 6f 2 /* And finally */ 1&gt;&quot;</span> expands to <span class="stringliteral">&quot;Hello!&quot;</span></div></div><!-- fragment --> (This example should begin with <code>"\&lt;"</code>; it may not because of Doxygen problems.) </li>
<li>
A backslash at the end of the string expands to a backslash. </li>
</ul>

</div>
</div>
<a id="abe4c743d2be681a21e0426edf81661a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4c743d2be681a21e0426edf81661a9">&#9670;&nbsp;</a></span>cp_quote()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_quote </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_newlines</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a quoted version of <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramname">allow_newlines</td><td>If true, then newline sequences are allowed in in the result. If false, then newline sequences should be translated to their backslash escape equivalents. Default is false.</td></tr>
  </table>
  </dd>
</dl>
<p>Returns a double-quoted string that, when unquoted by <a class="el" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361" title="Remove one level of quoting from str, returning the result. ">cp_unquote()</a>, will equal <em>str</em>. The returned string consists of a single double-quoted string, and in particular is never empty.</p>
<dl class="section invariant"><dt>Invariant</dt><dd>cp_quote(<em>str</em>) != "" &amp;&amp; cp_unquote(cp_quote(<em>str</em>)) == <em>str</em> </dd></dl>

</div>
</div>
<a id="ad6a644f412600eb0781773488c6a0046"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a644f412600eb0781773488c6a0046">&#9670;&nbsp;</a></span>cp_argvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cp_argvec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separate a configuration string into arguments at commas. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>configuration string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">conf</td><td>arguments</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration string is broken into arguments at unquoted commas. Each argument is passed through <a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864" title="Simplify str&#39;s whitespace and replace comments by spaces, returning the result. ">cp_uncomment()</a>, then appended to <em>conf</em>. If the final argument is empty, it is ignored. For example: </p><div class="fragment"><div class="line"><a class="code" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046">cp_argvec</a>(<span class="stringliteral">&quot;a, b, c&quot;</span>, v)            appends  <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span></div><div class="line"><a class="code" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046">cp_argvec</a>(<span class="stringliteral">&quot;  a /*?*/ b,  c, &quot;</span>, v)  appends  <span class="stringliteral">&quot;a b&quot;</span>, <span class="stringliteral">&quot;c&quot;</span></div><div class="line"><a class="code" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046">cp_argvec</a>(<span class="stringliteral">&quot;\&quot;x, y\&quot; // ?&quot;</span>, v)      appends  <span class="stringliteral">&quot;\&quot;x, y\&quot;&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="a135a1aa1eae03fe38907ec1077394820"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a135a1aa1eae03fe38907ec1077394820">&#9670;&nbsp;</a></span>cp_unargvec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_unargvec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join the strings of <em>conf</em> with commas and return the result. </p>
<p>This function does not quote or otherwise protect the strings in <em>conf</em>. The caller should do that if necessary. </p>

</div>
</div>
<a id="a08caa501d360ef6151c272253f34fe00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08caa501d360ef6151c272253f34fe00">&#9670;&nbsp;</a></span>cp_spacevec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cp_spacevec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Separate a configuration string into arguments at unquoted spaces. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>configuration string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">conf</td><td>arguments</td></tr>
  </table>
  </dd>
</dl>
<p>The configuration string is broken into arguments at unquoted spaces. Each argument is passed through <a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864" title="Simplify str&#39;s whitespace and replace comments by spaces, returning the result. ">cp_uncomment()</a>, then appended to <em>conf</em>. If the final argument is empty, it is ignored. For example: </p><div class="fragment"><div class="line"><a class="code" href="confparse_8hh.html#a08caa501d360ef6151c272253f34fe00">cp_spacevec</a>(<span class="stringliteral">&quot;a  b, c&quot;</span>, v)            appends  <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;b,&quot;</span>, <span class="stringliteral">&quot;c&quot;</span></div><div class="line"><a class="code" href="confparse_8hh.html#a08caa501d360ef6151c272253f34fe00">cp_spacevec</a>(<span class="stringliteral">&quot;  &#39;a /*?*/ b&#39;c&quot;</span>, v)     appends  <span class="stringliteral">&quot;&#39;a /*?*/ b&#39;c&quot;</span></div></div><!-- fragment --> 
</div>
</div>
<a id="aa8a047fba4bad1a0529fc51fd783133f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8a047fba4bad1a0529fc51fd783133f">&#9670;&nbsp;</a></span>cp_shift_spacevec()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_shift_spacevec </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove and return the first space-separated argument from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">str</td><td>space-separated configuration string</td></tr>
  </table>
  </dd>
</dl>
<p>The first space-separated argument in the configuration string is removed and returned. The returned argument is passed through <a class="el" href="confparse_8hh.html#aa01b2aaaf628883af929264473ee8864" title="Simplify str&#39;s whitespace and replace comments by spaces, returning the result. ">cp_uncomment()</a>. <em>str</em> is set to the remaining portion of the string, with any preceding spaces and comments removed. If the input string is all spaces and comments, then both the returned string and <em>str</em> will be empty. </p>

</div>
</div>
<a id="aa1748d17a6d30e071abca4e569078f17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1748d17a6d30e071abca4e569078f17">&#9670;&nbsp;</a></span>cp_unspacevec() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_unspacevec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join the strings in [<em>begin</em>, <em>end</em>) with spaces and return the result. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">begin</td><td>first string in range </td></tr>
    <tr><td class="paramname">end</td><td>one past last string in range</td></tr>
  </table>
  </dd>
</dl>
<p>This function does not quote or otherwise protect the strings in [<em>begin</em>, <em>end</em>). The caller should do that if necessary. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="confparse_8hh.html#af130191df66c930be6d39c261183e031" title="Join the strings in conf with spaces and return the result. ">cp_unspacevec(const Vector&lt;String&gt; &amp;)</a> </dd></dl>

</div>
</div>
<a id="af130191df66c930be6d39c261183e031"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af130191df66c930be6d39c261183e031">&#9670;&nbsp;</a></span>cp_unspacevec() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_string.html">String</a> cp_unspacevec </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Join the strings in <em>conf</em> with spaces and return the result. </p>
<p>This function does not quote or otherwise protect the strings in <em>conf</em>. The caller should do that if necessary. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="confparse_8hh.html#aa1748d17a6d30e071abca4e569078f17" title="Join the strings in [begin, end) with spaces and return the result. ">cp_unspacevec(const String *, const String *)</a> </dd></dl>

</div>
</div>
<a id="a3853041c3eff44f9432a41163a73c2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3853041c3eff44f9432a41163a73c2bd">&#9670;&nbsp;</a></span>cp_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a string from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rest</td><td>(optional) stores unparsed portion of <em>str</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a string from <em>str</em>. The first unquoted space encountered ends the string, but spaces are allowed within single or double quotes. Unquoted empty strings are not accepted. If the string fully parses, then the result is unquoted by <a class="el" href="confparse_8hh.html#a69a096d2b80a263f7e6b15e0b8c45361" title="Remove one level of quoting from str, returning the result. ">cp_unquote()</a> and stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>If <em>rest</em> is nonnull, then the string doesn't need to fully parse; the part of the string starting with the first unquoted space is stored in *<em>rest</em> and the function returns true. </p>

</div>
</div>
<a id="aae21647d30503b2b4e2bb04fd8842922"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae21647d30503b2b4e2bb04fd8842922">&#9670;&nbsp;</a></span>cp_word()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_word </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a word from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rest</td><td>(optional) stores unparsed portion of <em>str</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a word from <em>str</em>. The first unquoted space encountered ends the word. Single and double quotes are removed as by cp_unquote, but the unquoted string must satisfy cp_is_word. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>If <em>rest</em> is nonnull, then the string doesn't need to fully parse; the part of the string starting with the first unquoted space is stored in *<em>rest</em> and the function returns true (assuming cp_is_word succeeds on the initial portion). </p>

</div>
</div>
<a id="a17450dcd527f644e36009aefb1e1bd36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17450dcd527f644e36009aefb1e1bd36">&#9670;&nbsp;</a></span>cp_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_keyword </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>rest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a keyword from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">rest</td><td>(optional) stores unparsed portion of <em>str</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a keyword from <em>str</em>. Keywords consist of characters in <code>[A-Za-z0-9_.:?!]</code>. Quotes and spaces are not allowed; neither is the empty string. If the string fully parses as a keyword, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>If <em>rest</em> is nonnull, then the string doesn't need to fully parse; the part of the string starting with the first unquoted space is stored in *<em>rest</em> and the function returns true (assuming the initial portion is a valid keyword). </p>

</div>
</div>
<a id="a7e741359e6048d9847df83ba3b790c71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e741359e6048d9847df83ba3b790c71">&#9670;&nbsp;</a></span>cp_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_bool </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a boolean from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a boolean from <em>str</em>. The following strings are the valid representations for booleans:</p>
<dl>
<dt>0, false, no, f, n</dt>
<dd></dd>
<dt></dt>
<dd>Means false </dd>
<dt>1, true, yes, t, y</dt>
<dd>Means true </dd>
</dl>
<p>If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false. </p>

</div>
</div>
<a id="a73da3daad75dc0be8f51f2b8c9bd1e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73da3daad75dc0be8f51f2b8c9bd1e7c">&#9670;&nbsp;</a></span>cp_integer() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char * cp_integer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an integer from [<em>begin</em>, <em>end</em>) in base <em>base</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">begin</td><td>first character in string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">end</td><td>one past last character in string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>base of integer: 0 or 2-36 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to first unparsed character in string; equals <em>begin</em> if the string didn't start with a valid integer</dd></dl>
<p>This function parses an integer from the initial characters of a string. The resulting integer is stored in *<em>result</em>.</p>
<p>The integer format consists of an optional initial sign <code>+/-</code>, followed by one or more digits. A negative sign is only accepted if <em>result</em> has a signed type. Digits may be separated by underscores (to make numbers easier to read), but the first and last characters in the integer cannot be underscores, and two underscores can't appear in a row. Some examples:</p>
<div class="fragment"><div class="line">0</div><div class="line">0x100</div><div class="line">-1_000_023</div></div><!-- fragment --><p>Digits are numbered from 0-9, then A-Z/a-z. <em>base</em> determines which digits are legal. If <em>base</em> is 0, then a leading <code>0x</code> or <code>0X</code> may precede the digits, indicating base 16; a leading <code>0</code> indicates base 8; anything else is base 10.</p>
<p>Returns the first character that can't be parsed as part of the integer. If there is no valid integer at the beginning of the string, then returns <em>begin</em>; *<em>result</em> is unchanged.</p>
<p>This function checks for overflow. If an integer is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW. Otherwise, cp_errno is set to CPE_FORMAT (for no valid integer) or CPE_OK (if all was well).</p>
<p>Overloaded versions of this function are available for int, unsigned int, long, unsigned long, and (depending on configuration) long long and unsigned long long <em>result</em> values. </p>

</div>
</div>
<a id="a0a360e1ee2c3eec2362116c3f03d3009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a360e1ee2c3eec2362116c3f03d3009">&#9670;&nbsp;</a></span>cp_integer() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an integer from <em>str</em> in base <em>base</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">base</td><td>base of integer: 0 or 2-36 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an integer from an input string. If the string correctly parses as an integer, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>Overloaded versions are available for int, unsigned int, long, unsigned long, and (depending on configuration) long long and unsigned long long <em>result</em> values.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer(const char *, const char *, int, int *)</a> for the rules on parsing integers. </dd></dl>

</div>
</div>
<a id="ac3843f1f73bb1a50bb1cddc9ce9e0aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3843f1f73bb1a50bb1cddc9ce9e0aca">&#9670;&nbsp;</a></span>cp_integer() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_integer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse an integer from <em>str</em> in base 0. </p>
<p>Same as cp_integer(str, 0, result). </p>

</div>
</div>
<a id="a62fe9aa2b03be0c2c99070cb64240d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62fe9aa2b03be0c2c99070cb64240d84">&#9670;&nbsp;</a></span>cp_real2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_real2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frac_bits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a fixed-point number from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">frac_bits</td><td>number of bits of fraction, 0-CP_REAL2_MAX_FRAC_BITS </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a real number from an input string. The result is represented as a fixed-point number with <em>frac_bits</em> bits of fraction. For example, the number 0.5 would be represented as 0x1 if <em>frac_bits</em> == 1, or 0x8000 if <em>frac_bits</em> == 16. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>The real number format is the familiar decimal format parsed by, for example, C's strtod() function. It consists of, in order:</p>
<ul>
<li>An optional <code>+</code> or <code>-</code> sign. </li>
<li>An optional sequence of decimal digits representing the integer part. </li>
<li>An optional fraction point, followed by an optional sequence of decimal digits representing the fraction part. </li>
<li>An optional exponent (either <code>E&lt;digits&gt;</code>, <code>E+&lt;digits&gt;</code>, or <code>E-&lt;digits&gt;</code>).</li>
</ul>
<p>There must be at least one digit in either the integer part or the fraction part. As with cp_integer, digits can be separated by underscores to make large numbers easier to read. Some examples:</p>
<div class="fragment"><div class="line">0</div><div class="line">-100_000_000</div><div class="line">1e8</div><div class="line">+10.</div><div class="line">.1</div><div class="line">0.000_000_01e10</div></div><!-- fragment --><p>This function checks for overflow. If a number is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW. Otherwise, cp_errno is set to CPE_FORMAT (unparsable input) or CPE_OK (if all was well). Underflow is handled by rounding the result to the nearest representable number.</p>
<p>The following invariant always holds for all values <em>x</em> and fraction bits <em>frac_bits:</em> </p><div class="fragment"><div class="line">check_invariant(int32_t x, <span class="keywordtype">int</span> frac_bits) {</div><div class="line">    int32_t y;</div><div class="line">    assert(<a class="code" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84">cp_real2</a>(cp_unparse_real2(x, frac_bits), frac_bits, &amp;y) == <span class="keyword">true</span></div><div class="line">           &amp;&amp; y == x);</div><div class="line">}</div></div><!-- fragment --><p>An overloaded version of this function is available for uint32_t <em>result</em> values; it doesn't accept negative numbers.</p>
<dl class="section see"><dt>See also</dt><dd>The <a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e" title="Parse a real number from str, representing the result as an integer with frac_digits decimal digits o...">cp_real10()</a> functions behave like <a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84" title="Parse a fixed-point number from str. ">cp_real2()</a>, but the fractional part is expressed in decimal digits rather than bits. </dd></dl>

</div>
</div>
<a id="a387daecd4382457c3d2b8be88e60d02e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387daecd4382457c3d2b8be88e60d02e">&#9670;&nbsp;</a></span>cp_real10() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_real10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frac_digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a real number from <em>str</em>, representing the result as an integer with <em>frac_digits</em> decimal digits of fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">frac_digits</td><td>number of decimal digits of fraction, 0-9 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a real number from an input string. The result is represented as an integer with <em>frac_digits</em> decimal digits of fraction. For example, the number 0.5 would be represented as 5 if <em>frac_digits</em> == 1, or 5000 if <em>frac_digits</em> == 4. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>The real number format and error conditions are the same as for <a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84" title="Parse a fixed-point number from str. ">cp_real2()</a>.</p>
<p>An overloaded version of this function is available for uint32_t <em>result</em> values; it doesn't accept negative numbers. </p>

</div>
</div>
<a id="a47d562ad0cb6795313235ff84bad440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47d562ad0cb6795313235ff84bad440d">&#9670;&nbsp;</a></span>cp_real10() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_real10 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frac_digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result_int_part</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result_frac_part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a real number from <em>str</em>, representing the result as an integer with <em>frac_digits</em> decimal digits of fraction. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">frac_digits</td><td>number of decimal digits of fraction, 0-9 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_int_part</td><td>stores integer portion of parsed result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_frac_part</td><td>stores fractional portion of parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an unsigned real number from an input string. The result is represented with <em>frac_digits</em> decimal digits of fraction. The integer and fraction parts of the result are stored in two separate integers, <em>result_int_part</em> and <em>result_frac_part</em>. For example, the number 10.5 would be represented as 10 and 5 if <em>frac_digits</em> == 1, or 10 and 5000 if <em>frac_digits</em> == 4. If the string fully parses, then the resulting value is stored in the result variables and the function returns true. Otherwise, the result variables remains unchanged and the function returns false.</p>
<p>The real number format and error conditions are the same as for <a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84" title="Parse a fixed-point number from str. ">cp_real2()</a>. (Negative numbers are not allowed.) </p>

</div>
</div>
<a id="a03e3d6bb41be9959f40a37f217d9bc2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e3d6bb41be9959f40a37f217d9bc2a">&#9670;&nbsp;</a></span>cp_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_double </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a real number from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a real number from an input string in double format. It is basically equivalent to C's strtod(), but follows Click's configuration parsing conventions: If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false. If a number is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW; otherwise, cp_errno is set to CPE_FORMAT (unparsable) or CPE_OK (if all was well).</p>
<p>This function is not available in the kernel, since double objects cannot be used there. </p>

</div>
</div>
<a id="a45f4dd1ae1146aad253b6ecf69000f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f4dd1ae1146aad253b6ecf69000f6c">&#9670;&nbsp;</a></span>cp_seconds_as()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_seconds_as </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>frac_digits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an amount of time from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">frac_digits</td><td>number of decimal digits of fraction, 0-9 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an amount of time, measured in seconds, from <em>str</em>. <em>frac_digits</em> is the number of decimal digits of fraction returned in the result. For example, to measure the result in milliseconds, set <em>frac_digits</em> == 3; for microseconds, set <em>frac_digits</em> == 6. Does not handle negative amounts of time.</p>
<p>The input string is a real number (as in cp_real2) followed by an optional unit suffix. Units are:</p>
<dl>
<dt>ns, nsec</dt>
<dd>nanoseconds </dd>
<dt>us, usec</dt>
<dd>microseconds </dd>
<dt>ms, msec</dt>
<dd>milliseconds </dd>
<dt>s, sec</dt>
<dd>seconds </dd>
<dt>m, min</dt>
<dd>minutes </dd>
<dt>h, hr</dt>
<dd>hours </dd>
<dt>d, day</dt>
<dd>days </dd>
</dl>
<p>The default unit suffix is seconds. Thus, "3600", "3600s", "3.6e6 msec", "60m", and "1 hr" all parse to the same result, 3600 seconds.</p>
<p>If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>If a number is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW; otherwise, cp_errno is set to CPE_FORMAT (unparsable) or CPE_OK (if all was well). </p>

</div>
</div>
<a id="afa241b9899bd1118769cbff9ce75c18f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa241b9899bd1118769cbff9ce75c18f">&#9670;&nbsp;</a></span>cp_seconds_as_milli()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_seconds_as_milli </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an amount of time in milliseconds from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an amount of time, measured in milliseconds, from <em>str</em>. Equivalent to cp_seconds_as(<em>str</em>, 3, <em>result</em>). </p>

</div>
</div>
<a id="a1502cc5e990c25518f8c16536493136f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1502cc5e990c25518f8c16536493136f">&#9670;&nbsp;</a></span>cp_seconds_as_micro()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_seconds_as_micro </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an amount of time in microseconds from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an amount of time, measured in microseconds, from <em>str</em>. Equivalent to cp_seconds_as(<em>str</em>, 6, <em>result</em>). </p>

</div>
</div>
<a id="acfcd439b6d13c97798bbc0c95668a37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfcd439b6d13c97798bbc0c95668a37e">&#9670;&nbsp;</a></span>cp_seconds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_seconds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an amount of time from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an amount of time, measured in seconds, from <em>str</em>. As in <a class="el" href="confparse_8hh.html#a45f4dd1ae1146aad253b6ecf69000f6c" title="Parse an amount of time from str. ">cp_seconds_as()</a>, the input string is a real number followed by an optional unit suffix which defaults to seconds.</p>
<p>If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false. </p>

</div>
</div>
<a id="a048b32c8601bb347886d5f3ea749221f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a048b32c8601bb347886d5f3ea749221f">&#9670;&nbsp;</a></span>cp_time()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_time </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_timestamp.html">Timestamp</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a timestamp from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_negative</td><td>allow negative timestamps if true </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a timestamp from <em>str</em>. Timestamps are expressed as fractional amounts of seconds, usually measured in Unix time, such as <code>"1189383079.180265331"</code>. The input format accepts the unit suffixes described at cp_seconds_as. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>If a number is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW; otherwise, cp_errno is set to CPE_FORMAT (unparsable) or CPE_OK (if all was well).</p>
<p>An overloaded version of this function is available for struct timeval <em>result</em> values. </p>

</div>
</div>
<a id="ae0abab0a34c041846472bf3e6ffae4be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0abab0a34c041846472bf3e6ffae4be">&#9670;&nbsp;</a></span>cp_bandwidth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_bandwidth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a bandwidth value from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a bandwidth value from <em>str</em>. The input format is a real number followed by an optional unit suffix. Units are:</p>
<dl>
<dt>baud, bps, b/s</dt>
<dd>bits per second </dd>
<dt>Bps, B/s</dt>
<dd>bytes per second </dd>
<dt>e.g. kbaud, Mbps, GBps</dt>
<dd>kilo, mega, giga are supported (they mean 10^3, 10^6, and 10^9) </dd>
</dl>
<p>The default unit suffix is bytes per second.</p>
<p>If a number is too large for <em>result</em>, then the maximum possible value is stored in <em>result</em> and the cp_errno variable is set to CPE_OVERFLOW; otherwise, cp_errno is set to CPE_FORMAT (unparsable) or CPE_OK (if all was well). </p>

</div>
</div>
<a id="aa8914824f1b08c1b6ff63f10b3583ada"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8914824f1b08c1b6ff63f10b3583ada">&#9670;&nbsp;</a></span>cp_ip_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ip_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IP address from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for <em>AddressInfo</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an IP address from <em>str</em>. The input format is the usual dotted-quad format, as in <code>"18.26.4.9"</code>, where each number is a decimal number from 0-255. The <em>AddressInfo</em> element can be used to register shorthand names for other IP addresses. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>Overloaded versions of this function are available for unsigned char[4] and struct in_addr * result types. </p>

</div>
</div>
<a id="ac6b2a34a902c5b2855e016120c284b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b2a34a902c5b2855e016120c284b93">&#9670;&nbsp;</a></span>cp_ip_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ip_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a> *&#160;</td>
          <td class="paramname"><em>result_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_i_p_address.html">IPAddress</a> *&#160;</td>
          <td class="paramname"><em>result_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_bare_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IP address or prefix from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_addr</td><td>stores parsed address result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_mask</td><td>stores parsed address mask result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_bare_address</td><td>optional: if true, allow raw IP addresses; defaults to false </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for <em>AddressInfo</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an IP prefix description from <em>str</em>. The input format is the usual CIDR format with some additions. Allowed examples:</p>
<ul>
<li>
<code>"18.26.4.0/24"</code>: the default CIDR format. The prefix length, here 24, is a number between 0 and 32. This stores the equivalents of 18.26.4.0 in *<em>result_addr</em> and 255.255.255.0 in *<em>result_mask</em>. </li>
<li>
<code>"18.26.4/24"</code>: it is OK to leave off irrelevant parts of the address. However, <code>"18.26/24"</code> will not parse. </li>
<li>
<code>"18.26.4.0/255.255.255.0"</code>: the mask may be specified directly. This is the only way to define a non-prefix mask. </li>
<li>
Additionally, <em>AddressInfo</em> names may be used to specify the address part or the whole prefix: given AddressInfo(a 18.26.4.9), <code>"a/24"</code> is parseable as an IP prefix. </li>
</ul>
<p>The address part need not fit entirely within the prefix. <code>"18.26.4.9/24"</code> will parse into address 18.26.4.9 and mask 255.255.255.0.</p>
<p>If <em>allow_bare_address</em> is true, then a raw IP address is also acceptable input. The resulting mask will equal 255.255.255.255. Raw IP addresses take precedence over networks, so given AddressInfo(a 18.26.4.9/24), "a" will parse as 18.26.4.9/32, not 18.26.4/24. <em>allow_bare_address</em> defaults to false.</p>
<p>If the string fully parses, then the resulting address is stored in *<em>result_addr</em>, the resulting mask is stored in *<em>result_mask</em>, and the function returns true. Otherwise, the results remain unchanged and the function returns false.</p>
<p>Overloaded versions of this function are available for unsigned char[4] result types. </p>

</div>
</div>
<a id="a851d8db616ba1745bcdbac8bdd5574cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851d8db616ba1745bcdbac8bdd5574cf">&#9670;&nbsp;</a></span>cp_ip_address_list()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ip_address_list </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_i_p_address.html">IPAddress</a> &gt; *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a space-separated list of IP addresses from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for <em>AddressInfo</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a space-separated list of IP addresses from <em>str</em>. Each individual IP address is parsed as by <a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada" title="Parse an IP address from str. ">cp_ip_address()</a>. If the string fully parses, then *<em>result</em> is set to the resulting values in order. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>In addition to errors from <a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada" title="Parse an IP address from str. ">cp_ip_address()</a>, this function might run out of memory for *<em>result</em>, which produces a CPE_MEMORY error. </p>

</div>
</div>
<a id="a497851064c585d0fa473a30bf73998af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a497851064c585d0fa473a30bf73998af">&#9670;&nbsp;</a></span>cp_ip6_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ip6_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6Address *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IPv6 address from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for <em>AddressInfo</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an IPv6 address from <em>str</em>. The input format may be any of the forms allowed by <a href="ftp://ftp.ietf.org/rfc/rfc2373.txt">RFC2373</a>:</p>
<ul>
<li>A nonabbreviated address consists of eight colon-separated 16-bit hexadecimal numbers, as in <code>"1080:0:0:0:8:800:200C:417a"</code>.</li>
<li>Groups of zeros may be abbrivated with two colons, as in the equivalent <code>"1080::8:800:200C:417A"</code>.</li>
<li>An address may end with an embedded IPv4 address, as in <code>"::13.1.68.3"</code>, <code>"::FFFF:129.144.52.38"</code>, and (assuming the appropriate <em>AddressInfo</em> information) <code>"0::ip4_addr"</code>.</li>
</ul>
<p>The <em>AddressInfo</em> element can be used to register shorthand names for other IPv6 addresses. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>An overloaded version of this function is available for unsigned char[16] result type. </p>

</div>
</div>
<a id="afc5fd422bb8653469dcc1f655ba3e426"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc5fd422bb8653469dcc1f655ba3e426">&#9670;&nbsp;</a></span>cp_ip6_prefix()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ip6_prefix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IP6Address *&#160;</td>
          <td class="paramname"><em>result_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_bare_address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an IPv6 address or prefix from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_addr</td><td>stores parsed address result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_prefix</td><td>stores parsed prefix length result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">allow_bare_address</td><td>if true, allow raw IPv6 addresses </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for <em>AddressInfo</em> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an IPv6 prefix description from <em>str</em>. The input format is the usual CIDR format: an IPv6 address, followed by <code>"/prefixlen"</code>, where <code>prefixlen</code> is a number between 0 and 128. As an extension, the format <code>"addr/mask"</code> is supported, where both <code>addr</code> and <code>mask</code> are valid IPv6 addresses. However, unlike <a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93" title="Parse an IP address or prefix from str. ">cp_ip_prefix()</a>, <code>mask</code> must correspond to a valid prefix length &ndash; some number of one bits, followed by all zero bits. For example, "::/::1" will not parse. Finally, <em>AddressInfo</em> names may be used to specify the address part or the whole prefix.</p>
<p>The address part need not fit entirely within the prefix. <code>"::1/32"</code> will parse into address ::1 and prefix length 32.</p>
<p>If <em>allow_bare_address</em> is true, then a raw IPv6 address is also acceptable input. The resulting prefix will equal 128.</p>
<p>If the string fully parses, then the resulting address is stored in *<em>result_addr</em>, the resulting prefix length is stored in *<em>result_prefix</em>, and the function returns true. Otherwise, the results remain unchanged and the function returns false.</p>
<p>Overloaded versions of this function are available for unsigned char[16] result address type, and for IP6Address or unsigned char[16] result masks (instead of result prefix lengths). </p>

</div>
</div>
<a id="a71a07a747ecfafca77978fbace74d01d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71a07a747ecfafca77978fbace74d01d">&#9670;&nbsp;</a></span>cp_ethernet_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_ethernet_address </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_ether_address.html">EtherAddress</a> *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an Ethernet address from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for AddressInfo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an Ethernet address from <em>str</em>. The input format is the IEEE standard format, as in <code>"00-15-58-2D-FB-8F"</code>: six dash-separated 8-bit hexadecimal numbers in transmission order. Colons are also accepted as separators. The AddressInfo element can be used to register shorthand names for other Ethernet addresses. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>An overloaded version of this function is available for unsigned char[6] result type. </p>

</div>
</div>
<a id="a0b51d4b32b3318b2c02a376e5312d32d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b51d4b32b3318b2c02a376e5312d32d">&#9670;&nbsp;</a></span>cp_tcpudp_port()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_tcpudp_port </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>proto</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a TCP, UDP, etc. port number from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">proto</td><td>protocol number, e.g. IP_PROTO_TCP == 6 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>optional context for IPNameInfo </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a port number for IP protocol <em>proto</em> from <em>str</em>. The input may be a 16-bit number parsable by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>, as in <code>"80"</code>. It may also be a port name, such as <code>"www"</code>. Several port names are defined by default, including <code>auth</code>, <code>chargen</code>, <code>echo</code>, <code>finger</code>, <code>ftp</code>, <code>https</code>, <code>ntp</code>, and <code>www</code>. The <em>PortInfo</em> element can be used to define additional names, and at user level, <a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d" title="Parse a TCP, UDP, etc. port number from str. ">cp_tcpudp_port()</a> will consult the /etc/services database using getservbyname() as a last resort. If the string fully parses, then the resulting value is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false. </p>

</div>
</div>
<a id="a63a04a5a56f54f32679a5d873ac1cd2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63a04a5a56f54f32679a5d873ac1cd2d">&#9670;&nbsp;</a></span>cp_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a>* cp_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>argname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an element reference from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
    <tr><td class="paramname">argname</td><td>optional argument name (used for error messages) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> pointer, or null if no such element is found.</dd></dl>
<p>Parses an element reference from <em>str</em>. The input must be a single (possibly quoted) string acceptable to <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>. The unquoted value should be an element name. The name may be relative to a compound element; for instance, if <em>context</em> is an element named <code>a/b/c/xxx</code>, and <em>str</em> was <code>"yyy"</code>, then <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a> would search for elements named <code>a/b/c/yyy</code>, <code>a/b/yyy</code>, <code>a/yyy</code>, and finally <code>yyy</code>, returning the first one found. (See <a class="el" href="class_router.html#ad1ed4a35d56add1d092bff2d712e4103" title="Finds an element named name. ">Router::find()</a>.) If no element is found, reports an error to <em>errh</em> and returns null. If <em>errh</em> is null, no error is reported.</p>
<dl class="section see"><dt>See also</dt><dd>This function differs from <a class="el" href="class_router.html#ad1ed4a35d56add1d092bff2d712e4103" title="Finds an element named name. ">Router::find()</a> in that it unquotes its argument. </dd></dl>

</div>
</div>
<a id="a63762d61a43ad8eede021212411cac1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63762d61a43ad8eede021212411cac1d">&#9670;&nbsp;</a></span>cp_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a>* cp_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>argname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse an element reference from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramname">router</td><td>router </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
    <tr><td class="paramname">argname</td><td>optional argument name (used for error messages) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> pointer, or null if no such element is found.</dd></dl>
<p>Parses an element reference from <em>str</em>. The input must be a single (possibly quoted) string acceptable to <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>. The unquoted value should be a fully qualified element name corresponding to an element in <em>router</em>. If no element is found, reports an error to <em>errh</em> and returns null. If <em>errh</em> is null, no error is reported.</p>
<dl class="section see"><dt>See also</dt><dd>This function differs from <a class="el" href="class_router.html#ad1ed4a35d56add1d092bff2d712e4103" title="Finds an element named name. ">Router::find()</a> in that it unquotes its argument. </dd></dl>

</div>
</div>
<a id="ad412ee0e6169740f40c956a0d533848b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad412ee0e6169740f40c956a0d533848b">&#9670;&nbsp;</a></span>cp_handler_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_handler_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> **&#160;</td>
          <td class="paramname"><em>result_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>result_hname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a handler name from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_element</td><td>stores parsed element result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_hname</td><td>stores parsed handler name result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a handler name from <em>str</em>. Three formats are supported:</p>
<ul>
<li><code>"elementname.handlername"</code>, for a handler on a named element. The named element must exist; it is looked up as by <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a> in the compound element context specified by <em>context</em>.</li>
<li><code>".handlername"</code>, for a global handler on <em>context's</em> router.</li>
<li><code>"handlername"</code>, for a handler on the <em>context</em> element (if such a handler exists), or a global handler on <em>context's</em> router.</li>
</ul>
<p>The handler name must contain at least one character. Although the named element must exist, this function does not check whether the named handler exists. The input string may contain quotes; it is unquoted by <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>.</p>
<p>If the string fully parses, then the resulting element is stored in *<em>result_element</em>, the resulting handler name is stored in *<em>result_hname</em>, and the function returns true. For global handlers, *<em>result_element</em> is set to <a class="el" href="class_router.html#af48a295b245f7cde02c5c030498df8a3" title="Returns this router&#39;s root element. ">Router::root_element()</a>. If the string does not fully parse, the results remain unchanged and the function returns false. </p>

</div>
</div>
<a id="a332fd6a991c93467e3352f4b2c118a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a332fd6a991c93467e3352f4b2c118a1f">&#9670;&nbsp;</a></span>cp_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> **&#160;</td>
          <td class="paramname"><em>result_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_handler.html">Handler</a> **&#160;</td>
          <td class="paramname"><em>result_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a handler reference from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">flags</td><td>zero or more of <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55a53839db78e8b48bd46beb3d8cff3f2d3" title="Handler supports read operations. ">Handler::f_read</a>, <a class="el" href="class_handler.html#ac08417becc781346bef93d6dd440bc55affb8316da8ea607553b43f123b3d6403" title="Handler supports write operations. ">Handler::f_write</a>, and HandlerCall::f_preinitialize </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_element</td><td>stores parsed element result </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result_handler</td><td>stores parsed handler result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a handler reference from <em>str</em>. The input format is as in <a class="el" href="confparse_8hh.html#ad412ee0e6169740f40c956a0d533848b" title="Parse a handler name from str. ">cp_handler_name()</a>, but the named handler must actually exist. The <em>flags</em> argument lets the caller check for read and/or write handlers; its values are as for <a class="el" href="class_handler_call.html#ab8572653fec3b587d87177c906b99be6" title="Initialize the HandlerCall. ">HandlerCall::initialize()</a>. If the string fully parses, then the resulting element is stored in *<em>result_element</em>, the resulting handler is stored in *<em>result_handler</em>, and the function returns true. For global handlers, *<em>result_element</em> is set to <a class="el" href="class_router.html#af48a295b245f7cde02c5c030498df8a3" title="Returns this router&#39;s root element. ">Router::root_element()</a>. If the string does not fully parse, the results remain unchanged and the function returns false. </p>

</div>
</div>
<a id="a90bf06e7b3314f7e1806b0977ceac65e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf06e7b3314f7e1806b0977ceac65e">&#9670;&nbsp;</a></span>cp_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_filename </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a filename string from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a filename from <em>str</em>. This behaves like <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a> plus shell-style tilde expansion. Thus, <code>~/</code> at the beginning of a string is replaced with the value of the <code>HOME</code> environment variable (if it exists), and <code>~username/</code> is replaced with the given user's home directory as returned by getpwnam() (if the given user exists). Additionally, double slashes are replaced by single slashes. Thus, <code>"~//myfile.txt~"</code> might parse to <code>"/home/kohler/myfile.txt~"</code>. Empty strings are not accepted. If the string fully parses, then the result is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false.</p>
<p>This function is only available at user level. </p>

</div>
</div>
<a id="ac46670c43208f88fbf5839a8347f92df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac46670c43208f88fbf5839a8347f92df">&#9670;&nbsp;</a></span>cp_file_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_file_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a file offset from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses an unsigned integer from <em>str</em>, similarly to cp_integer(str, result). </p>

</div>
</div>
<a id="a74c9c7cd4046a5896351bace015bbcab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c9c7cd4046a5896351bace015bbcab">&#9670;&nbsp;</a></span>cp_anno()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool cp_anno </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a packet annotation value from <em>str</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">str</td><td>string </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">size</td><td>annotation size, or &lt;= 0 to not check size </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">result</td><td>stores parsed result </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">context</td><td>element context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if <em>str</em> parsed correctly, false otherwise.</dd></dl>
<p>Parses a packet annotation value from <em>str</em>. This is either a predefined annotation name, such as PAINT or ICMP_PARAM_PROB (all names from &lt;<a class="el" href="packet__anno_8hh_source.html">click/packet_anno.hh</a>&gt; are defined by default); a user-defined name (see the AnnotationInfo element); or an integer indicating the byte offset into the annotation area.</p>
<p>If <em>size</em> &lt;= 0, then the annotation value is returned as is. Use the #ANNOTATIONINFO_OFFSET and #ANNOTATIONINFO_SIZE macros to extract the offset and size portions. If <em>size</em> &gt; 0, then the annotation value is checked to ensure that the sizes are compatible. For instance, if <em>size</em> == 1, then the "DST_IP" annotation is rejected since it has the wrong size. In this case, the value stored in *<em>result</em> equals the annotation offset &ndash; the size is masked off.</p>
<p>Values that extend past the end of the annotation area are rejected.</p>
<p>If the string fully parses, then the result is stored in *<em>result</em> and the function returns true. Otherwise, *<em>result</em> remains unchanged and the function returns false. </p>

</div>
</div>
<a id="a9cf73ba574654eee9d96123c45fe3484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cf73ba574654eee9d96123c45fe3484">&#9670;&nbsp;</a></span>cp_va_kparse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_kparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a list of arguments. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>argument list </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter items, terminated by <a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91" title="Use as argument name. Ends cp_va argument list. ">cpEnd</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters successfully assigned, or negative on error.</dd></dl>
<p>The arguments in <em>conf</em> are parsed according to the items. Each supplied argument must match one of the items, and at least one argument must match each mandatory item. Any errors are reported to <em>errh</em>. If no error occurs, then the item results are assigned appropriately, and the function returns the number of assigned items, which might be 0. If any error occurs, then the item results are left unchanged and the function returns a negative error code.</p>
<p>The <em>context</em> argument is passed to any parsing functions that require element context. See above for more information on <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> items.</p>
<p>The item list must be terminated with cpEnd. An error message such as "warning: missing sentinel in function call" indicates that you terminated the list with 0 instead. Fix it by replacing the 0 with cpEnd. </p>

</div>
</div>
<a id="a84da63c103be27b0e23720caebb8049a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84da63c103be27b0e23720caebb8049a">&#9670;&nbsp;</a></span>cp_va_kparse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_kparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a comma-separated argument string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>comma-separated argument string </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter items, terminated by <a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91" title="Use as argument name. Ends cp_va argument list. ">cpEnd</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters successfully assigned, or negative on error.</dd></dl>
<p>The argument string is separated into an argument list by <a class="el" href="confparse_8hh.html#ad6a644f412600eb0781773488c6a0046" title="Separate a configuration string into arguments at commas. ">cp_argvec()</a>, after which the function behaves like cp_va_kparse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a>&amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...). </p>

</div>
</div>
<a id="a837ac4bbf266763b5eebb3e02a10b4da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837ac4bbf266763b5eebb3e02a10b4da">&#9670;&nbsp;</a></span>cp_va_space_kparse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_space_kparse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a space-separated argument string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>space-separated argument string </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter items, terminated by <a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91" title="Use as argument name. Ends cp_va argument list. ">cpEnd</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters successfully assigned, or negative on error.</dd></dl>
<p>The argument string is separated into an argument list by <a class="el" href="confparse_8hh.html#a08caa501d360ef6151c272253f34fe00" title="Separate a configuration string into arguments at unquoted spaces. ">cp_spacevec()</a>, after which the function behaves like cp_va_kparse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a>&amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...). </p>

</div>
</div>
<a id="a9217b8857a6309841ba3d075ef85437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9217b8857a6309841ba3d075ef85437a">&#9670;&nbsp;</a></span>cp_va_kparse_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_kparse_keyword </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a single argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>argument </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter items, terminated by <a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91" title="Use as argument name. Ends cp_va argument list. ">cpEnd</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters successfully assigned (0 or 1), or negative on error.</dd></dl>
<p>An argument list consisting of the single argument <em>str</em> is formed, after which this function behaves like cp_va_kparse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a>&amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...). </p>

</div>
</div>
<a id="a01b6a55a3d1d22bbadfaf378a301edf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01b6a55a3d1d22bbadfaf378a301edf0">&#9670;&nbsp;</a></span>cp_va_kparse_remove_keywords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_kparse_remove_keywords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse and remove matching arguments from <em>conf</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>argument list </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter items, terminated by <a class="el" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91" title="Use as argument name. Ends cp_va argument list. ">cpEnd</a> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of parameters successfully assigned, or negative on error.</dd></dl>
<p>The arguments in <em>conf</em> are parsed according to the items. At least one argument must correspond to each mandatory item, but extra arguments are not errors. If no error occurs, then the item results are assigned appropriately; any arguments that successfully matched are removed from <em>conf</em>; and the function returns the number of assigned items, which might be 0. If any error occurs, then <em>conf</em> and the item results are left unchanged and the function returns a negative error code. Errors are reported to <em>errh</em>.</p>
<p>The <em>context</em> argument is passed to any parsing functions that require element context. </p>

</div>
</div>
<a id="acda9203fe690e72bbc1688a3c740c37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acda9203fe690e72bbc1688a3c740c37e">&#9670;&nbsp;</a></span>cp_assign_arguments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_assign_arguments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>param_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> *&#160;</td>
          <td class="paramname"><em>param_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign arguments from <em>argv</em> to <em>values</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">argv</td><td>argument array </td></tr>
    <tr><td class="paramname">param_begin</td><td>start iterator for parameter list </td></tr>
    <tr><td class="paramname">param_end</td><td>end iterator for parameter list </td></tr>
    <tr><td class="paramname">values</td><td>value storage (may equal null or &amp;<em>argv</em>) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>&gt;= 0 on success, negative on failure</dd></dl>
<p>This function is used to resolve an argument array. The range [<em>param_begin</em>, <em>param_end</em>) defines the parameter names. This range begins with zero or more empty strings, which define mandatory positional arguments. It continues with zero or more nonempty strings, which define optional keyword arguments with the corresponding names. It may optionally conclude with "__REST__", which says that the last value should collect all unassigned arguments.</p>
<p>cp_assign_arguments attempts to assign the arguments in <em>argv</em> to the corresponding parameters. This succeeds if all mandatory positional arguments are present and all other arguments are accounted for, either by keywords or by "__REST__". On success, returns &gt;= 0. On failure because the argument list is invalid, returns -EINVAL. On other failure cases, such as out of memory, returns another negative error code.</p>
<p>On success, cp_assign_arguments also optionally assigns *<em>values</em> to the resulting value list. *<em>values</em> is resized to size (<em>param_end</em> - <em>param_begin</em>), and *<em>values</em>[<em>i</em>] is set to the argument corresponding to <em>param_begin</em>[<em>i</em>]. If <em>values</em> is null this step is skipped and the function has no side effects. It is safe to set <em>values</em> to &amp;<em>argv</em>. </p>

</div>
</div>
<a id="a05dd05870811fb091be88db69a5ff502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05dd05870811fb091be88db69a5ff502">&#9670;&nbsp;</a></span>cp_va_static_initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cp_va_static_initialize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> implementation. </p>
<p>This function must be called before any cp_va function is called. It is safe to call it multiple times.</p>
<dl class="section note"><dt>Note</dt><dd>Elements don't need to worry about <a class="el" href="confparse_8hh.html#a05dd05870811fb091be88db69a5ff502" title="Initialize the cp_va_kparse() implementation. ">cp_va_static_initialize()</a>; Click drivers have already called it for you. </dd></dl>

</div>
</div>
<a id="a2bb0691a7e955c32f99724829b232252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb0691a7e955c32f99724829b232252">&#9670;&nbsp;</a></span>cp_va_static_cleanup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cp_va_static_cleanup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clean up the <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> implementation. </p>
<p>Call this function to release any memory allocated by the cp_va implementation. As a side effect, this function unregisters all argument types registered by cp_register_argtype(). </p>

</div>
</div>
<a id="aea6b37319089e863e60a30543e320644"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6b37319089e863e60a30543e320644">&#9670;&nbsp;</a></span>cp_va_parse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy function for parsing a list of arguments. </p>
<p>never</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>argument list </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter descriptions, terminated by cpEnd </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000016">Deprecated:</a></b></dt><dd>Use <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> instead.</dd></dl>
<p>Older versions of Click used <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> instead of the current <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a>. This guide shows how to transition <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> calls into <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a>.</p>
<p>There are two major differences between the variants. First, <em>every</em> argument to <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> must have a keyword name, including arguments that are normally specified by position. Second, each <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> argument includes an "argument description string" used to improve error messages. <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> arguments do not take such a string; the keyword generates better, more concise messages.</p>
<p>The following examples, taken from Click elements, show how to change concrete <a class="el" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644" title="Legacy function for parsing a list of arguments. ">cp_va_parse()</a> calls into <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> calls.</p>
<div class="fragment"><div class="line"><span class="comment">// 1. Paint: Mandatory arguments are marked with cpkP+cpkM.</span></div><div class="line"><span class="comment">//    Element documentation and other analogous elements are</span></div><div class="line"><span class="comment">//    good places to look for keywords.</span></div><div class="line">... <a class="code" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                <a class="code" href="confparse_8hh.html#a802b1f261939ad1e1f602338ca6bc58c">cpByte</a>, <span class="stringliteral">&quot;color&quot;</span>, &amp;_color,    <span class="comment">// &quot;color&quot; is the description string</span></div><div class="line">                <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line">   <span class="comment">/* =&gt; */</span></div><div class="line">... <a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                 <span class="stringliteral">&quot;COLOR&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>+<a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9">cpkM</a>, <a class="code" href="confparse_8hh.html#a802b1f261939ad1e1f602338ca6bc58c">cpByte</a>, &amp;_color,</div><div class="line">                 <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line"></div><div class="line"><span class="comment">// 2. Switch: Optional arguments are marked with cpkP (no cpkM).</span></div><div class="line">... <a class="code" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                <a class="code" href="confparse_8hh.html#abb026faaf3c7dbd25a48f3e1124abf0d">cpOptional</a>,</div><div class="line">                <a class="code" href="confparse_8hh.html#af668236f4b4a15caf6f2508cd25bfc87">cpInteger</a>, <span class="stringliteral">&quot;active output&quot;</span>, &amp;_output,</div><div class="line">                <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line">   <span class="comment">/* =&gt; */</span></div><div class="line">... <a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                 <span class="stringliteral">&quot;OUTPUT&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>, <a class="code" href="confparse_8hh.html#af668236f4b4a15caf6f2508cd25bfc87">cpInteger</a>, &amp;_output,</div><div class="line">                 <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line"></div><div class="line"><span class="comment">// 3. Counter: Keywords are marked with cpkN (or, equivalently, 0).</span></div><div class="line">... <a class="code" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                <a class="code" href="confparse_8hh.html#aca9a72e47b3d5f977b367f7222d0a9bc">cpKeywords</a>,</div><div class="line">                <span class="stringliteral">&quot;COUNT_CALL&quot;</span>, <a class="code" href="confparse_8hh.html#a54ac02b6dea6f2826d3547b3939f9a15">cpArgument</a>, <span class="stringliteral">&quot;handler to call after a count&quot;</span>, &amp;count_call,</div><div class="line">                <span class="stringliteral">&quot;BYTE_COUNT_CALL&quot;</span>, <a class="code" href="confparse_8hh.html#a54ac02b6dea6f2826d3547b3939f9a15">cpArgument</a>, <span class="stringliteral">&quot;handler to call after a byte count&quot;</span>, &amp;byte_count_call,</div><div class="line">                <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line">   <span class="comment">/* =&gt; */</span></div><div class="line">... <a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                 <span class="stringliteral">&quot;COUNT_CALL&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f">cpkN</a>, <a class="code" href="confparse_8hh.html#a54ac02b6dea6f2826d3547b3939f9a15">cpArgument</a>, &amp;count_call,</div><div class="line">                 <span class="stringliteral">&quot;BYTE_COUNT_CALL&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f">cpkN</a>, <a class="code" href="confparse_8hh.html#a54ac02b6dea6f2826d3547b3939f9a15">cpArgument</a>, &amp;byte_count_call,</div><div class="line">                 <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line"></div><div class="line"><span class="comment">// 4. IPFragmenter: Combining all of the above.</span></div><div class="line">... <a class="code" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                <a class="code" href="confparse_8hh.html#a02c3a4f21b5a8c8015edce2e7bc359ab">cpUnsigned</a>, <span class="stringliteral">&quot;MTU&quot;</span>, &amp;_mtu,</div><div class="line">                <a class="code" href="confparse_8hh.html#abb026faaf3c7dbd25a48f3e1124abf0d">cpOptional</a>,</div><div class="line">                <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, <span class="stringliteral">&quot;HONOR_DF&quot;</span>, &amp;_honor_df,</div><div class="line">                <a class="code" href="confparse_8hh.html#aca9a72e47b3d5f977b367f7222d0a9bc">cpKeywords</a>,</div><div class="line">                <span class="stringliteral">&quot;HONOR_DF&quot;</span>, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, <span class="stringliteral">&quot;honor DF bit?&quot;</span>, &amp;_honor_df,</div><div class="line">                <span class="stringliteral">&quot;VERBOSE&quot;</span>, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, <span class="stringliteral">&quot;be verbose?&quot;</span>, &amp;_verbose,</div><div class="line">                <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line">   <span class="comment">/* =&gt; */</span></div><div class="line">... <a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                 <span class="stringliteral">&quot;MTU&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>+<a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2aef082c716fc62df74058d1fc3f3d74a9">cpkM</a>, <a class="code" href="confparse_8hh.html#a02c3a4f21b5a8c8015edce2e7bc359ab">cpUnsigned</a>, &amp;_mtu,</div><div class="line">                 <span class="stringliteral">&quot;HONOR_DF&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a5d1dc4f95c6e5f4506158ed4bf61216d">cpkP</a>, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, &amp;_honor_df,   <span class="comment">// NB only one HONOR_DF</span></div><div class="line">                 <span class="stringliteral">&quot;VERBOSE&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f">cpkN</a>, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, &amp;_verbose,</div><div class="line">                 <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line"></div><div class="line"><span class="comment">// 5. AggregateIPFlows: Confirmed keywords are marked with cpkC.</span></div><div class="line">... <a class="code" href="confparse_8hh.html#aea6b37319089e863e60a30543e320644">cp_va_parse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                <span class="stringliteral">&quot;TCP_TIMEOUT&quot;</span>, <a class="code" href="confparse_8hh.html#ad644d2dd40557bae281415614eb7df20">cpSeconds</a>, <span class="stringliteral">&quot;timeout for active TCP connections&quot;</span>, &amp;_tcp_timeout, ...,</div><div class="line">                <a class="code" href="confparse_8hh.html#a3d3617951ee3e5b9eb80018ec269c612">cpConfirmKeywords</a>,</div><div class="line">                <span class="stringliteral">&quot;FRAGMENTS&quot;</span>, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, <span class="stringliteral">&quot;handle fragmented packets?&quot;</span>, &amp;gave_fragments, &amp;fragments,</div><div class="line">                <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div><div class="line">   <span class="comment">/* =&gt; */</span></div><div class="line">... <a class="code" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484">cp_va_kparse</a>(conf, <span class="keyword">this</span>, errh,</div><div class="line">                 <span class="stringliteral">&quot;TCP_TIMEOUT&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a6d1a0bbb1aa1fb53873a33b152722b0f">cpkN</a>, <a class="code" href="confparse_8hh.html#ad644d2dd40557bae281415614eb7df20">cpSeconds</a>, &amp;_tcp_timeout, ...,</div><div class="line">                 <span class="stringliteral">&quot;FRAGMENTS&quot;</span>, <a class="code" href="confparse_8hh.html#a63ecb5b3b015b237f2f78b05595f07f2a88a11f4667824503572876fc1956ff67">cpkC</a>, &amp;gave_fragments, <a class="code" href="confparse_8hh.html#a70743b45b8c583047e6405006d3e997d">cpBool</a>, &amp;fragments,  <span class="comment">// Note different order</span></div><div class="line">                 <a class="code" href="confparse_8hh.html#a3107cb41175a9f2d8910ec6004458e91">cpEnd</a>) ...</div></div><!-- fragment --> 
</div>
</div>
<a id="abe286c128e1450846423736a7e045818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe286c128e1450846423736a7e045818">&#9670;&nbsp;</a></span>cp_va_parse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy function for parsing a comma-separated argument string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>comma-separated argument string </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter descriptions, terminated by cpEnd </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000017">Deprecated:</a></b></dt><dd>Use <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> instead. See cp_va_parse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a> &amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...) for a transition guide. </dd></dl>

</div>
</div>
<a id="a5e118defdfe7dea181dec407857f6373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e118defdfe7dea181dec407857f6373">&#9670;&nbsp;</a></span>cp_va_space_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_space_parse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy function for parsing a space-separated argument string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>space-separated argument string </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter descriptions, terminated by cpEnd </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000018">Deprecated:</a></b></dt><dd>Use <a class="el" href="confparse_8hh.html#a837ac4bbf266763b5eebb3e02a10b4da" title="Parse a space-separated argument string. ">cp_va_space_kparse()</a> instead. See cp_va_parse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a> &amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...) for a transition guide. </dd></dl>

</div>
</div>
<a id="aec000231945185c38d89b74b86525e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec000231945185c38d89b74b86525e6d">&#9670;&nbsp;</a></span>cp_va_parse_keyword()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_parse_keyword </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy function for parsing a single argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>argument </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter descriptions, terminated by cpEnd </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000019">Deprecated:</a></b></dt><dd>Use <a class="el" href="confparse_8hh.html#a9217b8857a6309841ba3d075ef85437a" title="Parse a single argument. ">cp_va_kparse_keyword()</a> instead. See cp_va_parse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a> &amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...) for a transition guide. </dd></dl>

</div>
</div>
<a id="a53fca3a1428cc2a346305829764b1a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53fca3a1428cc2a346305829764b1a75">&#9670;&nbsp;</a></span>cp_va_parse_remove_keywords()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int cp_va_parse_remove_keywords </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Legacy function for parsing and removing matching arguments from <em>conf</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>argument list </td></tr>
    <tr><td class="paramname">first</td><td>index of first non-mandatory argument </td></tr>
    <tr><td class="paramname">context</td><td>element context </td></tr>
    <tr><td class="paramname">errh</td><td>error handler </td></tr>
    <tr><td class="paramname">...</td><td>zero or more parameter descriptions, terminated by cpEnd </td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000020">Deprecated:</a></b></dt><dd>Use <a class="el" href="confparse_8hh.html#a01b6a55a3d1d22bbadfaf378a301edf0" title="Parse and remove matching arguments from conf. ">cp_va_kparse_remove_keywords()</a> instead. See cp_va_parse(const <a class="el" href="class_vector.html">Vector&lt;String&gt;</a> &amp;, <a class="el" href="class_element.html" title="Base class for Click elements. ">Element</a> *, <a class="el" href="class_error_handler.html" title="Error reporting class. ">ErrorHandler</a> *, ...) for a transition guide. Note that <a class="el" href="confparse_8hh.html#a01b6a55a3d1d22bbadfaf378a301edf0" title="Parse and remove matching arguments from conf. ">cp_va_kparse_remove_keywords()</a> does not take the <em>first</em> argument; simply leave it off. </dd></dl>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a3107cb41175a9f2d8910ec6004458e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3107cb41175a9f2d8910ec6004458e91">&#9670;&nbsp;</a></span>cpEnd</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpEnd</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use as argument name. Ends cp_va argument list. </p>

</div>
</div>
<a id="a5d8aad812afb85b0fef0f20e004bfa0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8aad812afb85b0fef0f20e004bfa0b">&#9670;&nbsp;</a></span>cpIgnoreRest</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIgnoreRest</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use as argument name. No result storage; causes <a class="el" href="confparse_8hh.html#a9cf73ba574654eee9d96123c45fe3484" title="Parse a list of arguments. ">cp_va_kparse()</a> to ignore unparsed arguments and any remaining items. </p>

</div>
</div>
<a id="a9fa57761bf1391314f00669b8e6fd3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa57761bf1391314f00669b8e6fd3e8">&#9670;&nbsp;</a></span>cpIgnore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIgnore</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>No result storage, ignores this argument. </p>

</div>
</div>
<a id="a54ac02b6dea6f2826d3547b3939f9a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ac02b6dea6f2826d3547b3939f9a15">&#9670;&nbsp;</a></span>cpArgument</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpArgument</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage String*, accepts any argument. </p>

</div>
</div>
<a id="ae8b20288115ebdc905a473a9ccea9360"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8b20288115ebdc905a473a9ccea9360">&#9670;&nbsp;</a></span>cpArguments</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpArguments</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage <a class="el" href="class_vector.html">Vector&lt;String&gt;</a>*, accepts any number of arguments with the same keyword. </p>

</div>
</div>
<a id="a7b070881b58db387ca6b8de0ee019be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b070881b58db387ca6b8de0ee019be4">&#9670;&nbsp;</a></span>cpString</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpString</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a3853041c3eff44f9432a41163a73c2bd" title="Parse a string from str. ">cp_string()</a>. </p>

</div>
</div>
<a id="a239e7339df236b3643d249865391ea6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239e7339df236b3643d249865391ea6a">&#9670;&nbsp;</a></span>cpWord</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpWord</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage String*, parsed by <a class="el" href="confparse_8hh.html#aae21647d30503b2b4e2bb04fd8842922" title="Parse a word from str. ">cp_word()</a>. </p>

</div>
</div>
<a id="a7e0c005f21cdbacc729d17cd76a2e8fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c005f21cdbacc729d17cd76a2e8fa">&#9670;&nbsp;</a></span>cpKeyword</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpKeyword</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a17450dcd527f644e36009aefb1e1bd36" title="Parse a keyword from str. ">cp_keyword()</a>. </p>

</div>
</div>
<a id="a70743b45b8c583047e6405006d3e997d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70743b45b8c583047e6405006d3e997d">&#9670;&nbsp;</a></span>cpBool</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpBool</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage bool*, parsed by <a class="el" href="confparse_8hh.html#a7e741359e6048d9847df83ba3b790c71" title="Parse a boolean from str. ">cp_bool()</a>. </p>

</div>
</div>
<a id="a802b1f261939ad1e1f602338ca6bc58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802b1f261939ad1e1f602338ca6bc58c">&#9670;&nbsp;</a></span>cpByte</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpByte</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage unsigned char*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a8cd1be6b084c9bb8de30b85feb1c1257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd1be6b084c9bb8de30b85feb1c1257">&#9670;&nbsp;</a></span>cpShort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpShort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage short*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a16a1557bacb0e0be5143db5e59aaa8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a1557bacb0e0be5143db5e59aaa8b5">&#9670;&nbsp;</a></span>cpUnsignedShort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUnsignedShort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage unsigned short*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="af668236f4b4a15caf6f2508cd25bfc87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af668236f4b4a15caf6f2508cd25bfc87">&#9670;&nbsp;</a></span>cpInteger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpInteger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage int32_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a02c3a4f21b5a8c8015edce2e7bc359ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c3a4f21b5a8c8015edce2e7bc359ab">&#9670;&nbsp;</a></span>cpUnsigned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUnsigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a38afa0eb33df387c613d1f8e0a00e779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38afa0eb33df387c613d1f8e0a00e779">&#9670;&nbsp;</a></span>cpSize</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpSize</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage size_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a4c416e44a66c4cafd9ae5a9246ef5483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c416e44a66c4cafd9ae5a9246ef5483">&#9670;&nbsp;</a></span>cpNamedInteger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpNamedInteger</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter uint32_t nameinfo_type, result storage int32_t*, parsed by <a class="el" href="class_name_info.html#a0c5ec52346d286545d099ff4139ef80e" title="Query installed databases for name, returning a 32-bit integer value. ">NameInfo::query_int</a>. </p>

</div>
</div>
<a id="a9ddf47f0316112e6b1f3df89908a34cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddf47f0316112e6b1f3df89908a34cf">&#9670;&nbsp;</a></span>cpInteger64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpInteger64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage int64_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="afc20aa1cbb0a3562476200c25423f45e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc20aa1cbb0a3562476200c25423f45e">&#9670;&nbsp;</a></span>cpUnsigned64</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUnsigned64</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint64_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="a6359a0cdf3daf568fa6e1399ac88afa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6359a0cdf3daf568fa6e1399ac88afa9">&#9670;&nbsp;</a></span>cpUnsignedReal2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUnsignedReal2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter int frac_bits, result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a62fe9aa2b03be0c2c99070cb64240d84" title="Parse a fixed-point number from str. ">cp_real2()</a>. </p>

</div>
</div>
<a id="a026f56003e8aa5eb72aec8b7b16e859d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026f56003e8aa5eb72aec8b7b16e859d">&#9670;&nbsp;</a></span>cpReal10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpReal10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter int frac_digits, result storage int32_t*, parsed by <a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e" title="Parse a real number from str, representing the result as an integer with frac_digits decimal digits o...">cp_real10()</a>. </p>

</div>
</div>
<a id="aa74d4a665ecfbbdf6947a1a7be5114dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74d4a665ecfbbdf6947a1a7be5114dd">&#9670;&nbsp;</a></span>cpUnsignedReal10</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUnsignedReal10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter int frac_digits, result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a387daecd4382457c3d2b8be88e60d02e" title="Parse a real number from str, representing the result as an integer with frac_digits decimal digits o...">cp_real10()</a>. </p>

</div>
</div>
<a id="ae5f31418cced25a485e8e97e68a44b1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f31418cced25a485e8e97e68a44b1b">&#9670;&nbsp;</a></span>cpDouble</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpDouble</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage double*, parsed by <a class="el" href="confparse_8hh.html#a03e3d6bb41be9959f40a37f217d9bc2a" title="Parse a real number from str. ">cp_double()</a>. </p>

</div>
</div>
<a id="ad644d2dd40557bae281415614eb7df20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad644d2dd40557bae281415614eb7df20">&#9670;&nbsp;</a></span>cpSeconds</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpSeconds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a45f4dd1ae1146aad253b6ecf69000f6c" title="Parse an amount of time from str. ">cp_seconds_as()</a> with frac_digits 0. </p>

</div>
</div>
<a id="a014e4a35daa90e43bc68e06bdf17ab6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a014e4a35daa90e43bc68e06bdf17ab6b">&#9670;&nbsp;</a></span>cpSecondsAsMilli</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpSecondsAsMilli</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#afa241b9899bd1118769cbff9ce75c18f" title="Parse an amount of time in milliseconds from str. ">cp_seconds_as_milli()</a>. </p>

</div>
</div>
<a id="a699ac8df64f0031e842c1ccc8b639ad0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a699ac8df64f0031e842c1ccc8b639ad0">&#9670;&nbsp;</a></span>cpSecondsAsMicro</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpSecondsAsMicro</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#a1502cc5e990c25518f8c16536493136f" title="Parse an amount of time in microseconds from str. ">cp_seconds_as_micro()</a>. </p>

</div>
</div>
<a id="ae9c309617bf09f1a1befa6c737b23c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c309617bf09f1a1befa6c737b23c88">&#9670;&nbsp;</a></span>cpTimestamp</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpTimestamp</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage Timestamp*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>. </p>

</div>
</div>
<a id="afccf0abca85e42010de19371c41234c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afccf0abca85e42010de19371c41234c7">&#9670;&nbsp;</a></span>cpTimestampSigned</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpTimestampSigned</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage Timestamp*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>. </p>

</div>
</div>
<a id="ac23f87af591ff92757961888efe6b2ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23f87af591ff92757961888efe6b2ac">&#9670;&nbsp;</a></span>cpTimeval</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpTimeval</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage struct timeval*, parsed by <a class="el" href="confparse_8hh.html#a048b32c8601bb347886d5f3ea749221f" title="Parse a timestamp from str. ">cp_time()</a>. </p>

</div>
</div>
<a id="aad6c97ac8eca209f5663d250647ec08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad6c97ac8eca209f5663d250647ec08c">&#9670;&nbsp;</a></span>cpBandwidth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpBandwidth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint32_t*, parsed by <a class="el" href="confparse_8hh.html#ae0abab0a34c041846472bf3e6ffae4be" title="Parse a bandwidth value from str. ">cp_bandwidth()</a>. </p>

</div>
</div>
<a id="ad7bdbf222a354f7864e8ce284fd1fe42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7bdbf222a354f7864e8ce284fd1fe42">&#9670;&nbsp;</a></span>cpIPAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIPAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IPAddress* or equivalent, parsed by <a class="el" href="confparse_8hh.html#aa8914824f1b08c1b6ff63f10b3583ada" title="Parse an IP address from str. ">cp_ip_address()</a>. </p>

</div>
</div>
<a id="a234dd84d3576cb40a2cee3a4e1ddd00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234dd84d3576cb40a2cee3a4e1ddd00d">&#9670;&nbsp;</a></span>cpIPPrefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIPPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IPAddress* addr and <a class="el" href="class_i_p_address.html" title="An IPv4 address. ">IPAddress</a> *mask, parsed by <a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93" title="Parse an IP address or prefix from str. ">cp_ip_prefix()</a>. </p>

</div>
</div>
<a id="afc77d6340ef7fb659fa154220ff2460a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc77d6340ef7fb659fa154220ff2460a">&#9670;&nbsp;</a></span>cpIPAddressOrPrefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIPAddressOrPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IPAddress* addr and <a class="el" href="class_i_p_address.html" title="An IPv4 address. ">IPAddress</a> *mask, parsed by <a class="el" href="confparse_8hh.html#ac6b2a34a902c5b2855e016120c284b93" title="Parse an IP address or prefix from str. ">cp_ip_prefix()</a>. </p>

</div>
</div>
<a id="ab9193eabb4fe3e037861d5a139b44908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9193eabb4fe3e037861d5a139b44908">&#9670;&nbsp;</a></span>cpIPAddressList</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIPAddressList</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage Vector&lt;IPAddress&gt;*, parsed by <a class="el" href="confparse_8hh.html#a851d8db616ba1745bcdbac8bdd5574cf" title="Parse a space-separated list of IP addresses from str. ">cp_ip_address_list()</a>. </p>

</div>
</div>
<a id="ac726d572fd623b660689f967491072fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac726d572fd623b660689f967491072fe">&#9670;&nbsp;</a></span>cpEtherAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpEtherAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage EtherAddress*, parsed by <a class="el" href="confparse_8hh.html#a71a07a747ecfafca77978fbace74d01d" title="Parse an Ethernet address from str. ">cp_ethernet_address()</a>. </p>

</div>
</div>
<a id="a88b872143fdfb48efbc3f80e696b67a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b872143fdfb48efbc3f80e696b67a1">&#9670;&nbsp;</a></span>cpEthernetAddress</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpEthernetAddress</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage EtherAddress*, parsed by <a class="el" href="confparse_8hh.html#a71a07a747ecfafca77978fbace74d01d" title="Parse an Ethernet address from str. ">cp_ethernet_address()</a>. Synonym for cpEtherAddress. </p>

</div>
</div>
<a id="a586c2aabfd7ddab05a07b3e9f72f0809"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a586c2aabfd7ddab05a07b3e9f72f0809">&#9670;&nbsp;</a></span>cpTCPPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpTCPPort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint16_t*, parsed by <a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d" title="Parse a TCP, UDP, etc. port number from str. ">cp_tcpudp_port()</a>. </p>

</div>
</div>
<a id="a9a8767dbcabfcb15a8a25e9314d48927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a8767dbcabfcb15a8a25e9314d48927">&#9670;&nbsp;</a></span>cpUDPPort</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpUDPPort</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage uint16_t*, parsed by <a class="el" href="confparse_8hh.html#a0b51d4b32b3318b2c02a376e5312d32d" title="Parse a TCP, UDP, etc. port number from str. ">cp_tcpudp_port()</a>. </p>

</div>
</div>
<a id="af0b54fa1eff1f6cc1db41f1be29407a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b54fa1eff1f6cc1db41f1be29407a1">&#9670;&nbsp;</a></span>cpElement</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpElement</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage Element**, parsed by <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a>. </p>

</div>
</div>
<a id="ae8f7c4e4b874ffe5bb9ee3b5c740fa17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f7c4e4b874ffe5bb9ee3b5c740fa17">&#9670;&nbsp;</a></span>cpElementCast</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpElementCast</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter const char*, result storage void**, parsed by <a class="el" href="confparse_8hh.html#a63a04a5a56f54f32679a5d873ac1cd2d" title="Parse an element reference from str. ">cp_element()</a> and <a class="el" href="class_element.html#ae19904c6060f3d4411e32cba0dd2e3c1" title="Attempt to cast the element to a named type. ">Element::cast()</a>. </p>

</div>
</div>
<a id="ab48dc97b1196c9cfcdd053a9aea4a37d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48dc97b1196c9cfcdd053a9aea4a37d">&#9670;&nbsp;</a></span>cpHandlerName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpHandlerName</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage Element** and String*, parsed by <a class="el" href="confparse_8hh.html#ad412ee0e6169740f40c956a0d533848b" title="Parse a handler name from str. ">cp_handler_name()</a>. </p>

</div>
</div>
<a id="af3e466630ef61518c01bfafaa4a69226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e466630ef61518c01bfafaa4a69226">&#9670;&nbsp;</a></span>cpHandlerCallRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpHandlerCallRead</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage HandlerCall*, parsed by <a class="el" href="class_handler_call.html" title="Convenience class for calling handlers. ">HandlerCall</a>. </p>

</div>
</div>
<a id="a2fd8fa488e307cc0be357d87ff0c6fd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd8fa488e307cc0be357d87ff0c6fd0">&#9670;&nbsp;</a></span>cpHandlerCallWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpHandlerCallWrite</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage HandlerCall*, parsed by <a class="el" href="class_handler_call.html" title="Convenience class for calling handlers. ">HandlerCall</a>. </p>

</div>
</div>
<a id="ad2d978036217313a428f043b450dfb0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d978036217313a428f043b450dfb0a">&#9670;&nbsp;</a></span>cpHandlerCallPtrRead</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpHandlerCallPtrRead</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage HandlerCall**, parsed by <a class="el" href="class_handler_call.html#a4ff40e1bb09141973016bb3259df531c" title="Create and initialize a read HandlerCall from hdesc. ">HandlerCall::reset_read</a>. </p>

</div>
</div>
<a id="aed6670db8f13b686aa92603150e2cf2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6670db8f13b686aa92603150e2cf2b">&#9670;&nbsp;</a></span>cpHandlerCallPtrWrite</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpHandlerCallPtrWrite</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage HandlerCall**, parsed by <a class="el" href="class_handler_call.html#a79ef3c74336920b4e856d4b7d4f0941e" title="Create and initialize a write HandlerCall from hdesc. ">HandlerCall::reset_write</a>. </p>

</div>
</div>
<a id="a30f1175365a79b40e1a9baff9376c99c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f1175365a79b40e1a9baff9376c99c">&#9670;&nbsp;</a></span>cpIP6Address</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIP6Address</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IP6Address* or equivalent, parsed by <a class="el" href="confparse_8hh.html#a497851064c585d0fa473a30bf73998af" title="Parse an IPv6 address from str. ">cp_ip6_address()</a>. </p>

</div>
</div>
<a id="a16b15ecc0f6e9f52060d7e031087e4aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b15ecc0f6e9f52060d7e031087e4aa">&#9670;&nbsp;</a></span>cpIP6Prefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIP6Prefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IP6Address* addr and IP6Address* mask, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>. </p>

</div>
</div>
<a id="a52fee93fa661924ae0a0e2409ce07ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fee93fa661924ae0a0e2409ce07ed3">&#9670;&nbsp;</a></span>cpIP6PrefixLen</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIP6PrefixLen</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IP6Address* addr and int* prefix_len, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>. </p>

</div>
</div>
<a id="af17decc8597d6ee5135216d2fa5a5247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17decc8597d6ee5135216d2fa5a5247">&#9670;&nbsp;</a></span>cpIP6AddressOrPrefix</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpIP6AddressOrPrefix</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage IP6Address* addr and IP6Address* mask, parsed by <a class="el" href="confparse_8hh.html#afc5fd422bb8653469dcc1f655ba3e426" title="Parse an IPv6 address or prefix from str. ">cp_ip6_prefix()</a>. </p>

</div>
</div>
<a id="a620dc576beec00aefd8872fc2703092f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620dc576beec00aefd8872fc2703092f">&#9670;&nbsp;</a></span>cpFilename</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpFilename</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage String*, parsed by <a class="el" href="confparse_8hh.html#a90bf06e7b3314f7e1806b0977ceac65e" title="Parse a filename string from str. ">cp_filename()</a>. </p>

</div>
</div>
<a id="ae21e655b2d4e0d5e91ca3ddc242eb61c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae21e655b2d4e0d5e91ca3ddc242eb61c">&#9670;&nbsp;</a></span>cpFileOffset</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpFileOffset</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Result storage off_t*, parsed by <a class="el" href="confparse_8hh.html#a73da3daad75dc0be8f51f2b8c9bd1e7c" title="Parse an integer from [begin, end) in base base. ">cp_integer()</a>. </p>

</div>
</div>
<a id="abf82791e7d98a4e9cb78c10ab244d9f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf82791e7d98a4e9cb78c10ab244d9f7">&#9670;&nbsp;</a></span>cpAnno</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpAnno</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse parameter int annotation_size, result storage int*, parsed by <a class="el" href="confparse_8hh.html#a74c9c7cd4046a5896351bace015bbcab" title="Parse a packet annotation value from str. ">cp_anno()</a>. </p>

</div>
</div>
<a id="abb026faaf3c7dbd25a48f3e1124abf0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb026faaf3c7dbd25a48f3e1124abf0d">&#9670;&nbsp;</a></span>cpOptional</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpOptional</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cp_va_parse only: Following arguments are optional. </p>

</div>
</div>
<a id="aca9a72e47b3d5f977b367f7222d0a9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca9a72e47b3d5f977b367f7222d0a9bc">&#9670;&nbsp;</a></span>cpKeywords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpKeywords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cp_va_parse only: Following arguments are keywords. </p>

</div>
</div>
<a id="a3d3617951ee3e5b9eb80018ec269c612"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3617951ee3e5b9eb80018ec269c612">&#9670;&nbsp;</a></span>cpConfirmKeywords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpConfirmKeywords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cp_va_parse only: Following arguments are confirmed keywords. </p>

</div>
</div>
<a id="aab09850bee7830d5557596adddcc6200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab09850bee7830d5557596adddcc6200">&#9670;&nbsp;</a></span>cpMandatoryKeywords</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="confparse_8hh.html#aac2cc0db6bee483e94e998211609d876">CpVaParseCmd</a> cpMandatoryKeywords</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>cp_va_parse only: Following arguments are mandatory keywords. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 13 2017 20:11:39 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
