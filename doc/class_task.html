<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Click: Task Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="class_task-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Task Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Represents a frequently-scheduled computational task.  
 <a href="class_task.html#details">More...</a></p>

<p>Inherits TaskLink.</p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a6b118538f13862065e2dd128e2901d05"><td class="memItemLeft" align="right" valign="top"><a id="a6b118538f13862065e2dd128e2901d05"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>STRIDE1</b> = 1U&lt;&lt;16, 
<b>MAX_STRIDE</b> = 1U&lt;&lt;31
 }</td></tr>
<tr class="separator:a6b118538f13862065e2dd128e2901d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef88c0a00d95e14b4ccf11d8f3dbff8"><td class="memItemLeft" align="right" valign="top"><a id="a4ef88c0a00d95e14b4ccf11d8f3dbff8"></a>enum &#160;</td><td class="memItemRight" valign="bottom">{ <b>MAX_TICKETS</b> = 1&lt;&lt;15, 
<b>DEFAULT_TICKETS</b> = 1&lt;&lt;10
 }</td></tr>
<tr class="separator:a4ef88c0a00d95e14b4ccf11d8f3dbff8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a3724f95f3e5b5c830e0fe6c4dde076ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a3724f95f3e5b5c830e0fe6c4dde076ae">Task</a> (TaskCallback f, void *<a class="el" href="class_task.html#a31ffa7f0f468e540996f163da4363ef8">user_data</a>)</td></tr>
<tr class="memdesc:a3724f95f3e5b5c830e0fe6c4dde076ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a task that calls <em>f</em> with <em>user_data</em> argument.  <a href="#a3724f95f3e5b5c830e0fe6c4dde076ae">More...</a><br /></td></tr>
<tr class="separator:a3724f95f3e5b5c830e0fe6c4dde076ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72c75cea9ea305831251239dd9dbd36b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a72c75cea9ea305831251239dd9dbd36b">Task</a> (<a class="el" href="class_element.html">Element</a> *e)</td></tr>
<tr class="memdesc:a72c75cea9ea305831251239dd9dbd36b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a task that calls <em>e</em> -&gt;<a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db">run_task()</a>.  <a href="#a72c75cea9ea305831251239dd9dbd36b">More...</a><br /></td></tr>
<tr class="separator:a72c75cea9ea305831251239dd9dbd36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ecf499ea35fb4a96853969a1e1cbbce"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a3ecf499ea35fb4a96853969a1e1cbbce">~Task</a> ()</td></tr>
<tr class="memdesc:a3ecf499ea35fb4a96853969a1e1cbbce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy a task.  <a href="#a3ecf499ea35fb4a96853969a1e1cbbce">More...</a><br /></td></tr>
<tr class="separator:a3ecf499ea35fb4a96853969a1e1cbbce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcd5dcc40caf17ba1d30771230f53ae9"><td class="memItemLeft" align="right" valign="top">TaskCallback&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#abcd5dcc40caf17ba1d30771230f53ae9">callback</a> () const</td></tr>
<tr class="memdesc:abcd5dcc40caf17ba1d30771230f53ae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task's callback function.  <a href="#abcd5dcc40caf17ba1d30771230f53ae9">More...</a><br /></td></tr>
<tr class="separator:abcd5dcc40caf17ba1d30771230f53ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31ffa7f0f468e540996f163da4363ef8"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a31ffa7f0f468e540996f163da4363ef8">user_data</a> () const</td></tr>
<tr class="memdesc:a31ffa7f0f468e540996f163da4363ef8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task callback function's user data.  <a href="#a31ffa7f0f468e540996f163da4363ef8">More...</a><br /></td></tr>
<tr class="separator:a31ffa7f0f468e540996f163da4363ef8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0134633cfcbed9b6c86b1880362f5e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a0c0134633cfcbed9b6c86b1880362f5e">element</a> () const</td></tr>
<tr class="memdesc:a0c0134633cfcbed9b6c86b1880362f5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task's owning element.  <a href="#a0c0134633cfcbed9b6c86b1880362f5e">More...</a><br /></td></tr>
<tr class="separator:a0c0134633cfcbed9b6c86b1880362f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e4d575af1ef7bd6865fca8c38d82d2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a6e4d575af1ef7bd6865fca8c38d82d2b">initialized</a> () const</td></tr>
<tr class="memdesc:a6e4d575af1ef7bd6865fca8c38d82d2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the task has been <a class="el" href="class_task.html#a9f1f8c7d7d446650c3435a012c8b91bf" title="Initialize the Task, and optionally schedule it. ">initialize()</a>d.  <a href="#a6e4d575af1ef7bd6865fca8c38d82d2b">More...</a><br /></td></tr>
<tr class="separator:a6e4d575af1ef7bd6865fca8c38d82d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ed45dcf81a790447080b583dd8650f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a02ed45dcf81a790447080b583dd8650f">home_thread_id</a> () const</td></tr>
<tr class="memdesc:a02ed45dcf81a790447080b583dd8650f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task's home thread ID.  <a href="#a02ed45dcf81a790447080b583dd8650f">More...</a><br /></td></tr>
<tr class="separator:a02ed45dcf81a790447080b583dd8650f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabbead0f989ee20f10f7abedba62350b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_router_thread.html">RouterThread</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#aabbead0f989ee20f10f7abedba62350b">thread</a> () const</td></tr>
<tr class="memdesc:aabbead0f989ee20f10f7abedba62350b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the thread on which this task is currently scheduled, or would be scheduled.  <a href="#aabbead0f989ee20f10f7abedba62350b">More...</a><br /></td></tr>
<tr class="separator:aabbead0f989ee20f10f7abedba62350b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae347499f0f66a02b59b30de3caef5e6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_router.html">Router</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#ae347499f0f66a02b59b30de3caef5e6d">router</a> () const</td></tr>
<tr class="memdesc:ae347499f0f66a02b59b30de3caef5e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the router to which this task belongs.  <a href="#ae347499f0f66a02b59b30de3caef5e6d">More...</a><br /></td></tr>
<tr class="separator:ae347499f0f66a02b59b30de3caef5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27af9c4a1a02a5e085e72c138943b9cb"><td class="memItemLeft" align="right" valign="top">Master *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a27af9c4a1a02a5e085e72c138943b9cb">master</a> () const</td></tr>
<tr class="memdesc:a27af9c4a1a02a5e085e72c138943b9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the master where this task will be scheduled.  <a href="#a27af9c4a1a02a5e085e72c138943b9cb">More...</a><br /></td></tr>
<tr class="separator:a27af9c4a1a02a5e085e72c138943b9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f1f8c7d7d446650c3435a012c8b91bf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a9f1f8c7d7d446650c3435a012c8b91bf">initialize</a> (<a class="el" href="class_element.html">Element</a> *owner, bool schedule)</td></tr>
<tr class="memdesc:a9f1f8c7d7d446650c3435a012c8b91bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, and optionally schedule it.  <a href="#a9f1f8c7d7d446650c3435a012c8b91bf">More...</a><br /></td></tr>
<tr class="separator:a9f1f8c7d7d446650c3435a012c8b91bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2266dfe38a41434d302e712fc7fdc230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a2266dfe38a41434d302e712fc7fdc230">initialize</a> (<a class="el" href="class_router.html">Router</a> *<a class="el" href="class_task.html#ae347499f0f66a02b59b30de3caef5e6d">router</a>, bool schedule)</td></tr>
<tr class="memdesc:a2266dfe38a41434d302e712fc7fdc230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, and optionally schedule it.  <a href="#a2266dfe38a41434d302e712fc7fdc230">More...</a><br /></td></tr>
<tr class="separator:a2266dfe38a41434d302e712fc7fdc230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481866bfe2f4f439b949706c679ece1a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a481866bfe2f4f439b949706c679ece1a">scheduled</a> () const</td></tr>
<tr class="memdesc:a481866bfe2f4f439b949706c679ece1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the task is currently scheduled to run.  <a href="#a481866bfe2f4f439b949706c679ece1a">More...</a><br /></td></tr>
<tr class="separator:a481866bfe2f4f439b949706c679ece1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab98c3ba90bbded1d55c3dacce8961c3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#ab98c3ba90bbded1d55c3dacce8961c3a">unschedule</a> ()</td></tr>
<tr class="memdesc:ab98c3ba90bbded1d55c3dacce8961c3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedule the task.  <a href="#ab98c3ba90bbded1d55c3dacce8961c3a">More...</a><br /></td></tr>
<tr class="separator:ab98c3ba90bbded1d55c3dacce8961c3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d8fd2f8c0d227d7be13742c1dd56590"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590">reschedule</a> ()</td></tr>
<tr class="memdesc:a3d8fd2f8c0d227d7be13742c1dd56590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule the task.  <a href="#a3d8fd2f8c0d227d7be13742c1dd56590">More...</a><br /></td></tr>
<tr class="separator:a3d8fd2f8c0d227d7be13742c1dd56590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1253ff52ca19fb20393f0285787c23c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#ae1253ff52ca19fb20393f0285787c23c">fast_reschedule</a> ()</td></tr>
<tr class="memdesc:ae1253ff52ca19fb20393f0285787c23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule a task from the task's callback function.  <a href="#ae1253ff52ca19fb20393f0285787c23c">More...</a><br /></td></tr>
<tr class="separator:ae1253ff52ca19fb20393f0285787c23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7bf5b861d3f092df74e6b51a00f0ce8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8">strong_unschedule</a> ()</td></tr>
<tr class="memdesc:aa7bf5b861d3f092df74e6b51a00f0ce8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unschedule the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> until <a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule()</a>.  <a href="#aa7bf5b861d3f092df74e6b51a00f0ce8">More...</a><br /></td></tr>
<tr class="separator:aa7bf5b861d3f092df74e6b51a00f0ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4f97540cff46af5393885f66c3fbc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8">strong_reschedule</a> ()</td></tr>
<tr class="memdesc:a4b4f97540cff46af5393885f66c3fbc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reschedule the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, undoing a prior <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule()</a>.  <a href="#a4b4f97540cff46af5393885f66c3fbc8">More...</a><br /></td></tr>
<tr class="separator:a4b4f97540cff46af5393885f66c3fbc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac36e7534b8a08146927a0417e7cfdc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a2ac36e7534b8a08146927a0417e7cfdc">move_thread</a> (int new_thread_id)</td></tr>
<tr class="memdesc:a2ac36e7534b8a08146927a0417e7cfdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> to a new home thread.  <a href="#a2ac36e7534b8a08146927a0417e7cfdc">More...</a><br /></td></tr>
<tr class="separator:a2ac36e7534b8a08146927a0417e7cfdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708786d60ce709f0c6b8569afdffcdf7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a708786d60ce709f0c6b8569afdffcdf7">tickets</a> () const</td></tr>
<tr class="memdesc:a708786d60ce709f0c6b8569afdffcdf7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the task's number of tickets.  <a href="#a708786d60ce709f0c6b8569afdffcdf7">More...</a><br /></td></tr>
<tr class="separator:a708786d60ce709f0c6b8569afdffcdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24bef57ec630b9ce96fa485640591a2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a24bef57ec630b9ce96fa485640591a2a">set_tickets</a> (int n)</td></tr>
<tr class="memdesc:a24bef57ec630b9ce96fa485640591a2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the task's ticket count.  <a href="#a24bef57ec630b9ce96fa485640591a2a">More...</a><br /></td></tr>
<tr class="separator:a24bef57ec630b9ce96fa485640591a2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2674fc14867cee946f074ef06c3a6a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a2674fc14867cee946f074ef06c3a6a9d">adjust_tickets</a> (int delta)</td></tr>
<tr class="memdesc:a2674fc14867cee946f074ef06c3a6a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add <em>delta</em> to the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>'s ticket count.  <a href="#a2674fc14867cee946f074ef06c3a6a9d">More...</a><br /></td></tr>
<tr class="separator:a2674fc14867cee946f074ef06c3a6a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cf45c723dc8901383da016dc316ce21"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_task.html#a3cf45c723dc8901383da016dc316ce21">fire</a> ()</td></tr>
<tr class="memdesc:a3cf45c723dc8901383da016dc316ce21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fire the task by calling its callback function.  <a href="#a3cf45c723dc8901383da016dc316ce21">More...</a><br /></td></tr>
<tr class="separator:a3cf45c723dc8901383da016dc316ce21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a frequently-scheduled computational task. </p>
<p>Click schedules a router's CPU or CPUs with one or more <em>task queues</em>. These queues are simply lists of <em>tasks</em>, which represent functions that would like unconditional access to the CPU. Tasks are generally associated with elements. When scheduled, most tasks call some element's <a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db">run_task()</a> method.</p>
<p>Click tasks are represented by <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> objects. An element that would like special access to a router's CPU should include and initialize a <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> instance variable.</p>
<p>Tasks are called very frequently, up to tens of thousands of times per second. Elements generally use Tasks for frequent tasks, and implement their own algorithms for scheduling and unscheduling the tasks when there's work to be done. For infrequent events, it is far more efficient to use <a class="el" href="class_timer.html" title="Triggers execution at a given time. ">Timer</a> objects.</p>
<p>A <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>'s callback function, which is called when the task fires, has bool return type. The callback should return true if the task did useful work, and false if it was not able to do useful work (for example, because there were no packets in the configuration to return). Adaptive algorithms may use this information to fine-tune Click's scheduling behavior.</p>
<p>Since Click tasks are cooperatively scheduled, executing a task should not take a long time. Slow tasks can inappropriately delay timers and other periodic events.</p>
<p>This code shows how <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> objects tend to be used. For fuller examples, see InfiniteSource and similar elements.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>InfiniteSource { ...</div><div class="line">    <span class="keywordtype">bool</span> run_task(<a class="code" href="class_task.html">Task</a> *t);</div><div class="line">  <span class="keyword">private</span>:</div><div class="line">    <a class="code" href="class_task.html">Task</a> _task;</div><div class="line">};</div><div class="line"></div><div class="line">InfiniteSource::InfiniteSource() : _task(this) {</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> InfiniteSource::initialize(<a class="code" href="class_error_handler.html">ErrorHandler</a> *errh) {</div><div class="line">    ScheduleInfo::initialize_task(<span class="keyword">this</span>, &amp;_task, errh);</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> InfiniteSource::run_task(<a class="code" href="class_task.html">Task</a> *) {</div><div class="line">    <a class="code" href="class_packet.html">Packet</a> *p = ... generate packet ...;</div><div class="line">    output(0).<a class="code" href="class_packet.html#a65f07d2050c0eac6625e271c6d3398ea">push</a>(p);</div><div class="line">    <span class="keywordflow">if</span> (packets left to send)</div><div class="line">        _task.fast_reschedule();</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;  <span class="comment">// the task did useful work</span></div><div class="line">}</div></div><!-- fragment --> </div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3724f95f3e5b5c830e0fe6c4dde076ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3724f95f3e5b5c830e0fe6c4dde076ae">&#9670;&nbsp;</a></span>Task() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Task::Task </td>
          <td>(</td>
          <td class="paramtype">TaskCallback&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>user_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a task that calls <em>f</em> with <em>user_data</em> argument. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>callback function </td></tr>
    <tr><td class="paramname">user_data</td><td>argument for callback function</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs a task that, when fired, calls <em>f</em> like so:</p>
<div class="fragment"><div class="line"><span class="keywordtype">bool</span> work_done = f(task, <a class="code" href="class_task.html#a31ffa7f0f468e540996f163da4363ef8">user_data</a>);</div></div><!-- fragment --><p>where <em>task</em> is a pointer to this task. <em>f</em> should return true if the task accomplished some meaningful work, and false if it did not. For example, a task that polls a network driver for packets should return true if it emits at least one packet, and false if no packets were available. </p>

</div>
</div>
<a id="a72c75cea9ea305831251239dd9dbd36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72c75cea9ea305831251239dd9dbd36b">&#9670;&nbsp;</a></span>Task() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Task::Task </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a task that calls <em>e</em> -&gt;<a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db">run_task()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">e</td><td>element to call</td></tr>
  </table>
  </dd>
</dl>
<p>Constructs a task that, when fired, calls the element <em>e's</em> <a class="el" href="class_element.html#ab40229beca000d06db59fd4720e319db">run_task()</a> method, passing this <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> as an argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a3724f95f3e5b5c830e0fe6c4dde076ae" title="Construct a task that calls f with user_data argument. ">Task(TaskCallback, void *)</a> </dd></dl>

</div>
</div>
<a id="a3ecf499ea35fb4a96853969a1e1cbbce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ecf499ea35fb4a96853969a1e1cbbce">&#9670;&nbsp;</a></span>~Task()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Task::~Task </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy a task. </p>
<p>Unschedules the task if necessary. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abcd5dcc40caf17ba1d30771230f53ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcd5dcc40caf17ba1d30771230f53ae9">&#9670;&nbsp;</a></span>callback()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TaskCallback Task::callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task's callback function. </p>
<p>Returns null if the task was constructed with the <a class="el" href="class_task.html#a72c75cea9ea305831251239dd9dbd36b" title="Construct a task that calls e -&gt;run_task(). ">Task(Element *)</a> constructor. </p>

</div>
</div>
<a id="a31ffa7f0f468e540996f163da4363ef8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31ffa7f0f468e540996f163da4363ef8">&#9670;&nbsp;</a></span>user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* Task::user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task callback function's user data. </p>

</div>
</div>
<a id="a0c0134633cfcbed9b6c86b1880362f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0134633cfcbed9b6c86b1880362f5e">&#9670;&nbsp;</a></span>element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_element.html">Element</a>* Task::element </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task's owning element. </p>

</div>
</div>
<a id="a6e4d575af1ef7bd6865fca8c38d82d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e4d575af1ef7bd6865fca8c38d82d2b">&#9670;&nbsp;</a></span>initialized()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Task::initialized </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the task has been <a class="el" href="class_task.html#a9f1f8c7d7d446650c3435a012c8b91bf" title="Initialize the Task, and optionally schedule it. ">initialize()</a>d. </p>

</div>
</div>
<a id="a02ed45dcf81a790447080b583dd8650f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ed45dcf81a790447080b583dd8650f">&#9670;&nbsp;</a></span>home_thread_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Task::home_thread_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task's home thread ID. </p>
<p>This is the <a class="el" href="class_router_thread.html#a8396254df9c0511a98b29360bd3743c5">thread_id()</a> of the thread on which this <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> would run if it were scheduled. This need not equal the ID of the current <a class="el" href="class_task.html#aabbead0f989ee20f10f7abedba62350b" title="Return the thread on which this task is currently scheduled, or would be scheduled. ">thread()</a>, since changes in <a class="el" href="class_task.html#a02ed45dcf81a790447080b583dd8650f" title="Return the task&#39;s home thread ID. ">home_thread_id()</a> aren't always implemented immediately (because of locking issues).</p>
<p>never </p>

</div>
</div>
<a id="aabbead0f989ee20f10f7abedba62350b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabbead0f989ee20f10f7abedba62350b">&#9670;&nbsp;</a></span>thread()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_router_thread.html">RouterThread</a> * Task::thread </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the thread on which this task is currently scheduled, or would be scheduled. </p>
<p>Usually, task-&gt;<a class="el" href="class_task.html#aabbead0f989ee20f10f7abedba62350b" title="Return the thread on which this task is currently scheduled, or would be scheduled. ">thread()</a>-&gt;<a class="el" href="class_router_thread.html#a8396254df9c0511a98b29360bd3743c5">thread_id()</a> == task-&gt;<a class="el" href="class_task.html#a02ed45dcf81a790447080b583dd8650f" title="Return the task&#39;s home thread ID. ">home_thread_id()</a>. They can differ, however, if <a class="el" href="class_task.html#a2ac36e7534b8a08146927a0417e7cfdc" title="Move the Task to a new home thread. ">move_thread()</a> was called but the task hasn't yet been moved to the new thread. </p>

</div>
</div>
<a id="ae347499f0f66a02b59b30de3caef5e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae347499f0f66a02b59b30de3caef5e6d">&#9670;&nbsp;</a></span>router()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_router.html">Router</a>* Task::router </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the router to which this task belongs. </p>

</div>
</div>
<a id="a27af9c4a1a02a5e085e72c138943b9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27af9c4a1a02a5e085e72c138943b9cb">&#9670;&nbsp;</a></span>master()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Master * Task::master </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the master where this task will be scheduled. </p>

</div>
</div>
<a id="a9f1f8c7d7d446650c3435a012c8b91bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f1f8c7d7d446650c3435a012c8b91bf">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, and optionally schedule it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">owner</td><td>specifies the element owning the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> </td></tr>
    <tr><td class="paramname">schedule</td><td>if true, the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> will be scheduled immediately</td></tr>
  </table>
  </dd>
</dl>
<p>This function must be called on every <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> before it is used. The corresponding router's ThreadSched, if any, is used to determine the task's initial thread assignment. The task initially has the default number of tickets, and is scheduled iff <em>schedule</em> is true.</p>
<p>An assertion will fail if a <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> is initialized twice.</p>
<p>Most elements call ScheduleInfo::initialize_task() to initialize a <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> object. The ScheduleInfo method additionally sets the task's scheduling parameters, such as ticket count and thread preference, based on a router's ScheduleInfo. ScheduleInfo::initialize_task() calls <a class="el" href="class_task.html#a9f1f8c7d7d446650c3435a012c8b91bf" title="Initialize the Task, and optionally schedule it. ">Task::initialize()</a>. </p>

</div>
</div>
<a id="a2266dfe38a41434d302e712fc7fdc230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2266dfe38a41434d302e712fc7fdc230">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task::initialize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_router.html">Router</a> *&#160;</td>
          <td class="paramname"><em>router</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>schedule</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, and optionally schedule it. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">router</td><td>specifies the router owning the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> </td></tr>
    <tr><td class="paramname">schedule</td><td>if true, the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> will be scheduled immediately</td></tr>
  </table>
  </dd>
</dl>
<p>This function is shorthand for <a class="el" href="class_task.html#a9f1f8c7d7d446650c3435a012c8b91bf">Task::initialize</a>(<em>router</em> -&gt;<a class="el" href="class_router.html#af48a295b245f7cde02c5c030498df8a3">root_element</a>(), <em>scheduled</em>). However, it is better to explicitly associate tasks with real elements. </p>

</div>
</div>
<a id="a481866bfe2f4f439b949706c679ece1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481866bfe2f4f439b949706c679ece1a">&#9670;&nbsp;</a></span>scheduled()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Task::scheduled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the task is currently scheduled to run. </p>
<dl class="section note"><dt>Note</dt><dd>A scheduled task will usually run very soon, but not always; due to locking issues, the effects of some <a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590" title="Reschedule the task. ">reschedule()</a> requests may be delayed. Although a task unscheduled with <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule()</a> may appear <a class="el" href="class_task.html#a481866bfe2f4f439b949706c679ece1a" title="Return true iff the task is currently scheduled to run. ">scheduled()</a>, it will not run until <a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule()</a> is called. </dd></dl>

</div>
</div>
<a id="ab98c3ba90bbded1d55c3dacce8961c3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab98c3ba90bbded1d55c3dacce8961c3a">&#9670;&nbsp;</a></span>unschedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::unschedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unschedule the task. </p>
<p>After <a class="el" href="class_task.html#ab98c3ba90bbded1d55c3dacce8961c3a" title="Unschedule the task. ">unschedule()</a> returns, the task will not run until it is rescheduled with <a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590" title="Reschedule the task. ">reschedule()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590" title="Reschedule the task. ">reschedule</a>, <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule</a> </dd></dl>

</div>
</div>
<a id="a3d8fd2f8c0d227d7be13742c1dd56590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d8fd2f8c0d227d7be13742c1dd56590">&#9670;&nbsp;</a></span>reschedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::reschedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reschedule the task. </p>
<p>The task is rescheduled on its home thread. It will eventually run, unless its home thread is quiescent or it has been <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule()</a>d.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#ab98c3ba90bbded1d55c3dacce8961c3a" title="Unschedule the task. ">unschedule</a>, <a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule</a> </dd></dl>

</div>
</div>
<a id="ae1253ff52ca19fb20393f0285787c23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1253ff52ca19fb20393f0285787c23c">&#9670;&nbsp;</a></span>fast_reschedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::fast_reschedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reschedule a task from the task's callback function. </p>
<dl class="section warning"><dt>Warning</dt><dd>Only call <em>task.fast_reschedule()</em> while <em>task</em> is being fired, i.e., in its callback function. It is an error to call .<a class="el" href="class_task.html#ae1253ff52ca19fb20393f0285787c23c" title="Reschedule a task from the task&#39;s callback function. ">fast_reschedule()</a> at other times &ndash; the task may not actually be rescheduled.</dd></dl>
<p>Here's a typical, correct use of <a class="el" href="class_task.html#ae1253ff52ca19fb20393f0285787c23c" title="Reschedule a task from the task&#39;s callback function. ">fast_reschedule()</a>:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyElement : <span class="keyword">public</span> <a class="code" href="class_element.html">Element</a> {</div><div class="line">    ... <a class="code" href="class_task.html">Task</a> _task; ... <span class="keywordtype">bool</span> run_task(<a class="code" href="class_task.html">Task</a> *t); ...</div><div class="line">};</div><div class="line"><span class="keywordtype">bool</span> MyElement::run_task(<a class="code" href="class_task.html">Task</a> *) {</div><div class="line">    do_some_work();</div><div class="line">    _task.fast_reschedule();</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p>This assumes, however, that run_task() is only called directly by the driver. If you call run_task() from another context, _task may not actually be scheduled.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> MyElement::run_timer(<a class="code" href="class_timer.html">Timer</a> *) {</div><div class="line">    run_task();   <span class="comment">// XXX might not reschedule _task!</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="aa7bf5b861d3f092df74e6b51a00f0ce8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7bf5b861d3f092df74e6b51a00f0ce8">&#9670;&nbsp;</a></span>strong_unschedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::strong_unschedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unschedule the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> until <a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule()</a>. </p>
<p>Like <a class="el" href="class_task.html#ab98c3ba90bbded1d55c3dacce8961c3a" title="Unschedule the task. ">unschedule()</a>, but in addition, future <a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590" title="Reschedule the task. ">reschedule()</a> calls will not actually schedule the task. Only after <a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule()</a> will the task run again. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a4b4f97540cff46af5393885f66c3fbc8" title="Reschedule the Task, undoing a prior strong_unschedule(). ">strong_reschedule</a>, <a class="el" href="class_task.html#ab98c3ba90bbded1d55c3dacce8961c3a" title="Unschedule the task. ">unschedule</a> </dd></dl>

</div>
</div>
<a id="a4b4f97540cff46af5393885f66c3fbc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b4f97540cff46af5393885f66c3fbc8">&#9670;&nbsp;</a></span>strong_reschedule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::strong_reschedule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reschedule the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>, undoing a prior <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule()</a>. </p>
<p>This function undoes any previous <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule()</a> and reschedules the task. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a3d8fd2f8c0d227d7be13742c1dd56590" title="Reschedule the task. ">reschedule</a>, <a class="el" href="class_task.html#aa7bf5b861d3f092df74e6b51a00f0ce8" title="Unschedule the Task until strong_reschedule(). ">strong_unschedule</a> </dd></dl>

</div>
</div>
<a id="a2ac36e7534b8a08146927a0417e7cfdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac36e7534b8a08146927a0417e7cfdc">&#9670;&nbsp;</a></span>move_thread()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Task::move_thread </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_thread_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a> to a new home thread. </p>
<p>The home thread ID is set to <em>new_thread_id</em>. The task, if it is currently scheduled, is rescheduled on thread <em>new_thread_id</em> (which generally takes some time to take effect). If <em>new_thread_id</em> is less than zero or greater than the number of threads on the router, the task is scheduled on a quiescent thread that never actually runs. </p>

</div>
</div>
<a id="a708786d60ce709f0c6b8569afdffcdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708786d60ce709f0c6b8569afdffcdf7">&#9670;&nbsp;</a></span>tickets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int Task::tickets </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the task's number of tickets. </p>
<p>Tasks with larger numbers of tickets are scheduled more often. Tasks are initialized with <a class="el" href="class_task.html#a708786d60ce709f0c6b8569afdffcdf7" title="Return the task&#39;s number of tickets. ">tickets()</a> == DEFAULT_TICKETS.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a24bef57ec630b9ce96fa485640591a2a" title="Set the task&#39;s ticket count. ">set_tickets</a>, <a class="el" href="class_task.html#a2674fc14867cee946f074ef06c3a6a9d" title="Add delta to the Task&#39;s ticket count. ">adjust_tickets</a> </dd></dl>

</div>
</div>
<a id="a24bef57ec630b9ce96fa485640591a2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24bef57ec630b9ce96fa485640591a2a">&#9670;&nbsp;</a></span>set_tickets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::set_tickets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the task's ticket count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n</td><td>the ticket count</td></tr>
  </table>
  </dd>
</dl>
<p>The ticket count <em>n</em> is pinned to the range [1, MAX_TICKETS].</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a708786d60ce709f0c6b8569afdffcdf7" title="Return the task&#39;s number of tickets. ">tickets</a>, <a class="el" href="class_task.html#a2674fc14867cee946f074ef06c3a6a9d" title="Add delta to the Task&#39;s ticket count. ">adjust_tickets</a> </dd></dl>

</div>
</div>
<a id="a2674fc14867cee946f074ef06c3a6a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2674fc14867cee946f074ef06c3a6a9d">&#9670;&nbsp;</a></span>adjust_tickets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Task::adjust_tickets </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>delta</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add <em>delta</em> to the <a class="el" href="class_task.html" title="Represents a frequently-scheduled computational task. ">Task</a>'s ticket count. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">delta</td><td>adjustment to the ticket count</td></tr>
  </table>
  </dd>
</dl>
<p>The ticket count cannot be adjusted below 1 or above MAX_TICKETS.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_task.html#a24bef57ec630b9ce96fa485640591a2a" title="Set the task&#39;s ticket count. ">set_tickets</a> </dd></dl>

</div>
</div>
<a id="a3cf45c723dc8901383da016dc316ce21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cf45c723dc8901383da016dc316ce21">&#9670;&nbsp;</a></span>fire()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Task::fire </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fire the task by calling its callback function. </p>
<p>This function is generally called by the <a class="el" href="class_router_thread.html" title="A set of Tasks scheduled on the same CPU. ">RouterThread</a> implementation; there should be no need to call it yourself. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/click/<a class="el" href="task_8hh_source.html">task.hh</a></li>
<li>lib/task.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 13 2017 20:11:40 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
