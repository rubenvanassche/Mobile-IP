<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Click: Args Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Click
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="class_args-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Args Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Argument parser class.  
 <a href="class_args.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="args_8hh_source.html">args.hh</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Args:</div>
<div class="dyncontent">
 <div class="center">
  <img src="class_args.png" usemap="#Args_map" alt=""/>
  <map id="Args_map" name="Args_map">
<area href="class_arg_context.html" title="Argument context class. " alt="ArgContext" shape="rect" coords="0,0,75,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7aa513f5fd0698757052b3500694d716"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a7aa513f5fd0698757052b3500694d716">Args</a> (<a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a7aa513f5fd0698757052b3500694d716"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument parser.  <a href="#a7aa513f5fd0698757052b3500694d716">More...</a><br /></td></tr>
<tr class="separator:a7aa513f5fd0698757052b3500694d716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acbf9e1762e0a7d7a0097f45e8f3a8c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a0acbf9e1762e0a7d7a0097f45e8f3a8c">Args</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, <a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a0acbf9e1762e0a7d7a0097f45e8f3a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument parser parsing a copy of <em>conf</em>.  <a href="#a0acbf9e1762e0a7d7a0097f45e8f3a8c">More...</a><br /></td></tr>
<tr class="separator:a0acbf9e1762e0a7d7a0097f45e8f3a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50940b8f19e3518ef6dc3bc3b69aa16c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a50940b8f19e3518ef6dc3bc3b69aa16c">Args</a> (const <a class="el" href="class_element.html">Element</a> *<a class="el" href="class_arg_context.html#a98327f6cae962ec49c18b7413dbb046f">context</a>, <a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a50940b8f19e3518ef6dc3bc3b69aa16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument parser.  <a href="#a50940b8f19e3518ef6dc3bc3b69aa16c">More...</a><br /></td></tr>
<tr class="separator:a50940b8f19e3518ef6dc3bc3b69aa16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8645d2c69de37dede9f86ca0e031aa44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a8645d2c69de37dede9f86ca0e031aa44">Args</a> (const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf, const <a class="el" href="class_element.html">Element</a> *<a class="el" href="class_arg_context.html#a98327f6cae962ec49c18b7413dbb046f">context</a>, <a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a8645d2c69de37dede9f86ca0e031aa44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument parser parsing a copy of <em>conf</em>.  <a href="#a8645d2c69de37dede9f86ca0e031aa44">More...</a><br /></td></tr>
<tr class="separator:a8645d2c69de37dede9f86ca0e031aa44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf4cc85c8b8574ef2d48bad5ce156ed3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#acf4cc85c8b8574ef2d48bad5ce156ed3">Args</a> (const <a class="el" href="class_args.html">Args</a> &amp;x)</td></tr>
<tr class="memdesc:acf4cc85c8b8574ef2d48bad5ce156ed3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct an argument parser.  <a href="#acf4cc85c8b8574ef2d48bad5ce156ed3">More...</a><br /></td></tr>
<tr class="separator:acf4cc85c8b8574ef2d48bad5ce156ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89a861c843bd1954a801bbbd8aea0f4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a89a861c843bd1954a801bbbd8aea0f4b">operator=</a> (const <a class="el" href="class_args.html">Args</a> &amp;x)</td></tr>
<tr class="memdesc:a89a861c843bd1954a801bbbd8aea0f4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign to a copy of <em>x</em>.  <a href="#a89a861c843bd1954a801bbbd8aea0f4b">More...</a><br /></td></tr>
<tr class="separator:a89a861c843bd1954a801bbbd8aea0f4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c34859f9933afc5da5542497775c87"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#ab3c34859f9933afc5da5542497775c87">empty</a> () const</td></tr>
<tr class="memdesc:ab3c34859f9933afc5da5542497775c87"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff this parser has no arguments or results.  <a href="#ab3c34859f9933afc5da5542497775c87">More...</a><br /></td></tr>
<tr class="separator:ab3c34859f9933afc5da5542497775c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74287212310bb7b4db76dd5880707ab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a74287212310bb7b4db76dd5880707ab7">results_empty</a> () const</td></tr>
<tr class="memdesc:a74287212310bb7b4db76dd5880707ab7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff this parser has no results.  <a href="#a74287212310bb7b4db76dd5880707ab7">More...</a><br /></td></tr>
<tr class="separator:a74287212310bb7b4db76dd5880707ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704400569a5b9c3c24050b45c4169034"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a704400569a5b9c3c24050b45c4169034">clear</a> ()</td></tr>
<tr class="memdesc:a704400569a5b9c3c24050b45c4169034"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all arguments.  <a href="#a704400569a5b9c3c24050b45c4169034">More...</a><br /></td></tr>
<tr class="separator:a704400569a5b9c3c24050b45c4169034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c25fdc2fbdff25df523332557c0d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a930c25fdc2fbdff25df523332557c0d7">bind</a> (<a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;conf)</td></tr>
<tr class="memdesc:a930c25fdc2fbdff25df523332557c0d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bind this parser's arguments to <em>conf</em>.  <a href="#a930c25fdc2fbdff25df523332557c0d7">More...</a><br /></td></tr>
<tr class="separator:a930c25fdc2fbdff25df523332557c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9992ef3d5ec275d2a84c3518f8b99a84"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a9992ef3d5ec275d2a84c3518f8b99a84">push_back</a> (const <a class="el" href="class_string.html">String</a> &amp;arg)</td></tr>
<tr class="memdesc:a9992ef3d5ec275d2a84c3518f8b99a84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append argument <em>arg</em> to this parser.  <a href="#a9992ef3d5ec275d2a84c3518f8b99a84">More...</a><br /></td></tr>
<tr class="separator:a9992ef3d5ec275d2a84c3518f8b99a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fa99ec2b2599e3cf92fdebc8a156cea"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a8fa99ec2b2599e3cf92fdebc8a156cea"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a8fa99ec2b2599e3cf92fdebc8a156cea">push_back</a> (Iter begin, Iter end)</td></tr>
<tr class="memdesc:a8fa99ec2b2599e3cf92fdebc8a156cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append arguments in the range [<em>begin</em>, <em>end</em>) to this parser.  <a href="#a8fa99ec2b2599e3cf92fdebc8a156cea">More...</a><br /></td></tr>
<tr class="separator:a8fa99ec2b2599e3cf92fdebc8a156cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fc0251982bc76f4959e139a729f4111"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a9fc0251982bc76f4959e139a729f4111">push_back_words</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a9fc0251982bc76f4959e139a729f4111"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the space-separated words in <em>str</em> to this parser.  <a href="#a9fc0251982bc76f4959e139a729f4111">More...</a><br /></td></tr>
<tr class="separator:a9fc0251982bc76f4959e139a729f4111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb7e6dd9923ca56c7124ff4eab5ea90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a2cb7e6dd9923ca56c7124ff4eab5ea90">push_back_args</a> (const <a class="el" href="class_string.html">String</a> &amp;str)</td></tr>
<tr class="memdesc:a2cb7e6dd9923ca56c7124ff4eab5ea90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append the comma-separated arguments in <em>str</em> to this parser.  <a href="#a2cb7e6dd9923ca56c7124ff4eab5ea90">More...</a><br /></td></tr>
<tr class="separator:a2cb7e6dd9923ca56c7124ff4eab5ea90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b9a3bd5ce129ae24aca60c7acec90df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a8b9a3bd5ce129ae24aca60c7acec90df">reset</a> ()</td></tr>
<tr class="memdesc:a8b9a3bd5ce129ae24aca60c7acec90df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reset the parse status for every argument.  <a href="#a8b9a3bd5ce129ae24aca60c7acec90df">More...</a><br /></td></tr>
<tr class="separator:a8b9a3bd5ce129ae24aca60c7acec90df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b80585207c901659c91b52e221d552"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a41b80585207c901659c91b52e221d552"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a> (const char *keyword, T &amp;x)</td></tr>
<tr class="memdesc:a41b80585207c901659c91b52e221d552"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an argument using its type's default parser.  <a href="#a41b80585207c901659c91b52e221d552">More...</a><br /></td></tr>
<tr class="separator:a41b80585207c901659c91b52e221d552"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15972a114b85bd33e9a38e9662d3cb94"><td class="memTemplParams" colspan="2"><a id="a15972a114b85bd33e9a38e9662d3cb94"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a15972a114b85bd33e9a38e9662d3cb94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_m</b> (const char *keyword, T &amp;x)</td></tr>
<tr class="separator:a15972a114b85bd33e9a38e9662d3cb94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dceaa7f0b2da6b3fc407f551dbd1cb2"><td class="memTemplParams" colspan="2"><a id="a3dceaa7f0b2da6b3fc407f551dbd1cb2"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3dceaa7f0b2da6b3fc407f551dbd1cb2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_p</b> (const char *keyword, T &amp;x)</td></tr>
<tr class="separator:a3dceaa7f0b2da6b3fc407f551dbd1cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e138ed983ca25f9f087a3c6b96ed18"><td class="memTemplParams" colspan="2"><a id="a17e138ed983ca25f9f087a3c6b96ed18"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a17e138ed983ca25f9f087a3c6b96ed18"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_mp</b> (const char *keyword, T &amp;x)</td></tr>
<tr class="separator:a17e138ed983ca25f9f087a3c6b96ed18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b63771c7ac9eeba77e87e388d91563"><td class="memTemplParams" colspan="2"><a id="a32b63771c7ac9eeba77e87e388d91563"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32b63771c7ac9eeba77e87e388d91563"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read</b> (const char *keyword, int flags, T &amp;x)</td></tr>
<tr class="separator:a32b63771c7ac9eeba77e87e388d91563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79803daada7ddef34c5fa8465f34c9aa"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a79803daada7ddef34c5fa8465f34c9aa"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a79803daada7ddef34c5fa8465f34c9aa">read_or_set</a> (const char *keyword, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="memdesc:a79803daada7ddef34c5fa8465f34c9aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an argument using the default parser, or set it to a default value if the argument is was not supplied.  <a href="#a79803daada7ddef34c5fa8465f34c9aa">More...</a><br /></td></tr>
<tr class="separator:a79803daada7ddef34c5fa8465f34c9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829922beda7ad3e4832d67a7868903f9"><td class="memTemplParams" colspan="2"><a id="a829922beda7ad3e4832d67a7868903f9"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:a829922beda7ad3e4832d67a7868903f9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_or_set_p</b> (const char *keyword, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="separator:a829922beda7ad3e4832d67a7868903f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac112a77e28b01b3a72b1a499c13ae679"><td class="memTemplParams" colspan="2"><a id="ac112a77e28b01b3a72b1a499c13ae679"></a>
template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ac112a77e28b01b3a72b1a499c13ae679"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_or_set</b> (const char *keyword, int flags, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="separator:ac112a77e28b01b3a72b1a499c13ae679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc18aabd29c1d1cfdf74aef0d28d3c68"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:abc18aabd29c1d1cfdf74aef0d28d3c68"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#abc18aabd29c1d1cfdf74aef0d28d3c68">read</a> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="memdesc:abc18aabd29c1d1cfdf74aef0d28d3c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an argument using a specified parser.  <a href="#abc18aabd29c1d1cfdf74aef0d28d3c68">More...</a><br /></td></tr>
<tr class="separator:abc18aabd29c1d1cfdf74aef0d28d3c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714a8645eed140fcd03bfac6721eea94"><td class="memTemplParams" colspan="2"><a id="a714a8645eed140fcd03bfac6721eea94"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a714a8645eed140fcd03bfac6721eea94"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_m</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:a714a8645eed140fcd03bfac6721eea94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc7ed1ca211ddba727247af130e7e80"><td class="memTemplParams" colspan="2"><a id="abdc7ed1ca211ddba727247af130e7e80"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:abdc7ed1ca211ddba727247af130e7e80"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_p</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:abdc7ed1ca211ddba727247af130e7e80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a901f8b37cdd36bc661ce55e75925ff5c"><td class="memTemplParams" colspan="2"><a id="a901f8b37cdd36bc661ce55e75925ff5c"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a901f8b37cdd36bc661ce55e75925ff5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_mp</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:a901f8b37cdd36bc661ce55e75925ff5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03b9f78f094ebec991760e10cb9bcf06"><td class="memTemplParams" colspan="2"><a id="a03b9f78f094ebec991760e10cb9bcf06"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a03b9f78f094ebec991760e10cb9bcf06"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read</b> (const char *keyword, int flags, P parser, T &amp;x)</td></tr>
<tr class="separator:a03b9f78f094ebec991760e10cb9bcf06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1a79b0f1b24c4ecc54d40b00dbc213"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T , typename V &gt; </td></tr>
<tr class="memitem:aeb1a79b0f1b24c4ecc54d40b00dbc213"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#aeb1a79b0f1b24c4ecc54d40b00dbc213">read_or_set</a> (const char *keyword, P parser, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="memdesc:aeb1a79b0f1b24c4ecc54d40b00dbc213"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an argument using a specified parser, or set it to a default value if the argument is was not supplied.  <a href="#aeb1a79b0f1b24c4ecc54d40b00dbc213">More...</a><br /></td></tr>
<tr class="separator:aeb1a79b0f1b24c4ecc54d40b00dbc213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8807c3d73c1c7b712afe1b681bdf3d9c"><td class="memTemplParams" colspan="2"><a id="a8807c3d73c1c7b712afe1b681bdf3d9c"></a>
template&lt;typename P , typename T , typename V &gt; </td></tr>
<tr class="memitem:a8807c3d73c1c7b712afe1b681bdf3d9c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_or_set_p</b> (const char *keyword, P parser, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="separator:a8807c3d73c1c7b712afe1b681bdf3d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41e24e0b7581e48ba98ac5c5907bbc7"><td class="memTemplParams" colspan="2"><a id="af41e24e0b7581e48ba98ac5c5907bbc7"></a>
template&lt;typename P , typename T , typename V &gt; </td></tr>
<tr class="memitem:af41e24e0b7581e48ba98ac5c5907bbc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_or_set</b> (const char *keyword, int flags, P parser, T &amp;x, const V &amp;default_value)</td></tr>
<tr class="separator:af41e24e0b7581e48ba98ac5c5907bbc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75fc02b42f4a57d1eae93ced28b8cbb"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af75fc02b42f4a57d1eae93ced28b8cbb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#af75fc02b42f4a57d1eae93ced28b8cbb">read</a> (const char *keyword, P parser, T1 &amp;x1, T2 &amp;x2)</td></tr>
<tr class="memdesc:af75fc02b42f4a57d1eae93ced28b8cbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an argument using a specified parser with two results.  <a href="#af75fc02b42f4a57d1eae93ced28b8cbb">More...</a><br /></td></tr>
<tr class="separator:af75fc02b42f4a57d1eae93ced28b8cbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3f272b1214db022f9527257a20bb3f1"><td class="memTemplParams" colspan="2"><a id="ad3f272b1214db022f9527257a20bb3f1"></a>
template&lt;typename P , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ad3f272b1214db022f9527257a20bb3f1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_m</b> (const char *keyword, P parser, T1 &amp;x1, T2 &amp;x2)</td></tr>
<tr class="separator:ad3f272b1214db022f9527257a20bb3f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7a1be3695bb5d5c2d1b548ad30c3a9"><td class="memTemplParams" colspan="2"><a id="acf7a1be3695bb5d5c2d1b548ad30c3a9"></a>
template&lt;typename P , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:acf7a1be3695bb5d5c2d1b548ad30c3a9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_p</b> (const char *keyword, P parser, T1 &amp;x1, T2 &amp;x2)</td></tr>
<tr class="separator:acf7a1be3695bb5d5c2d1b548ad30c3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9391514f7d8e13d5f40dd5500363de78"><td class="memTemplParams" colspan="2"><a id="a9391514f7d8e13d5f40dd5500363de78"></a>
template&lt;typename P , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a9391514f7d8e13d5f40dd5500363de78"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_mp</b> (const char *keyword, P parser, T1 &amp;x1, T2 &amp;x2)</td></tr>
<tr class="separator:a9391514f7d8e13d5f40dd5500363de78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54854b516e953812dec61fc0e0fbe2cc"><td class="memTemplParams" colspan="2"><a id="a54854b516e953812dec61fc0e0fbe2cc"></a>
template&lt;typename P , typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a54854b516e953812dec61fc0e0fbe2cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read</b> (const char *keyword, int flags, P parser, T1 &amp;x1, T2 &amp;x2)</td></tr>
<tr class="separator:a54854b516e953812dec61fc0e0fbe2cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a539960c5e58ddc337ddac96aabb688"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a9a539960c5e58ddc337ddac96aabb688"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a9a539960c5e58ddc337ddac96aabb688">read_with</a> (const char *keyword, P parser)</td></tr>
<tr class="memdesc:a9a539960c5e58ddc337ddac96aabb688"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an argument to a specified parser.  <a href="#a9a539960c5e58ddc337ddac96aabb688">More...</a><br /></td></tr>
<tr class="separator:a9a539960c5e58ddc337ddac96aabb688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09af0352feda7bb16c36c5ffddcb1dff"><td class="memTemplParams" colspan="2"><a id="a09af0352feda7bb16c36c5ffddcb1dff"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a09af0352feda7bb16c36c5ffddcb1dff"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_m_with</b> (const char *keyword, P parser)</td></tr>
<tr class="separator:a09af0352feda7bb16c36c5ffddcb1dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf47646a5085b1497bf4dd46be948e93"><td class="memTemplParams" colspan="2"><a id="abf47646a5085b1497bf4dd46be948e93"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:abf47646a5085b1497bf4dd46be948e93"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_p_with</b> (const char *keyword, P parser)</td></tr>
<tr class="separator:abf47646a5085b1497bf4dd46be948e93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c84951b0adae24e2d75cfcd5ed16e5c"><td class="memTemplParams" colspan="2"><a id="a7c84951b0adae24e2d75cfcd5ed16e5c"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:a7c84951b0adae24e2d75cfcd5ed16e5c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_mp_with</b> (const char *keyword, P parser)</td></tr>
<tr class="separator:a7c84951b0adae24e2d75cfcd5ed16e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b3a0059ff41d1dee53cec2d2189872"><td class="memTemplParams" colspan="2"><a id="ad0b3a0059ff41d1dee53cec2d2189872"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:ad0b3a0059ff41d1dee53cec2d2189872"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_with</b> (const char *keyword, int flags, P parser)</td></tr>
<tr class="separator:ad0b3a0059ff41d1dee53cec2d2189872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b3f0cff628da89e7714265869350cc7"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a0b3f0cff628da89e7714265869350cc7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a0b3f0cff628da89e7714265869350cc7">read_with</a> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="memdesc:a0b3f0cff628da89e7714265869350cc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass an argument to a specified parser.  <a href="#a0b3f0cff628da89e7714265869350cc7">More...</a><br /></td></tr>
<tr class="separator:a0b3f0cff628da89e7714265869350cc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41c4f12a69b0c68201aac412a7bfdb1"><td class="memTemplParams" colspan="2"><a id="ad41c4f12a69b0c68201aac412a7bfdb1"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:ad41c4f12a69b0c68201aac412a7bfdb1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_m_with</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:ad41c4f12a69b0c68201aac412a7bfdb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b2b52d56c3d840ce1424bea848ff905"><td class="memTemplParams" colspan="2"><a id="a5b2b52d56c3d840ce1424bea848ff905"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a5b2b52d56c3d840ce1424bea848ff905"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_p_with</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:a5b2b52d56c3d840ce1424bea848ff905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab178c6b66f66fa09848ba2acea43f4ac"><td class="memTemplParams" colspan="2"><a id="ab178c6b66f66fa09848ba2acea43f4ac"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:ab178c6b66f66fa09848ba2acea43f4ac"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_mp_with</b> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="separator:ab178c6b66f66fa09848ba2acea43f4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb56ef842643545203496ce68636589"><td class="memTemplParams" colspan="2"><a id="a4cb56ef842643545203496ce68636589"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a4cb56ef842643545203496ce68636589"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_with</b> (const char *keyword, int flags, P parser, T &amp;x)</td></tr>
<tr class="separator:a4cb56ef842643545203496ce68636589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c392796d1f11434ad4e9c351e2c24dd"><td class="memTemplParams" colspan="2">template&lt;typename P &gt; </td></tr>
<tr class="memitem:a0c392796d1f11434ad4e9c351e2c24dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a0c392796d1f11434ad4e9c351e2c24dd">read_all_with</a> (const char *keyword, P parser)</td></tr>
<tr class="memdesc:a0c392796d1f11434ad4e9c351e2c24dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass all matching arguments to a specified parser.  <a href="#a0c392796d1f11434ad4e9c351e2c24dd">More...</a><br /></td></tr>
<tr class="separator:a0c392796d1f11434ad4e9c351e2c24dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6e30a15480c640a545aeb2c3b26f176"><td class="memTemplParams" colspan="2"><a id="af6e30a15480c640a545aeb2c3b26f176"></a>
template&lt;typename P &gt; </td></tr>
<tr class="memitem:af6e30a15480c640a545aeb2c3b26f176"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_all_with</b> (const char *keyword, int flags, P parser)</td></tr>
<tr class="separator:af6e30a15480c640a545aeb2c3b26f176"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61d4b3db100a9d7ec3a3b36c5563ebad"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a61d4b3db100a9d7ec3a3b36c5563ebad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a61d4b3db100a9d7ec3a3b36c5563ebad">read_all_with</a> (const char *keyword, P parser, T &amp;x)</td></tr>
<tr class="memdesc:a61d4b3db100a9d7ec3a3b36c5563ebad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass all matching arguments to a specified parser.  <a href="#a61d4b3db100a9d7ec3a3b36c5563ebad">More...</a><br /></td></tr>
<tr class="separator:a61d4b3db100a9d7ec3a3b36c5563ebad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dade9baa3c422491e8e4c1b12a4ebba"><td class="memTemplParams" colspan="2"><a id="a9dade9baa3c422491e8e4c1b12a4ebba"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a9dade9baa3c422491e8e4c1b12a4ebba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_all_with</b> (const char *keyword, int flags, P parser, T &amp;x)</td></tr>
<tr class="separator:a9dade9baa3c422491e8e4c1b12a4ebba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c8c5fc53b3676965af5a1c09a975b10"><td class="memTemplParams" colspan="2">template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a6c8c5fc53b3676965af5a1c09a975b10"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#a6c8c5fc53b3676965af5a1c09a975b10">read_all</a> (const char *keyword, P parser, <a class="el" href="class_vector.html">Vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="memdesc:a6c8c5fc53b3676965af5a1c09a975b10"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass all matching arguments to a specified parser.  <a href="#a6c8c5fc53b3676965af5a1c09a975b10">More...</a><br /></td></tr>
<tr class="separator:a6c8c5fc53b3676965af5a1c09a975b10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7249875e03bc247974cd664b04c7b17b"><td class="memTemplParams" colspan="2"><a id="a7249875e03bc247974cd664b04c7b17b"></a>
template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7249875e03bc247974cd664b04c7b17b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_all</b> (const char *keyword, <a class="el" href="class_vector.html">Vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a7249875e03bc247974cd664b04c7b17b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac16e8b9ab6bc3c45e988258839b131"><td class="memTemplParams" colspan="2"><a id="aaac16e8b9ab6bc3c45e988258839b131"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:aaac16e8b9ab6bc3c45e988258839b131"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_all</b> (const char *keyword, int flags, P parser, <a class="el" href="class_vector.html">Vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:aaac16e8b9ab6bc3c45e988258839b131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec956b59e8f7adbbc8f4d580d9f8e81"><td class="memTemplParams" colspan="2"><a id="a2ec956b59e8f7adbbc8f4d580d9f8e81"></a>
template&lt;typename P , typename T &gt; </td></tr>
<tr class="memitem:a2ec956b59e8f7adbbc8f4d580d9f8e81"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>read_all</b> (const char *keyword, int flags, <a class="el" href="class_vector.html">Vector</a>&lt; T &gt; &amp;x)</td></tr>
<tr class="separator:a2ec956b59e8f7adbbc8f4d580d9f8e81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1abe7d2a822257ffbe234682df172566"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a1abe7d2a822257ffbe234682df172566">status</a> () const</td></tr>
<tr class="memdesc:a1abe7d2a822257ffbe234682df172566"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the current parse status.  <a href="#a1abe7d2a822257ffbe234682df172566">More...</a><br /></td></tr>
<tr class="separator:a1abe7d2a822257ffbe234682df172566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9831ca722456b01613bb5425e1b3049"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#aa9831ca722456b01613bb5425e1b3049">status</a> (bool &amp;x)</td></tr>
<tr class="memdesc:aa9831ca722456b01613bb5425e1b3049"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>x</em> to the current parse status.  <a href="#aa9831ca722456b01613bb5425e1b3049">More...</a><br /></td></tr>
<tr class="separator:aa9831ca722456b01613bb5425e1b3049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3083b5c47264eef3fb1b7066abecf3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a6c3083b5c47264eef3fb1b7066abecf3">status</a> (bool &amp;x) const</td></tr>
<tr class="separator:a6c3083b5c47264eef3fb1b7066abecf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b119f1208446eaef56a56af1250bef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a31b119f1208446eaef56a56af1250bef">read_status</a> () const</td></tr>
<tr class="memdesc:a31b119f1208446eaef56a56af1250bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true iff the last read request succeeded.  <a href="#a31b119f1208446eaef56a56af1250bef">More...</a><br /></td></tr>
<tr class="separator:a31b119f1208446eaef56a56af1250bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b63f9369d10e3d8ce84d2e17e0cc916"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a2b63f9369d10e3d8ce84d2e17e0cc916">read_status</a> (bool &amp;x)</td></tr>
<tr class="memdesc:a2b63f9369d10e3d8ce84d2e17e0cc916"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set <em>x</em> to the success status of the last read request.  <a href="#a2b63f9369d10e3d8ce84d2e17e0cc916">More...</a><br /></td></tr>
<tr class="separator:a2b63f9369d10e3d8ce84d2e17e0cc916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3494f66d3bac0716b46a036c3724bd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a1b3494f66d3bac0716b46a036c3724bd">read_status</a> (bool &amp;x) const</td></tr>
<tr class="separator:a1b3494f66d3bac0716b46a036c3724bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bea2b7f87e9ac89ebff9c0d641e4f3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a0bea2b7f87e9ac89ebff9c0d641e4f3c">strip</a> ()</td></tr>
<tr class="memdesc:a0bea2b7f87e9ac89ebff9c0d641e4f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all arguments matched so far.  <a href="#a0bea2b7f87e9ac89ebff9c0d641e4f3c">More...</a><br /></td></tr>
<tr class="separator:a0bea2b7f87e9ac89ebff9c0d641e4f3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa343628e90ba0c9ef7f9507169d01c47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#aa343628e90ba0c9ef7f9507169d01c47">execute</a> ()</td></tr>
<tr class="memdesc:aa343628e90ba0c9ef7f9507169d01c47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign results.  <a href="#aa343628e90ba0c9ef7f9507169d01c47">More...</a><br /></td></tr>
<tr class="separator:aa343628e90ba0c9ef7f9507169d01c47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba08300119a05294177811c00656259"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a7ba08300119a05294177811c00656259">consume</a> ()</td></tr>
<tr class="memdesc:a7ba08300119a05294177811c00656259"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign results and remove matched arguments.  <a href="#a7ba08300119a05294177811c00656259">More...</a><br /></td></tr>
<tr class="separator:a7ba08300119a05294177811c00656259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bae5bd2b8383351a05ebf77df36ad68"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a8bae5bd2b8383351a05ebf77df36ad68">complete</a> ()</td></tr>
<tr class="memdesc:a8bae5bd2b8383351a05ebf77df36ad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign results if all arguments matched.  <a href="#a8bae5bd2b8383351a05ebf77df36ad68">More...</a><br /></td></tr>
<tr class="separator:a8bae5bd2b8383351a05ebf77df36ad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8b8aa8fc0cfe67ed0de40b440bb0dff"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad8b8aa8fc0cfe67ed0de40b440bb0dff"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#ad8b8aa8fc0cfe67ed0de40b440bb0dff">slot</a> (T &amp;x)</td></tr>
<tr class="memdesc:ad8b8aa8fc0cfe67ed0de40b440bb0dff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a result slot for <em>x</em>.  <a href="#ad8b8aa8fc0cfe67ed0de40b440bb0dff">More...</a><br /></td></tr>
<tr class="separator:ad8b8aa8fc0cfe67ed0de40b440bb0dff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8627c13eeeb7e0fdb705a565a3084e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af8627c13eeeb7e0fdb705a565a3084e7"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#af8627c13eeeb7e0fdb705a565a3084e7">initialized_slot</a> (T &amp;x)</td></tr>
<tr class="memdesc:af8627c13eeeb7e0fdb705a565a3084e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create and return a result slot for <em>x</em>.  <a href="#af8627c13eeeb7e0fdb705a565a3084e7">More...</a><br /></td></tr>
<tr class="separator:af8627c13eeeb7e0fdb705a565a3084e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a0652c743d64dfa371b46b0ebb465e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ac7a0652c743d64dfa371b46b0ebb465e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_args.html">Args</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_args.html#ac7a0652c743d64dfa371b46b0ebb465e">set</a> (T &amp;x, const V &amp;value)</td></tr>
<tr class="memdesc:ac7a0652c743d64dfa371b46b0ebb465e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a result that assigns <em>x</em> to <em>value</em>.  <a href="#ac7a0652c743d64dfa371b46b0ebb465e">More...</a><br /></td></tr>
<tr class="separator:ac7a0652c743d64dfa371b46b0ebb465e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_arg_context"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_arg_context')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_arg_context.html">ArgContext</a></td></tr>
<tr class="memitem:a8648014801772955d74a179b8100e0eb inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a8648014801772955d74a179b8100e0eb">ArgContext</a> (<a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a8648014801772955d74a179b8100e0eb inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument context.  <a href="class_arg_context.html#a8648014801772955d74a179b8100e0eb">More...</a><br /></td></tr>
<tr class="separator:a8648014801772955d74a179b8100e0eb inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b789f4f23f422cd0d64931a7b5cd3d inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a85b789f4f23f422cd0d64931a7b5cd3d">ArgContext</a> (const <a class="el" href="class_element.html">Element</a> *<a class="el" href="class_arg_context.html#a98327f6cae962ec49c18b7413dbb046f">context</a>, <a class="el" href="class_error_handler.html">ErrorHandler</a> *<a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a>=0)</td></tr>
<tr class="memdesc:a85b789f4f23f422cd0d64931a7b5cd3d inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct an argument context.  <a href="class_arg_context.html#a85b789f4f23f422cd0d64931a7b5cd3d">More...</a><br /></td></tr>
<tr class="separator:a85b789f4f23f422cd0d64931a7b5cd3d inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98327f6cae962ec49c18b7413dbb046f inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a98327f6cae962ec49c18b7413dbb046f">context</a> () const</td></tr>
<tr class="memdesc:a98327f6cae962ec49c18b7413dbb046f inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the element context.  <a href="class_arg_context.html#a98327f6cae962ec49c18b7413dbb046f">More...</a><br /></td></tr>
<tr class="separator:a98327f6cae962ec49c18b7413dbb046f inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8abebd3ba79f8f470e95031a79712624 inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">errh</a> () const</td></tr>
<tr class="memdesc:a8abebd3ba79f8f470e95031a79712624 inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the associated error handler.  <a href="class_arg_context.html#a8abebd3ba79f8f470e95031a79712624">More...</a><br /></td></tr>
<tr class="separator:a8abebd3ba79f8f470e95031a79712624 inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab71d40eff403ce178ee0fe5e826746a0 inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_string.html">String</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#ab71d40eff403ce178ee0fe5e826746a0">error_prefix</a> () const</td></tr>
<tr class="memdesc:ab71d40eff403ce178ee0fe5e826746a0 inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a prefix string associated with the current argument.  <a href="class_arg_context.html#ab71d40eff403ce178ee0fe5e826746a0">More...</a><br /></td></tr>
<tr class="separator:ab71d40eff403ce178ee0fe5e826746a0 inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad7d09fe6ef277d9a227781a73fbc87 inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a8ad7d09fe6ef277d9a227781a73fbc87">error</a> (const char *fmt,...) const</td></tr>
<tr class="memdesc:a8ad7d09fe6ef277d9a227781a73fbc87 inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a parse error for the current argument.  <a href="class_arg_context.html#a8ad7d09fe6ef277d9a227781a73fbc87">More...</a><br /></td></tr>
<tr class="separator:a8ad7d09fe6ef277d9a227781a73fbc87 inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acadb535ef1c1800005933da8589a3c0f inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#acadb535ef1c1800005933da8589a3c0f">warning</a> (const char *fmt,...) const</td></tr>
<tr class="memdesc:acadb535ef1c1800005933da8589a3c0f inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a parse warning for the current argument.  <a href="class_arg_context.html#acadb535ef1c1800005933da8589a3c0f">More...</a><br /></td></tr>
<tr class="separator:acadb535ef1c1800005933da8589a3c0f inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ca2a5d37dc90b388179dd81dce44327 inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_arg_context.html#a4ca2a5d37dc90b388179dd81dce44327">message</a> (const char *fmt,...) const</td></tr>
<tr class="memdesc:a4ca2a5d37dc90b388179dd81dce44327 inherit pub_methods_class_arg_context"><td class="mdescLeft">&#160;</td><td class="mdescRight">Report a message for the current argument.  <a href="class_arg_context.html#a4ca2a5d37dc90b388179dd81dce44327">More...</a><br /></td></tr>
<tr class="separator:a4ca2a5d37dc90b388179dd81dce44327 inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0039c9f1fe3c2cd3cfd3a0740b79cd inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="adc0039c9f1fe3c2cd3cfd3a0740b79cd"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xmessage</b> (const <a class="el" href="class_string.html">String</a> &amp;anno, const <a class="el" href="class_string.html">String</a> &amp;str) const</td></tr>
<tr class="separator:adc0039c9f1fe3c2cd3cfd3a0740b79cd inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2818113177635dc7f35a5e9d7ed10df2 inherit pub_methods_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="a2818113177635dc7f35a5e9d7ed10df2"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>xmessage</b> (const <a class="el" href="class_string.html">String</a> &amp;anno, const char *fmt, va_list val) const</td></tr>
<tr class="separator:a2818113177635dc7f35a5e9d7ed10df2 inherit pub_methods_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa09961d018d5899659de7eb9c9234c7c"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#aa09961d018d5899659de7eb9c9234c7c">mandatory</a> = 1</td></tr>
<tr class="memdesc:aa09961d018d5899659de7eb9c9234c7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">read flag for mandatory arguments  <a href="#aa09961d018d5899659de7eb9c9234c7c">More...</a><br /></td></tr>
<tr class="separator:aa09961d018d5899659de7eb9c9234c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52e212bf2f015e04a31deb10c18c3d47"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a52e212bf2f015e04a31deb10c18c3d47">positional</a> = 2</td></tr>
<tr class="memdesc:a52e212bf2f015e04a31deb10c18c3d47"><td class="mdescLeft">&#160;</td><td class="mdescRight">read flag for positional arguments  <a href="#a52e212bf2f015e04a31deb10c18c3d47">More...</a><br /></td></tr>
<tr class="separator:a52e212bf2f015e04a31deb10c18c3d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c870e1974e168ee06323cb1771af763"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a4c870e1974e168ee06323cb1771af763">deprecated</a> = 4</td></tr>
<tr class="memdesc:a4c870e1974e168ee06323cb1771af763"><td class="mdescLeft">&#160;</td><td class="mdescRight">read flag for deprecated arguments  <a href="#a4c870e1974e168ee06323cb1771af763">More...</a><br /></td></tr>
<tr class="separator:a4c870e1974e168ee06323cb1771af763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a075319dd228bb1c7734df704210804ae"><td class="memItemLeft" align="right" valign="top">static constexpr int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_args.html#a075319dd228bb1c7734df704210804ae">firstmatch</a> = 8</td></tr>
<tr class="memdesc:a075319dd228bb1c7734df704210804ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">read flag to take first matching argument  <a href="#a075319dd228bb1c7734df704210804ae">More...</a><br /></td></tr>
<tr class="separator:a075319dd228bb1c7734df704210804ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pro_attribs_class_arg_context"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_class_arg_context')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="class_arg_context.html">ArgContext</a></td></tr>
<tr class="memitem:acada71a62adea8f3037e9af4e7441d53 inherit pro_attribs_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="acada71a62adea8f3037e9af4e7441d53"></a>
const <a class="el" href="class_element.html">Element</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_context</b></td></tr>
<tr class="separator:acada71a62adea8f3037e9af4e7441d53 inherit pro_attribs_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a153f975d9c3ae7156264f6f24fd550 inherit pro_attribs_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="a1a153f975d9c3ae7156264f6f24fd550"></a>
<a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_errh</b></td></tr>
<tr class="separator:a1a153f975d9c3ae7156264f6f24fd550 inherit pro_attribs_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac95ebf23ec3bed5aa76ee1d0f8eada inherit pro_attribs_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="a7ac95ebf23ec3bed5aa76ee1d0f8eada"></a>
const char *&#160;</td><td class="memItemRight" valign="bottom"><b>_arg_keyword</b></td></tr>
<tr class="separator:a7ac95ebf23ec3bed5aa76ee1d0f8eada inherit pro_attribs_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad759362c9aac936945377a303e3ed51d inherit pro_attribs_class_arg_context"><td class="memItemLeft" align="right" valign="top"><a id="ad759362c9aac936945377a303e3ed51d"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_read_status</b></td></tr>
<tr class="separator:ad759362c9aac936945377a303e3ed51d inherit pro_attribs_class_arg_context"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Argument parser class. </p>
<p>never <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> parses Click configuration strings in a type-safe manner.</p>
<p><a class="el" href="class_args.html" title="Argument parser class. ">Args</a> manages <em>arguments</em> and <em>result slots</em>. Arguments are strings to be parsed and result slots are parsed values.</p>
<p>The <a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552" title="Read an argument using its type&#39;s default parser. ">read()</a> functions parse arguments into result slots.</p>
<div class="fragment"><div class="line"><a class="code" href="class_args.html">Args</a> args;</div><div class="line">args.<a class="code" href="class_args.html#a9992ef3d5ec275d2a84c3518f8b99a84">push_back</a>(<span class="stringliteral">&quot;A 1&quot;</span>); <span class="comment">// add argument</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a_result;</div><div class="line">args.<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;A&quot;</span>, a_result); <span class="comment">// parse &quot;A&quot; into a result slot</span></div></div><!-- fragment --><p>As arguments are parsed, <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> marks them off and adds new result slots. Each result slot is paired with a variable belonging to the caller. However, the caller's variables aren't modified until the parse <em>executes</em> via <a class="el" href="class_args.html#a8bae5bd2b8383351a05ebf77df36ad68" title="Assign results if all arguments matched. ">complete()</a>, <a class="el" href="class_args.html#a7ba08300119a05294177811c00656259" title="Assign results and remove matched arguments. ">consume()</a>, or <a class="el" href="class_args.html#aa343628e90ba0c9ef7f9507169d01c47" title="Assign results. ">execute()</a>.</p>
<div class="fragment"><div class="line"><a class="code" href="class_args.html">Args</a> args; args.<a class="code" href="class_args.html#a9992ef3d5ec275d2a84c3518f8b99a84">push_back</a>(<span class="stringliteral">&quot;A 1&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a_result = 0;</div><div class="line">args.<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;A&quot;</span>, a_result);</div><div class="line">assert(a_result == 0);  <span class="comment">// parsed value not yet assigned</span></div><div class="line">args.<a class="code" href="class_args.html#aa343628e90ba0c9ef7f9507169d01c47">execute</a>();         <span class="comment">// this call assigns results</span></div><div class="line">assert(a_result == 1);</div></div><!-- fragment --><p>If <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> encounters a parse error, then execution doesn't modify <em>any</em> of the caller's variables.</p>
<div class="fragment"><div class="line"><a class="code" href="class_args.html">Args</a> args; args.<a class="code" href="class_args.html#a9992ef3d5ec275d2a84c3518f8b99a84">push_back</a>(<span class="stringliteral">&quot;A 1, B NOT_AN_INTEGER&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a_result = 0, b_result = 0;</div><div class="line">args.<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;A&quot;</span>, a_result)   <span class="comment">// succeeds</span></div><div class="line">    .<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;B&quot;</span>, b_result)   <span class="comment">// fails, since B is not an integer</span></div><div class="line">    .<a class="code" href="class_args.html#aa343628e90ba0c9ef7f9507169d01c47">execute</a>();</div><div class="line">assert(a_result == 0 &amp;&amp; b_result == 0);</div></div><!-- fragment --><p>Each <a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552" title="Read an argument using its type&#39;s default parser. ">read()</a> function comes in five variants. <a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552" title="Read an argument using its type&#39;s default parser. ">read()</a> reads an optional keyword argument. read_m() reads a mandatory keyword argument: if the argument was not supplied, <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> will report a parse error. read_p() reads an optional positional argument. If the keyword was not supplied, but a positional argument was, that is used. read_mp() reads a mandatory positional argument. Positional arguments are parsed in order. The fifth variant of <a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552" title="Read an argument using its type&#39;s default parser. ">read()</a> takes an integer <em>flags</em> argument; flags include <a class="el" href="class_args.html#a52e212bf2f015e04a31deb10c18c3d47" title="read flag for positional arguments ">Args::positional</a>, <a class="el" href="class_args.html#aa09961d018d5899659de7eb9c9234c7c" title="read flag for mandatory arguments ">Args::mandatory</a>, and others, such as <a class="el" href="class_args.html#a4c870e1974e168ee06323cb1771af763" title="read flag for deprecated arguments ">Args::deprecated</a>.</p>
<p>The <a class="el" href="class_args.html#a8bae5bd2b8383351a05ebf77df36ad68" title="Assign results if all arguments matched. ">complete()</a> execution method checks that every argument has been successfully parsed and reports an error if not. <a class="el" href="class_args.html#a7ba08300119a05294177811c00656259" title="Assign results and remove matched arguments. ">consume()</a> doesn't check for completion, but removes parsed arguments from the argument set. Execution methods return 0 on success and &lt;0 on failure. You can check the parse status before execution using <a class="el" href="class_args.html#a1abe7d2a822257ffbe234682df172566" title="Return the current parse status. ">status()</a>.</p>
<p><a class="el" href="class_args.html" title="Argument parser class. ">Args</a> methods are designed to chain. All <a class="el" href="class_args.html#a41b80585207c901659c91b52e221d552" title="Read an argument using its type&#39;s default parser. ">read()</a> methods (and some others) return a reference to the <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> itself. It is often possible to parse a whole set of arguments using a single temporary <a class="el" href="class_args.html" title="Argument parser class. ">Args</a>. For example:</p>
<div class="fragment"><div class="line"><a class="code" href="class_vector.html">Vector&lt;String&gt;</a> conf;</div><div class="line">conf.<a class="code" href="class_vector.html#a2d312373a3b228bb597b3a4c04970776">push_back</a>(<span class="stringliteral">&quot;A 1&quot;</span>);</div><div class="line">conf.<a class="code" href="class_vector.html#a2d312373a3b228bb597b3a4c04970776">push_back</a>(<span class="stringliteral">&quot;B 2&quot;</span>);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> a, b;</div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_args.html#a7aa513f5fd0698757052b3500694d716">Args</a>(conf).<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;A&quot;</span>, a)</div><div class="line">    .<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;B&quot;</span>, b)</div><div class="line">    .<a class="code" href="class_args.html#a8bae5bd2b8383351a05ebf77df36ad68">complete</a>() &gt;= 0)</div><div class="line">    click_chatter(<span class="stringliteral">&quot;Success! a=%d, b=%d&quot;</span>, a, b);</div></div><!-- fragment --><p>The actual work of parsing is handled by <em>parser objects</em>. Many common variable types have default parsers defined by the DefaultArg&lt;T&gt; template. For example, the default parser for an integer value understands the common textual representations of integers. You can also pass a parser explicitly. For example:</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> a, b, c;</div><div class="line">args.<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;A&quot;</span>, a)      <span class="comment">// parse A using DefaultArg&lt;int&gt; = IntArg()</span></div><div class="line">    .<a class="code" href="class_args.html#a41b80585207c901659c91b52e221d552">read</a>(<span class="stringliteral">&quot;B&quot;</span>, <a class="code" href="class_int_arg.html">IntArg</a>(2), b);   <span class="comment">// parse B using IntArg(2): base-2</span></div></div><!-- fragment --><p><a class="el" href="class_args.html" title="Argument parser class. ">Args</a> generally calls a parser object's parse() method with three arguments:</p>
<ol>
<li>
const <a class="el" href="class_string.html" title="A string of characters. ">String</a> &amp;<b>str</b>: The string to be parsed. </li>
<li>
T &amp;<b>result</b>: A reference to the result. The parsed value, if any, should be stored here. (This points to storage local to <a class="el" href="class_args.html" title="Argument parser class. ">Args</a>, not to the caller's variable.) </li>
<li>
<a class="el" href="class_args.html" title="Argument parser class. ">Args</a> &amp;<b>args</b>: A reference to the calling <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> object, for error reporting. </li>
</ol>
<p>The parse() method should return true if the parse succeeds and false if it fails. Type-specific error messages should be reported using methods like <b>args</b>.<a class="el" href="class_arg_context.html#a8ad7d09fe6ef277d9a227781a73fbc87" title="Report a parse error for the current argument. ">error()</a>. For generic errors, the parse() method can simply return false; <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> will generate a "KEYWORD: parse error" message.</p>
<p>Most parsers are <em>disciplined</em>, meaning that they modify <b>result</b> only if the parse succeeds. This doesn't matter in the context of <a class="el" href="class_args.html" title="Argument parser class. ">Args</a>, but can matter to users who call a parse function directly. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7aa513f5fd0698757052b3500694d716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa513f5fd0698757052b3500694d716">&#9670;&nbsp;</a></span>Args() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args::Args </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an argument parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0acbf9e1762e0a7d7a0097f45e8f3a8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acbf9e1762e0a7d7a0097f45e8f3a8c">&#9670;&nbsp;</a></span>Args() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args::Args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an argument parser parsing a copy of <em>conf</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>list of configuration arguments </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a50940b8f19e3518ef6dc3bc3b69aa16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50940b8f19e3518ef6dc3bc3b69aa16c">&#9670;&nbsp;</a></span>Args() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args::Args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an argument parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>optional element context </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8645d2c69de37dede9f86ca0e031aa44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8645d2c69de37dede9f86ca0e031aa44">&#9670;&nbsp;</a></span>Args() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args::Args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_element.html">Element</a> *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_error_handler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errh</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct an argument parser parsing a copy of <em>conf</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>list of configuration arguments </td></tr>
    <tr><td class="paramname">context</td><td>optional element context </td></tr>
    <tr><td class="paramname">errh</td><td>optional error handler </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acf4cc85c8b8574ef2d48bad5ce156ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf4cc85c8b8574ef2d48bad5ce156ed3">&#9670;&nbsp;</a></span>Args() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Args::Args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_args.html">Args</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy construct an argument parser. </p>
<dl class="section note"><dt>Note</dt><dd><em>x's</em> results are not copied. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a89a861c843bd1954a801bbbd8aea0f4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89a861c843bd1954a801bbbd8aea0f4b">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_args.html">Args</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign to a copy of <em>x</em>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><a class="el" href="class_args.html#a74287212310bb7b4db76dd5880707ab7" title="Return true iff this parser has no results. ">results_empty()</a> &amp;&amp; <em>x.results_empty()</em> </dd></dl>

</div>
</div>
<a id="ab3c34859f9933afc5da5542497775c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c34859f9933afc5da5542497775c87">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Args::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff this parser has no arguments or results. </p>

</div>
</div>
<a id="a74287212310bb7b4db76dd5880707ab7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74287212310bb7b4db76dd5880707ab7">&#9670;&nbsp;</a></span>results_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Args::results_empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff this parser has no results. </p>

</div>
</div>
<a id="a704400569a5b9c3c24050b45c4169034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704400569a5b9c3c24050b45c4169034">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a930c25fdc2fbdff25df523332557c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930c25fdc2fbdff25df523332557c0d7">&#9670;&nbsp;</a></span>bind()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::bind </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; <a class="el" href="class_string.html">String</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>conf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bind this parser's arguments to <em>conf</em>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">conf</td><td>reference to new arguments </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>This <a class="el" href="class_args.html" title="Argument parser class. ">Args</a> shares <em>conf</em> with the caller. For instance, <a class="el" href="class_args.html#a7ba08300119a05294177811c00656259" title="Assign results and remove matched arguments. ">consume()</a> will modify <em>conf</em>. </dd></dl>

</div>
</div>
<a id="a9992ef3d5ec275d2a84c3518f8b99a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9992ef3d5ec275d2a84c3518f8b99a84">&#9670;&nbsp;</a></span>push_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::push_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append argument <em>arg</em> to this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a8fa99ec2b2599e3cf92fdebc8a156cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fa99ec2b2599e3cf92fdebc8a156cea">&#9670;&nbsp;</a></span>push_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::push_back </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append arguments in the range [<em>begin</em>, <em>end</em>) to this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a9fc0251982bc76f4959e139a729f4111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fc0251982bc76f4959e139a729f4111">&#9670;&nbsp;</a></span>push_back_words()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::push_back_words </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the space-separated words in <em>str</em> to this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a2cb7e6dd9923ca56c7124ff4eab5ea90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb7e6dd9923ca56c7124ff4eab5ea90">&#9670;&nbsp;</a></span>push_back_args()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::push_back_args </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_string.html">String</a> &amp;&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Append the comma-separated arguments in <em>str</em> to this parser. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a8b9a3bd5ce129ae24aca60c7acec90df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b9a3bd5ce129ae24aca60c7acec90df">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reset the parse status for every argument. </p>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>For example: </p><div class="fragment"><div class="line"><a class="code" href="class_vector.html">Vector&lt;String&gt;</a> conf; conf.<a class="code" href="class_vector.html#a2d312373a3b228bb597b3a4c04970776">push_back</a>(<span class="stringliteral">&quot;1&quot;</span>); conf.<a class="code" href="class_vector.html#a2d312373a3b228bb597b3a4c04970776">push_back</a>(<span class="stringliteral">&quot;2&quot;</span>);</div><div class="line"><span class="keywordtype">int</span> a, b;</div><div class="line"><a class="code" href="class_args.html#a7aa513f5fd0698757052b3500694d716">Args</a>(conf).read_p(<span class="stringliteral">&quot;A&quot;</span>, a).read_p(<span class="stringliteral">&quot;B&quot;</span>, b).execute();</div><div class="line">assert(a == 1 &amp;&amp; b == 2);</div><div class="line"><a class="code" href="class_args.html#a7aa513f5fd0698757052b3500694d716">Args</a>(conf).read_p(<span class="stringliteral">&quot;A&quot;</span>, a).reset().read_p(<span class="stringliteral">&quot;B&quot;</span>, b).execute();</div><div class="line">assert(a == 1 &amp;&amp; b == 1);</div></div><!-- fragment --><p> Results are not affected. </p>

</div>
</div>
<a id="a41b80585207c901659c91b52e221d552"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b80585207c901659c91b52e221d552">&#9670;&nbsp;</a></span>read() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an argument using its type's default parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">x</td><td>reference to result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result slot for <em>x</em> and calls DefaultArg&lt;T&gt;().parse(string, result, *this). </p>

</div>
</div>
<a id="a79803daada7ddef34c5fa8465f34c9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79803daada7ddef34c5fa8465f34c9aa">&#9670;&nbsp;</a></span>read_or_set() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_or_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an argument using the default parser, or set it to a default value if the argument is was not supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">x</td><td>reference to result </td></tr>
    <tr><td class="paramname">default_value</td><td>default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result slot for <em>x</em>. If <em>keyword</em> was supplied, calls DefaultArg&lt;T&gt;().parse(string, result, this). Otherwise, assigns the result to <em>value</em>. </p>

</div>
</div>
<a id="abc18aabd29c1d1cfdf74aef0d28d3c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc18aabd29c1d1cfdf74aef0d28d3c68">&#9670;&nbsp;</a></span>read() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an argument using a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x</td><td>reference to result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result slot for <em>x</em> and calls <em>parser.parse</em>(string, result, *this). </p>

</div>
</div>
<a id="aeb1a79b0f1b24c4ecc54d40b00dbc213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1a79b0f1b24c4ecc54d40b00dbc213">&#9670;&nbsp;</a></span>read_or_set() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_or_set </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>default_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an argument using a specified parser, or set it to a default value if the argument is was not supplied. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x</td><td>reference to result variable </td></tr>
    <tr><td class="paramname">default_value</td><td>default value </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result slot for <em>x</em>. If argument <em>keyword</em> was supplied, calls <em>parser.parse(string, result, *this)</em>. Otherwise, assigns the result to <em>default_value</em>. </p>

</div>
</div>
<a id="af75fc02b42f4a57d1eae93ced28b8cbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af75fc02b42f4a57d1eae93ced28b8cbb">&#9670;&nbsp;</a></span>read() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T1 &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T2 &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an argument using a specified parser with two results. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x1</td><td>reference to first result </td></tr>
    <tr><td class="paramname">x2</td><td>reference to second result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates results for <em>x1</em> and <em>x2</em> and calls <em>parser.parse</em>(string, result1, result2, *this). </p>

</div>
</div>
<a id="a9a539960c5e58ddc337ddac96aabb688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a539960c5e58ddc337ddac96aabb688">&#9670;&nbsp;</a></span>read_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass an argument to a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Calls <em>parser.parse(string, *this)</em>. </p>

</div>
</div>
<a id="a0b3f0cff628da89e7714265869350cc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b3f0cff628da89e7714265869350cc7">&#9670;&nbsp;</a></span>read_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass an argument to a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x</td><td>reference to result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result slot for <em>x</em> and calls <em>parser.parse</em>(string, result, *this).</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>Use read(keyword, parser, variable) instead. </dd></dl>

</div>
</div>
<a id="a0c392796d1f11434ad4e9c351e2c24dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c392796d1f11434ad4e9c351e2c24dd">&#9670;&nbsp;</a></span>read_all_with() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_all_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass all matching arguments to a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Calls <em>parser.parse(string, *this)</em> zero or more times.</p>
<dl class="section note"><dt>Note</dt><dd>The value of <a class="el" href="class_args.html#a31b119f1208446eaef56a56af1250bef" title="Return true iff the last read request succeeded. ">read_status()</a> is true iff at least one argument matched and all matching arguments successfully parsed. </dd></dl>

</div>
</div>
<a id="a61d4b3db100a9d7ec3a3b36c5563ebad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61d4b3db100a9d7ec3a3b36c5563ebad">&#9670;&nbsp;</a></span>read_all_with() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_all_with </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass all matching arguments to a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x</td><td>reference to result </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>Creates a result for <em>x</em> and calls <em>parser.parse</em>(string, result, *this) zero or more times, once per matching argument.</p>
<dl class="section note"><dt>Note</dt><dd>The value of <a class="el" href="class_args.html#a31b119f1208446eaef56a56af1250bef" title="Return true iff the last read request succeeded. ">read_status()</a> is true iff at least one argument matched and all matching arguments successfully parsed. </dd></dl>

</div>
</div>
<a id="a6c8c5fc53b3676965af5a1c09a975b10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c8c5fc53b3676965af5a1c09a975b10">&#9670;&nbsp;</a></span>read_all()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename P , typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_all </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keyword</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">P&#160;</td>
          <td class="paramname"><em>parser</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_vector.html">Vector</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass all matching arguments to a specified parser. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keyword</td><td>argument name </td></tr>
    <tr><td class="paramname">parser</td><td>parser object </td></tr>
    <tr><td class="paramname">x</td><td>reference to vector of results </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>*this</dd></dl>
<p>For each <em>keyword</em> argument, calls <em>parser.parse</em>(string, value, *this). The resulting values are collected into a vector result slot for <em>x</em>.</p>
<dl class="section note"><dt>Note</dt><dd>The value of <a class="el" href="class_args.html#a31b119f1208446eaef56a56af1250bef" title="Return true iff the last read request succeeded. ">read_status()</a> is true iff at least one argument matched and all matching arguments successfully parsed. </dd></dl>

</div>
</div>
<a id="a1abe7d2a822257ffbe234682df172566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1abe7d2a822257ffbe234682df172566">&#9670;&nbsp;</a></span>status() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Args::status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the current parse status. </p>

</div>
</div>
<a id="aa9831ca722456b01613bb5425e1b3049"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9831ca722456b01613bb5425e1b3049">&#9670;&nbsp;</a></span>status() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::status </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>x</em> to the current parse status. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<a id="a6c3083b5c47264eef3fb1b7066abecf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3083b5c47264eef3fb1b7066abecf3">&#9670;&nbsp;</a></span>status() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_args.html">Args</a>&amp; Args::status </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a31b119f1208446eaef56a56af1250bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b119f1208446eaef56a56af1250bef">&#9670;&nbsp;</a></span>read_status() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool Args::read_status </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true iff the last read request succeeded. </p>
<p>This function should only be called after a read. </p>

</div>
</div>
<a id="a2b63f9369d10e3d8ce84d2e17e0cc916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b63f9369d10e3d8ce84d2e17e0cc916">&#9670;&nbsp;</a></span>read_status() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::read_status </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set <em>x</em> to the success status of the last read request. </p>
<p>This function should only be called after a read. </p>

</div>
</div>
<a id="a1b3494f66d3bac0716b46a036c3724bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3494f66d3bac0716b46a036c3724bd">&#9670;&nbsp;</a></span>read_status() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_args.html">Args</a>&amp; Args::read_status </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is an overloaded member function, provided for convenience. It differs from the above function only in what argument(s) it accepts. </p>

</div>
</div>
<a id="a0bea2b7f87e9ac89ebff9c0d641e4f3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bea2b7f87e9ac89ebff9c0d641e4f3c">&#9670;&nbsp;</a></span>strip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a> &amp; Args::strip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all arguments matched so far. </p>

</div>
</div>
<a id="aa343628e90ba0c9ef7f9507169d01c47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa343628e90ba0c9ef7f9507169d01c47">&#9670;&nbsp;</a></span>execute()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Args::execute </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign results. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the parse succeeded, &lt;0 otherwise </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_args.html#a74287212310bb7b4db76dd5880707ab7" title="Return true iff this parser has no results. ">results_empty()</a></dd></dl>
<p>Results are only assigned if <a class="el" href="class_args.html#a1abe7d2a822257ffbe234682df172566" title="Return the current parse status. ">status()</a> is true (the parse is successful so far). Clears results as a side effect. </p>

</div>
</div>
<a id="a7ba08300119a05294177811c00656259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ba08300119a05294177811c00656259">&#9670;&nbsp;</a></span>consume()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Args::consume </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign results and remove matched arguments. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the parse succeeded, &lt;0 otherwise </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_args.html#a74287212310bb7b4db76dd5880707ab7" title="Return true iff this parser has no results. ">results_empty()</a></dd></dl>
<p>Matched arguments are always removed. Results are only assigned if <a class="el" href="class_args.html#a1abe7d2a822257ffbe234682df172566" title="Return the current parse status. ">status()</a> is true (the parse is successful so far). Clears results as a side effect. </p>

</div>
</div>
<a id="a8bae5bd2b8383351a05ebf77df36ad68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bae5bd2b8383351a05ebf77df36ad68">&#9670;&nbsp;</a></span>complete()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int Args::complete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign results if all arguments matched. </p>
<dl class="section return"><dt>Returns</dt><dd>0 if the parse succeeded, &lt;0 otherwise </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd><a class="el" href="class_args.html#a74287212310bb7b4db76dd5880707ab7" title="Return true iff this parser has no results. ">results_empty()</a></dd></dl>
<p>Results are only assigned if <a class="el" href="class_args.html#a1abe7d2a822257ffbe234682df172566" title="Return the current parse status. ">status()</a> is true (the parse is successful so far) and all arguments have been parsed. Clears results as a side effect. </p>

</div>
</div>
<a id="ad8b8aa8fc0cfe67ed0de40b440bb0dff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8b8aa8fc0cfe67ed0de40b440bb0dff">&#9670;&nbsp;</a></span>slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* Args::slot </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a result slot for <em>x</em>. </p>
<p>If T is a trivially copyable type, such as int, then the resulting slot might not be initialized. </p>

</div>
</div>
<a id="af8627c13eeeb7e0fdb705a565a3084e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8627c13eeeb7e0fdb705a565a3084e7">&#9670;&nbsp;</a></span>initialized_slot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* Args::initialized_slot </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create and return a result slot for <em>x</em>. </p>
<p>The resulting slot is always default-initialized. </p>

</div>
</div>
<a id="ac7a0652c743d64dfa371b46b0ebb465e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a0652c743d64dfa371b46b0ebb465e">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_args.html">Args</a>&amp; Args::set </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const V &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a result that assigns <em>x</em> to <em>value</em>. </p>
<dl class="section return"><dt>Returns</dt><dd>*this </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa09961d018d5899659de7eb9c9234c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa09961d018d5899659de7eb9c9234c7c">&#9670;&nbsp;</a></span>mandatory</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Args::mandatory = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read flag for mandatory arguments </p>

</div>
</div>
<a id="a52e212bf2f015e04a31deb10c18c3d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52e212bf2f015e04a31deb10c18c3d47">&#9670;&nbsp;</a></span>positional</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Args::positional = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read flag for positional arguments </p>

</div>
</div>
<a id="a4c870e1974e168ee06323cb1771af763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c870e1974e168ee06323cb1771af763">&#9670;&nbsp;</a></span>deprecated</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Args::deprecated = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read flag for deprecated arguments </p>

</div>
</div>
<a id="a075319dd228bb1c7734df704210804ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a075319dd228bb1c7734df704210804ae">&#9670;&nbsp;</a></span>firstmatch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int Args::firstmatch = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>read flag to take first matching argument </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/click/<a class="el" href="args_8hh_source.html">args.hh</a></li>
<li>lib/args.cc</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 13 2017 20:11:39 for Click by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
